var mablPdfViewer;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/annotation_layer_builder.js":
/*!*****************************************!*\
  !*** ./src/annotation_layer_builder.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationLayerBuilder": () => (/* binding */ AnnotationLayerBuilder),
/* harmony export */   "DefaultAnnotationLayerFactory": () => (/* binding */ DefaultAnnotationLayerFactory)
/* harmony export */ });
/* harmony import */ var _mabl_pdf_js_build_pdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mabl/pdf.js/build/pdf */ "./src/pdf_js/build/pdf.js");
/* harmony import */ var _mabl_pdf_js_build_pdf__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mabl_pdf_js_build_pdf__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui_utils */ "./src/ui_utils.js");
/* harmony import */ var _pdf_link_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pdf_link_service */ "./src/pdf_link_service.js");
/* Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @typedef {Object} AnnotationLayerBuilderOptions
 * @property {HTMLDivElement} pageDiv
 * @property {PDFPage} pdfPage
 * @property {string} imageResourcesPath - (optional) Path for image resources,
 *   mainly for annotation icons. Include trailing slash.
 * @property {boolean} renderInteractiveForms
 * @property {IPDFLinkService} linkService
 * @property {DownloadManager} downloadManager
 * @property {IL10n} l10n - Localization service.
 */

class AnnotationLayerBuilder {
  /**
   * @param {AnnotationLayerBuilderOptions} options
   */
  constructor(_ref) {
    var {
      pageDiv,
      pdfPage,
      linkService,
      downloadManager,
      imageResourcesPath = '',
      renderInteractiveForms = false,
      l10n = _ui_utils__WEBPACK_IMPORTED_MODULE_1__.NullL10n
    } = _ref;
    this.pageDiv = pageDiv;
    this.pdfPage = pdfPage;
    this.linkService = linkService;
    this.downloadManager = downloadManager;
    this.imageResourcesPath = imageResourcesPath;
    this.renderInteractiveForms = renderInteractiveForms;
    this.l10n = l10n;
    this.div = null;
    this._cancelled = false;
  }
  /**
   * @param {PageViewport} viewport
   * @param {string} intent (default value is 'display')
   */


  render(viewport) {
    var intent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'display';
    this.pdfPage.getAnnotations({
      intent
    }).then(annotations => {
      if (this._cancelled) {
        return;
      }

      var parameters = {
        viewport: viewport.clone({
          dontFlip: true
        }),
        div: this.div,
        annotations,
        page: this.pdfPage,
        imageResourcesPath: this.imageResourcesPath,
        renderInteractiveForms: this.renderInteractiveForms,
        linkService: this.linkService,
        downloadManager: this.downloadManager
      };

      if (this.div) {
        // If an annotationLayer already exists, refresh its children's
        // transformation matrices.
        _mabl_pdf_js_build_pdf__WEBPACK_IMPORTED_MODULE_0__.AnnotationLayer.update(parameters);
      } else {
        // Create an annotation layer div and render the annotations
        // if there is at least one annotation.
        if (annotations.length === 0) {
          return;
        }

        this.div = document.createElement('div');
        this.div.className = 'annotationLayer';
        this.pageDiv.appendChild(this.div);
        parameters.div = this.div;
        _mabl_pdf_js_build_pdf__WEBPACK_IMPORTED_MODULE_0__.AnnotationLayer.render(parameters);
        this.l10n.translate(this.div);
      }
    });
  }

  cancel() {
    this._cancelled = true;
  }

  hide() {
    if (!this.div) {
      return;
    }

    this.div.setAttribute('hidden', 'true');
  }

}
/**
 * @implements IPDFAnnotationLayerFactory
 */


class DefaultAnnotationLayerFactory {
  /**
   * @param {HTMLDivElement} pageDiv
   * @param {PDFPage} pdfPage
   * @param {string} imageResourcesPath - (optional) Path for image resources,
   *   mainly for annotation icons. Include trailing slash.
   * @param {boolean} renderInteractiveForms
   * @param {IL10n} l10n
   * @returns {AnnotationLayerBuilder}
   */
  createAnnotationLayerBuilder(pageDiv, pdfPage) {
    var imageResourcesPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var renderInteractiveForms = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var l10n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _ui_utils__WEBPACK_IMPORTED_MODULE_1__.NullL10n;
    return new AnnotationLayerBuilder({
      pageDiv,
      pdfPage,
      imageResourcesPath,
      renderInteractiveForms,
      linkService: new _pdf_link_service__WEBPACK_IMPORTED_MODULE_2__.SimpleLinkService(),
      l10n
    });
  }

}



/***/ }),

/***/ "./src/pdf_js/build/pdf.js":
/*!*********************************!*\
  !*** ./src/pdf_js/build/pdf.js ***!
  \*********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }

function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) { _classCheckPrivateStaticAccess(receiver, classConstructor); _classCheckPrivateStaticFieldDescriptor(descriptor, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) { _classCheckPrivateStaticAccess(receiver, classConstructor); _classCheckPrivateStaticFieldDescriptor(descriptor, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classCheckPrivateStaticFieldDescriptor(descriptor, action) { if (descriptor === undefined) { throw new TypeError("attempted to " + action + " private static field before its declaration"); } }

function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else {}
})(this, () => {
  return (
    /******/
    (() => {
      // webpackBootstrap

      /******/
      "use strict";
      /******/

      var __webpack_modules__ = [
        /* 0 */
      ,
      /* 1 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;
        exports.arrayByteLength = arrayByteLength;
        exports.arraysToBytes = arraysToBytes;
        exports.assert = assert;
        exports.bytesToString = bytesToString;
        exports.createPromiseCapability = createPromiseCapability;
        exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
        exports.escapeString = escapeString;
        exports.getModificationDate = getModificationDate;
        exports.getVerbosityLevel = getVerbosityLevel;
        exports.info = info;
        exports.isArrayBuffer = isArrayBuffer;
        exports.isArrayEqual = isArrayEqual;
        exports.isAscii = isAscii;
        exports.objectFromMap = objectFromMap;
        exports.objectSize = objectSize;
        exports.setVerbosityLevel = setVerbosityLevel;
        exports.shadow = shadow;
        exports.string32 = string32;
        exports.stringToBytes = stringToBytes;
        exports.stringToPDFString = stringToPDFString;
        exports.stringToUTF16BEString = stringToUTF16BEString;
        exports.stringToUTF8String = stringToUTF8String;
        exports.unreachable = unreachable;
        exports.utf8StringToString = utf8StringToString;
        exports.warn = warn;

        __w_pdfjs_require__(2);

        var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
        exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
        var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
        exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
        var RenderingIntentFlag = {
          ANY: 0x01,
          DISPLAY: 0x02,
          PRINT: 0x04,
          ANNOTATIONS_FORMS: 0x10,
          ANNOTATIONS_STORAGE: 0x20,
          ANNOTATIONS_DISABLE: 0x40,
          OPLIST: 0x100
        };
        exports.RenderingIntentFlag = RenderingIntentFlag;
        var AnnotationMode = {
          DISABLE: 0,
          ENABLE: 1,
          ENABLE_FORMS: 2,
          ENABLE_STORAGE: 3
        };
        exports.AnnotationMode = AnnotationMode;
        var PermissionFlag = {
          PRINT: 0x04,
          MODIFY_CONTENTS: 0x08,
          COPY: 0x10,
          MODIFY_ANNOTATIONS: 0x20,
          FILL_INTERACTIVE_FORMS: 0x100,
          COPY_FOR_ACCESSIBILITY: 0x200,
          ASSEMBLE: 0x400,
          PRINT_HIGH_QUALITY: 0x800
        };
        exports.PermissionFlag = PermissionFlag;
        var TextRenderingMode = {
          FILL: 0,
          STROKE: 1,
          FILL_STROKE: 2,
          INVISIBLE: 3,
          FILL_ADD_TO_PATH: 4,
          STROKE_ADD_TO_PATH: 5,
          FILL_STROKE_ADD_TO_PATH: 6,
          ADD_TO_PATH: 7,
          FILL_STROKE_MASK: 3,
          ADD_TO_PATH_FLAG: 4
        };
        exports.TextRenderingMode = TextRenderingMode;
        var ImageKind = {
          GRAYSCALE_1BPP: 1,
          RGB_24BPP: 2,
          RGBA_32BPP: 3
        };
        exports.ImageKind = ImageKind;
        var AnnotationType = {
          TEXT: 1,
          LINK: 2,
          FREETEXT: 3,
          LINE: 4,
          SQUARE: 5,
          CIRCLE: 6,
          POLYGON: 7,
          POLYLINE: 8,
          HIGHLIGHT: 9,
          UNDERLINE: 10,
          SQUIGGLY: 11,
          STRIKEOUT: 12,
          STAMP: 13,
          CARET: 14,
          INK: 15,
          POPUP: 16,
          FILEATTACHMENT: 17,
          SOUND: 18,
          MOVIE: 19,
          WIDGET: 20,
          SCREEN: 21,
          PRINTERMARK: 22,
          TRAPNET: 23,
          WATERMARK: 24,
          THREED: 25,
          REDACT: 26
        };
        exports.AnnotationType = AnnotationType;
        var AnnotationStateModelType = {
          MARKED: "Marked",
          REVIEW: "Review"
        };
        exports.AnnotationStateModelType = AnnotationStateModelType;
        var AnnotationMarkedState = {
          MARKED: "Marked",
          UNMARKED: "Unmarked"
        };
        exports.AnnotationMarkedState = AnnotationMarkedState;
        var AnnotationReviewState = {
          ACCEPTED: "Accepted",
          REJECTED: "Rejected",
          CANCELLED: "Cancelled",
          COMPLETED: "Completed",
          NONE: "None"
        };
        exports.AnnotationReviewState = AnnotationReviewState;
        var AnnotationReplyType = {
          GROUP: "Group",
          REPLY: "R"
        };
        exports.AnnotationReplyType = AnnotationReplyType;
        var AnnotationFlag = {
          INVISIBLE: 0x01,
          HIDDEN: 0x02,
          PRINT: 0x04,
          NOZOOM: 0x08,
          NOROTATE: 0x10,
          NOVIEW: 0x20,
          READONLY: 0x40,
          LOCKED: 0x80,
          TOGGLENOVIEW: 0x100,
          LOCKEDCONTENTS: 0x200
        };
        exports.AnnotationFlag = AnnotationFlag;
        var AnnotationFieldFlag = {
          READONLY: 0x0000001,
          REQUIRED: 0x0000002,
          NOEXPORT: 0x0000004,
          MULTILINE: 0x0001000,
          PASSWORD: 0x0002000,
          NOTOGGLETOOFF: 0x0004000,
          RADIO: 0x0008000,
          PUSHBUTTON: 0x0010000,
          COMBO: 0x0020000,
          EDIT: 0x0040000,
          SORT: 0x0080000,
          FILESELECT: 0x0100000,
          MULTISELECT: 0x0200000,
          DONOTSPELLCHECK: 0x0400000,
          DONOTSCROLL: 0x0800000,
          COMB: 0x1000000,
          RICHTEXT: 0x2000000,
          RADIOSINUNISON: 0x2000000,
          COMMITONSELCHANGE: 0x4000000
        };
        exports.AnnotationFieldFlag = AnnotationFieldFlag;
        var AnnotationBorderStyleType = {
          SOLID: 1,
          DASHED: 2,
          BEVELED: 3,
          INSET: 4,
          UNDERLINE: 5
        };
        exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
        var AnnotationActionEventType = {
          E: "Mouse Enter",
          X: "Mouse Exit",
          D: "Mouse Down",
          U: "Mouse Up",
          Fo: "Focus",
          Bl: "Blur",
          PO: "PageOpen",
          PC: "PageClose",
          PV: "PageVisible",
          PI: "PageInvisible",
          K: "Keystroke",
          F: "Format",
          V: "Validate",
          C: "Calculate"
        };
        exports.AnnotationActionEventType = AnnotationActionEventType;
        var DocumentActionEventType = {
          WC: "WillClose",
          WS: "WillSave",
          DS: "DidSave",
          WP: "WillPrint",
          DP: "DidPrint"
        };
        exports.DocumentActionEventType = DocumentActionEventType;
        var PageActionEventType = {
          O: "PageOpen",
          C: "PageClose"
        };
        exports.PageActionEventType = PageActionEventType;
        var StreamType = {
          UNKNOWN: "UNKNOWN",
          FLATE: "FLATE",
          LZW: "LZW",
          DCT: "DCT",
          JPX: "JPX",
          JBIG: "JBIG",
          A85: "A85",
          AHX: "AHX",
          CCF: "CCF",
          RLX: "RLX"
        };
        exports.StreamType = StreamType;
        var FontType = {
          UNKNOWN: "UNKNOWN",
          TYPE1: "TYPE1",
          TYPE1STANDARD: "TYPE1STANDARD",
          TYPE1C: "TYPE1C",
          CIDFONTTYPE0: "CIDFONTTYPE0",
          CIDFONTTYPE0C: "CIDFONTTYPE0C",
          TRUETYPE: "TRUETYPE",
          CIDFONTTYPE2: "CIDFONTTYPE2",
          TYPE3: "TYPE3",
          OPENTYPE: "OPENTYPE",
          TYPE0: "TYPE0",
          MMTYPE1: "MMTYPE1"
        };
        exports.FontType = FontType;
        var VerbosityLevel = {
          ERRORS: 0,
          WARNINGS: 1,
          INFOS: 5
        };
        exports.VerbosityLevel = VerbosityLevel;
        var CMapCompressionType = {
          NONE: 0,
          BINARY: 1,
          STREAM: 2
        };
        exports.CMapCompressionType = CMapCompressionType;
        var OPS = {
          dependency: 1,
          setLineWidth: 2,
          setLineCap: 3,
          setLineJoin: 4,
          setMiterLimit: 5,
          setDash: 6,
          setRenderingIntent: 7,
          setFlatness: 8,
          setGState: 9,
          save: 10,
          restore: 11,
          transform: 12,
          moveTo: 13,
          lineTo: 14,
          curveTo: 15,
          curveTo2: 16,
          curveTo3: 17,
          closePath: 18,
          rectangle: 19,
          stroke: 20,
          closeStroke: 21,
          fill: 22,
          eoFill: 23,
          fillStroke: 24,
          eoFillStroke: 25,
          closeFillStroke: 26,
          closeEOFillStroke: 27,
          endPath: 28,
          clip: 29,
          eoClip: 30,
          beginText: 31,
          endText: 32,
          setCharSpacing: 33,
          setWordSpacing: 34,
          setHScale: 35,
          setLeading: 36,
          setFont: 37,
          setTextRenderingMode: 38,
          setTextRise: 39,
          moveText: 40,
          setLeadingMoveText: 41,
          setTextMatrix: 42,
          nextLine: 43,
          showText: 44,
          showSpacedText: 45,
          nextLineShowText: 46,
          nextLineSetSpacingShowText: 47,
          setCharWidth: 48,
          setCharWidthAndBounds: 49,
          setStrokeColorSpace: 50,
          setFillColorSpace: 51,
          setStrokeColor: 52,
          setStrokeColorN: 53,
          setFillColor: 54,
          setFillColorN: 55,
          setStrokeGray: 56,
          setFillGray: 57,
          setStrokeRGBColor: 58,
          setFillRGBColor: 59,
          setStrokeCMYKColor: 60,
          setFillCMYKColor: 61,
          shadingFill: 62,
          beginInlineImage: 63,
          beginImageData: 64,
          endInlineImage: 65,
          paintXObject: 66,
          markPoint: 67,
          markPointProps: 68,
          beginMarkedContent: 69,
          beginMarkedContentProps: 70,
          endMarkedContent: 71,
          beginCompat: 72,
          endCompat: 73,
          paintFormXObjectBegin: 74,
          paintFormXObjectEnd: 75,
          beginGroup: 76,
          endGroup: 77,
          beginAnnotations: 78,
          endAnnotations: 79,
          beginAnnotation: 80,
          endAnnotation: 81,
          paintJpegXObject: 82,
          paintImageMaskXObject: 83,
          paintImageMaskXObjectGroup: 84,
          paintImageXObject: 85,
          paintInlineImageXObject: 86,
          paintInlineImageXObjectGroup: 87,
          paintImageXObjectRepeat: 88,
          paintImageMaskXObjectRepeat: 89,
          paintSolidColorImageMask: 90,
          constructPath: 91
        };
        exports.OPS = OPS;
        var UNSUPPORTED_FEATURES = {
          unknown: "unknown",
          forms: "forms",
          javaScript: "javaScript",
          signatures: "signatures",
          smask: "smask",
          shadingPattern: "shadingPattern",
          font: "font",
          errorTilingPattern: "errorTilingPattern",
          errorExtGState: "errorExtGState",
          errorXObject: "errorXObject",
          errorFontLoadType3: "errorFontLoadType3",
          errorFontState: "errorFontState",
          errorFontMissing: "errorFontMissing",
          errorFontTranslate: "errorFontTranslate",
          errorColorSpace: "errorColorSpace",
          errorOperatorList: "errorOperatorList",
          errorFontToUnicode: "errorFontToUnicode",
          errorFontLoadNative: "errorFontLoadNative",
          errorFontBuildPath: "errorFontBuildPath",
          errorFontGetPath: "errorFontGetPath",
          errorMarkedContent: "errorMarkedContent",
          errorContentSubStream: "errorContentSubStream"
        };
        exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
        var PasswordResponses = {
          NEED_PASSWORD: 1,
          INCORRECT_PASSWORD: 2
        };
        exports.PasswordResponses = PasswordResponses;
        var verbosity = VerbosityLevel.WARNINGS;

        function setVerbosityLevel(level) {
          if (Number.isInteger(level)) {
            verbosity = level;
          }
        }

        function getVerbosityLevel() {
          return verbosity;
        }

        function info(msg) {
          if (verbosity >= VerbosityLevel.INFOS) {
            console.log("Info: ".concat(msg));
          }
        }

        function warn(msg) {
          if (verbosity >= VerbosityLevel.WARNINGS) {
            console.log("Warning: ".concat(msg));
          }
        }

        function unreachable(msg) {
          throw new Error(msg);
        }

        function assert(cond, msg) {
          if (!cond) {
            unreachable(msg);
          }
        }

        function _isValidProtocol(url) {
          if (!url) {
            return false;
          }

          switch (url.protocol) {
            case "http:":
            case "https:":
            case "ftp:":
            case "mailto:":
            case "tel:":
              return true;

            default:
              return false;
          }
        }

        function createValidAbsoluteUrl(url) {
          var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (!url) {
            return null;
          }

          try {
            if (options && typeof url === "string") {
              if (options.addDefaultProtocol && url.startsWith("www.")) {
                var dots = url.match(/\./g);

                if (dots && dots.length >= 2) {
                  url = "http://".concat(url);
                }
              }

              if (options.tryConvertEncoding) {
                try {
                  url = stringToUTF8String(url);
                } catch (ex) {}
              }
            }

            var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

            if (_isValidProtocol(absoluteUrl)) {
              return absoluteUrl;
            }
          } catch (ex) {}

          return null;
        }

        function shadow(obj, prop, value) {
          Object.defineProperty(obj, prop, {
            value,
            enumerable: true,
            configurable: true,
            writable: false
          });
          return value;
        }

        var BaseException = function BaseExceptionClosure() {
          function BaseException(message, name) {
            if (this.constructor === BaseException) {
              unreachable("Cannot initialize BaseException.");
            }

            this.message = message;
            this.name = name;
          }

          BaseException.prototype = new Error();
          BaseException.constructor = BaseException;
          return BaseException;
        }();

        exports.BaseException = BaseException;

        class PasswordException extends BaseException {
          constructor(msg, code) {
            super(msg, "PasswordException");
            this.code = code;
          }

        }

        exports.PasswordException = PasswordException;

        class UnknownErrorException extends BaseException {
          constructor(msg, details) {
            super(msg, "UnknownErrorException");
            this.details = details;
          }

        }

        exports.UnknownErrorException = UnknownErrorException;

        class InvalidPDFException extends BaseException {
          constructor(msg) {
            super(msg, "InvalidPDFException");
          }

        }

        exports.InvalidPDFException = InvalidPDFException;

        class MissingPDFException extends BaseException {
          constructor(msg) {
            super(msg, "MissingPDFException");
          }

        }

        exports.MissingPDFException = MissingPDFException;

        class UnexpectedResponseException extends BaseException {
          constructor(msg, status) {
            super(msg, "UnexpectedResponseException");
            this.status = status;
          }

        }

        exports.UnexpectedResponseException = UnexpectedResponseException;

        class FormatError extends BaseException {
          constructor(msg) {
            super(msg, "FormatError");
          }

        }

        exports.FormatError = FormatError;

        class AbortException extends BaseException {
          constructor(msg) {
            super(msg, "AbortException");
          }

        }

        exports.AbortException = AbortException;

        function bytesToString(bytes) {
          if (typeof bytes !== "object" || bytes === null || bytes.length === undefined) {
            unreachable("Invalid argument for bytesToString");
          }

          var length = bytes.length;
          var MAX_ARGUMENT_COUNT = 8192;

          if (length < MAX_ARGUMENT_COUNT) {
            return String.fromCharCode.apply(null, bytes);
          }

          var strBuf = [];

          for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
            var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
            var chunk = bytes.subarray(i, chunkEnd);
            strBuf.push(String.fromCharCode.apply(null, chunk));
          }

          return strBuf.join("");
        }

        function stringToBytes(str) {
          if (typeof str !== "string") {
            unreachable("Invalid argument for stringToBytes");
          }

          var length = str.length;
          var bytes = new Uint8Array(length);

          for (var i = 0; i < length; ++i) {
            bytes[i] = str.charCodeAt(i) & 0xff;
          }

          return bytes;
        }

        function arrayByteLength(arr) {
          if (arr.length !== undefined) {
            return arr.length;
          }

          if (arr.byteLength !== undefined) {
            return arr.byteLength;
          }

          unreachable("Invalid argument for arrayByteLength");
        }

        function arraysToBytes(arr) {
          var length = arr.length;

          if (length === 1 && arr[0] instanceof Uint8Array) {
            return arr[0];
          }

          var resultLength = 0;

          for (var i = 0; i < length; i++) {
            resultLength += arrayByteLength(arr[i]);
          }

          var pos = 0;
          var data = new Uint8Array(resultLength);

          for (var _i2 = 0; _i2 < length; _i2++) {
            var item = arr[_i2];

            if (!(item instanceof Uint8Array)) {
              if (typeof item === "string") {
                item = stringToBytes(item);
              } else {
                item = new Uint8Array(item);
              }
            }

            var itemLength = item.byteLength;
            data.set(item, pos);
            pos += itemLength;
          }

          return data;
        }

        function string32(value) {
          return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
        }

        function objectSize(obj) {
          return Object.keys(obj).length;
        }

        function objectFromMap(map) {
          var obj = Object.create(null);

          for (var [key, value] of map) {
            obj[key] = value;
          }

          return obj;
        }

        function isLittleEndian() {
          var buffer8 = new Uint8Array(4);
          buffer8[0] = 1;
          var view32 = new Uint32Array(buffer8.buffer, 0, 1);
          return view32[0] === 1;
        }

        function isEvalSupported() {
          try {
            new Function("");
            return true;
          } catch (e) {
            return false;
          }
        }

        class FeatureTest {
          static get isLittleEndian() {
            return shadow(this, "isLittleEndian", isLittleEndian());
          }

          static get isEvalSupported() {
            return shadow(this, "isEvalSupported", isEvalSupported());
          }

          static get isOffscreenCanvasSupported() {
            return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
          }

        }

        exports.FeatureTest = FeatureTest;
        var hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));

        class Util {
          static makeHexColor(r, g, b) {
            return "#".concat(hexNumbers[r]).concat(hexNumbers[g]).concat(hexNumbers[b]);
          }

          static scaleMinMax(transform, minMax) {
            var temp;

            if (transform[0]) {
              if (transform[0] < 0) {
                temp = minMax[0];
                minMax[0] = minMax[1];
                minMax[1] = temp;
              }

              minMax[0] *= transform[0];
              minMax[1] *= transform[0];

              if (transform[3] < 0) {
                temp = minMax[2];
                minMax[2] = minMax[3];
                minMax[3] = temp;
              }

              minMax[2] *= transform[3];
              minMax[3] *= transform[3];
            } else {
              temp = minMax[0];
              minMax[0] = minMax[2];
              minMax[2] = temp;
              temp = minMax[1];
              minMax[1] = minMax[3];
              minMax[3] = temp;

              if (transform[1] < 0) {
                temp = minMax[2];
                minMax[2] = minMax[3];
                minMax[3] = temp;
              }

              minMax[2] *= transform[1];
              minMax[3] *= transform[1];

              if (transform[2] < 0) {
                temp = minMax[0];
                minMax[0] = minMax[1];
                minMax[1] = temp;
              }

              minMax[0] *= transform[2];
              minMax[1] *= transform[2];
            }

            minMax[0] += transform[4];
            minMax[1] += transform[4];
            minMax[2] += transform[5];
            minMax[3] += transform[5];
          }

          static transform(m1, m2) {
            return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
          }

          static applyTransform(p, m) {
            var xt = p[0] * m[0] + p[1] * m[2] + m[4];
            var yt = p[0] * m[1] + p[1] * m[3] + m[5];
            return [xt, yt];
          }

          static applyInverseTransform(p, m) {
            var d = m[0] * m[3] - m[1] * m[2];
            var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
            var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
            return [xt, yt];
          }

          static getAxialAlignedBoundingBox(r, m) {
            var p1 = Util.applyTransform(r, m);
            var p2 = Util.applyTransform(r.slice(2, 4), m);
            var p3 = Util.applyTransform([r[0], r[3]], m);
            var p4 = Util.applyTransform([r[2], r[1]], m);
            return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
          }

          static inverseTransform(m) {
            var d = m[0] * m[3] - m[1] * m[2];
            return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
          }

          static apply3dTransform(m, v) {
            return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
          }

          static singularValueDecompose2dScale(m) {
            var transpose = [m[0], m[2], m[1], m[3]];
            var a = m[0] * transpose[0] + m[1] * transpose[2];
            var b = m[0] * transpose[1] + m[1] * transpose[3];
            var c = m[2] * transpose[0] + m[3] * transpose[2];
            var d = m[2] * transpose[1] + m[3] * transpose[3];
            var first = (a + d) / 2;
            var second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
            var sx = first + second || 1;
            var sy = first - second || 1;
            return [Math.sqrt(sx), Math.sqrt(sy)];
          }

          static normalizeRect(rect) {
            var r = rect.slice(0);

            if (rect[0] > rect[2]) {
              r[0] = rect[2];
              r[2] = rect[0];
            }

            if (rect[1] > rect[3]) {
              r[1] = rect[3];
              r[3] = rect[1];
            }

            return r;
          }

          static intersect(rect1, rect2) {
            var xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
            var xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));

            if (xLow > xHigh) {
              return null;
            }

            var yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
            var yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));

            if (yLow > yHigh) {
              return null;
            }

            return [xLow, yLow, xHigh, yHigh];
          }

          static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
            var tvalues = [],
                bounds = [[], []];
            var a, b, c, t, t1, t2, b2ac, sqrtb2ac;

            for (var i = 0; i < 2; ++i) {
              if (i === 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
              } else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
              }

              if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12) {
                  continue;
                }

                t = -c / b;

                if (0 < t && t < 1) {
                  tvalues.push(t);
                }

                continue;
              }

              b2ac = b * b - 4 * c * a;
              sqrtb2ac = Math.sqrt(b2ac);

              if (b2ac < 0) {
                continue;
              }

              t1 = (-b + sqrtb2ac) / (2 * a);

              if (0 < t1 && t1 < 1) {
                tvalues.push(t1);
              }

              t2 = (-b - sqrtb2ac) / (2 * a);

              if (0 < t2 && t2 < 1) {
                tvalues.push(t2);
              }
            }

            var j = tvalues.length,
                mt;
            var jlen = j;

            while (j--) {
              t = tvalues[j];
              mt = 1 - t;
              bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
              bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
            }

            bounds[0][jlen] = x0;
            bounds[1][jlen] = y0;
            bounds[0][jlen + 1] = x3;
            bounds[1][jlen + 1] = y3;
            bounds[0].length = bounds[1].length = jlen + 2;
            return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
          }

        }

        exports.Util = Util;
        var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];

        function stringToPDFString(str) {
          if (str[0] >= "\xEF") {
            var encoding;

            if (str[0] === "\xFE" && str[1] === "\xFF") {
              encoding = "utf-16be";
            } else if (str[0] === "\xFF" && str[1] === "\xFE") {
              encoding = "utf-16le";
            } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
              encoding = "utf-8";
            }

            if (encoding) {
              try {
                var decoder = new TextDecoder(encoding, {
                  fatal: true
                });
                var buffer = stringToBytes(str);
                return decoder.decode(buffer);
              } catch (ex) {
                warn("stringToPDFString: \"".concat(ex, "\"."));
              }
            }
          }

          var strBuf = [];

          for (var i = 0, ii = str.length; i < ii; i++) {
            var code = PDFStringTranslateTable[str.charCodeAt(i)];
            strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
          }

          return strBuf.join("");
        }

        function escapeString(str) {
          return str.replace(/([()\\\n\r])/g, match => {
            if (match === "\n") {
              return "\\n";
            } else if (match === "\r") {
              return "\\r";
            }

            return "\\".concat(match);
          });
        }

        function isAscii(str) {
          return /^[\x00-\x7F]*$/.test(str);
        }

        function stringToUTF16BEString(str) {
          var buf = ["\xFE\xFF"];

          for (var i = 0, ii = str.length; i < ii; i++) {
            var char = str.charCodeAt(i);
            buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));
          }

          return buf.join("");
        }

        function stringToUTF8String(str) {
          return decodeURIComponent(escape(str));
        }

        function utf8StringToString(str) {
          return unescape(encodeURIComponent(str));
        }

        function isArrayBuffer(v) {
          return typeof v === "object" && v !== null && v.byteLength !== undefined;
        }

        function isArrayEqual(arr1, arr2) {
          if (arr1.length !== arr2.length) {
            return false;
          }

          for (var i = 0, ii = arr1.length; i < ii; i++) {
            if (arr1[i] !== arr2[i]) {
              return false;
            }
          }

          return true;
        }

        function getModificationDate() {
          var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
          var buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
          return buffer.join("");
        }

        function createPromiseCapability() {
          var capability = Object.create(null);
          var isSettled = false;
          Object.defineProperty(capability, "settled", {
            get() {
              return isSettled;
            }

          });
          capability.promise = new Promise(function (resolve, reject) {
            capability.resolve = function (data) {
              isSettled = true;
              resolve(data);
            };

            capability.reject = function (reason) {
              isSettled = true;
              reject(reason);
            };
          });
          return capability;
        }
        /***/

      },
      /* 2 */

      /***/
      (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {
        var _is_node = __w_pdfjs_require__(3);

        ;
        /***/
      },
      /* 3 */

      /***/
      (__unused_webpack_module, exports) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.isNodeJS = void 0;
        var isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
        exports.isNodeJS = isNodeJS;
        /***/
      },
      /* 4 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
        exports.getDocument = getDocument;
        exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
        exports.version = void 0;

        var _util = __w_pdfjs_require__(1);

        var _display_utils = __w_pdfjs_require__(5);

        var _font_loader = __w_pdfjs_require__(7);

        var _annotation_storage = __w_pdfjs_require__(8);

        var _canvas = __w_pdfjs_require__(10);

        var _worker_options = __w_pdfjs_require__(13);

        var _is_node = __w_pdfjs_require__(3);

        var _message_handler = __w_pdfjs_require__(14);

        var _metadata = __w_pdfjs_require__(15);

        var _optional_content_config = __w_pdfjs_require__(16);

        var _transport_stream = __w_pdfjs_require__(17);

        var _xfa_text = __w_pdfjs_require__(18);

        var DEFAULT_RANGE_CHUNK_SIZE = 65536;
        var RENDERING_CANCELLED_TIMEOUT = 100;
        var DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
        exports.DefaultCanvasFactory = DefaultCanvasFactory;
        var DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
        exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
        var DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
        exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;

        if (_is_node.isNodeJS) {
          var {
            NodeCanvasFactory,
            NodeCMapReaderFactory,
            NodeStandardFontDataFactory
          } = __w_pdfjs_require__(19);

          exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;
          exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;
        }

        var createPDFNetworkStream;

        function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
          createPDFNetworkStream = pdfNetworkStreamFactory;
        }

        function getDocument(src) {
          var task = new PDFDocumentLoadingTask();
          var source;

          if (typeof src === "string" || src instanceof URL) {
            source = {
              url: src
            };
          } else if ((0, _util.isArrayBuffer)(src)) {
            source = {
              data: src
            };
          } else if (src instanceof PDFDataRangeTransport) {
            source = {
              range: src
            };
          } else {
            if (typeof src !== "object") {
              throw new Error("Invalid parameter in getDocument, " + "need either string, URL, Uint8Array, or parameter object.");
            }

            if (!src.url && !src.data && !src.range) {
              throw new Error("Invalid parameter object: need either .data, .range or .url");
            }

            source = src;
          }

          var params = Object.create(null);
          var rangeTransport = null,
              worker = null;

          for (var key in source) {
            var value = source[key];

            switch (key) {
              case "url":
                if (typeof window !== "undefined") {
                  try {
                    params[key] = new URL(value, window.location).href;
                    continue;
                  } catch (ex) {
                    (0, _util.warn)("Cannot create valid URL: \"".concat(ex, "\"."));
                  }
                } else if (typeof value === "string" || value instanceof URL) {
                  params[key] = value.toString();
                  continue;
                }

                throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");

              case "range":
                rangeTransport = value;
                continue;

              case "worker":
                worker = value;
                continue;

              case "data":
                if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
                  params[key] = new Uint8Array(value);
                } else if (value instanceof Uint8Array) {
                  break;
                } else if (typeof value === "string") {
                  params[key] = (0, _util.stringToBytes)(value);
                } else if (typeof value === "object" && value !== null && !isNaN(value.length)) {
                  params[key] = new Uint8Array(value);
                } else if ((0, _util.isArrayBuffer)(value)) {
                  params[key] = new Uint8Array(value);
                } else {
                  throw new Error("Invalid PDF binary data: either typed array, " + "string, or array-like object is expected in the data property.");
                }

                continue;
            }

            params[key] = value;
          }

          params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
          params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
          params.ignoreErrors = params.stopAtErrors !== true;
          params.fontExtraProperties = params.fontExtraProperties === true;
          params.pdfBug = params.pdfBug === true;
          params.enableXfa = params.enableXfa === true;

          if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {
            params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;
          }

          if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
            params.docBaseUrl = null;
          }

          if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {
            params.maxImageSize = -1;
          }

          if (typeof params.cMapUrl !== "string") {
            params.cMapUrl = null;
          }

          if (typeof params.standardFontDataUrl !== "string") {
            params.standardFontDataUrl = null;
          }

          if (typeof params.useWorkerFetch !== "boolean") {
            params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
          }

          if (typeof params.isEvalSupported !== "boolean") {
            params.isEvalSupported = true;
          }

          if (typeof params.disableFontFace !== "boolean") {
            params.disableFontFace = _is_node.isNodeJS;
          }

          if (typeof params.useSystemFonts !== "boolean") {
            params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
          }

          if (typeof params.ownerDocument !== "object" || params.ownerDocument === null) {
            params.ownerDocument = globalThis.document;
          }

          if (typeof params.disableRange !== "boolean") {
            params.disableRange = false;
          }

          if (typeof params.disableStream !== "boolean") {
            params.disableStream = false;
          }

          if (typeof params.disableAutoFetch !== "boolean") {
            params.disableAutoFetch = false;
          }

          (0, _util.setVerbosityLevel)(params.verbosity);

          if (!worker) {
            var workerParams = {
              verbosity: params.verbosity,
              port: _worker_options.GlobalWorkerOptions.workerPort
            };
            worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
            task._worker = worker;
          }

          var docId = task.docId;
          worker.promise.then(function () {
            if (task.destroyed) {
              throw new Error("Loading aborted");
            }

            var workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);

            var networkStreamPromise = new Promise(function (resolve) {
              var networkStream;

              if (rangeTransport) {
                networkStream = new _transport_stream.PDFDataTransportStream({
                  length: params.length,
                  initialData: params.initialData,
                  progressiveDone: params.progressiveDone,
                  contentDispositionFilename: params.contentDispositionFilename,
                  disableRange: params.disableRange,
                  disableStream: params.disableStream
                }, rangeTransport);
              } else if (!params.data) {
                networkStream = createPDFNetworkStream({
                  url: params.url,
                  length: params.length,
                  httpHeaders: params.httpHeaders,
                  withCredentials: params.withCredentials,
                  rangeChunkSize: params.rangeChunkSize,
                  disableRange: params.disableRange,
                  disableStream: params.disableStream
                });
              }

              resolve(networkStream);
            });
            return Promise.all([workerIdPromise, networkStreamPromise]).then(function (_ref) {
              var [workerId, networkStream] = _ref;

              if (task.destroyed) {
                throw new Error("Loading aborted");
              }

              var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
              var transport = new WorkerTransport(messageHandler, task, networkStream, params);
              task._transport = transport;
              messageHandler.send("Ready", null);
            });
          }).catch(task._capability.reject);
          return task;
        }

        function _fetchDocument(_x, _x2, _x3, _x4) {
          return _fetchDocument2.apply(this, arguments);
        }

        function _fetchDocument2() {
          _fetchDocument2 = _asyncToGenerator(function* (worker, source, pdfDataRangeTransport, docId) {
            if (worker.destroyed) {
              throw new Error("Worker was destroyed");
            }

            if (pdfDataRangeTransport) {
              source.length = pdfDataRangeTransport.length;
              source.initialData = pdfDataRangeTransport.initialData;
              source.progressiveDone = pdfDataRangeTransport.progressiveDone;
              source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
            }

            var workerId = yield worker.messageHandler.sendWithPromise("GetDocRequest", {
              docId,
              apiVersion: '2.14.0',
              source: {
                data: source.data,
                url: source.url,
                password: source.password,
                disableAutoFetch: source.disableAutoFetch,
                rangeChunkSize: source.rangeChunkSize,
                length: source.length
              },
              maxImageSize: source.maxImageSize,
              disableFontFace: source.disableFontFace,
              docBaseUrl: source.docBaseUrl,
              ignoreErrors: source.ignoreErrors,
              isEvalSupported: source.isEvalSupported,
              fontExtraProperties: source.fontExtraProperties,
              enableXfa: source.enableXfa,
              useSystemFonts: source.useSystemFonts,
              cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
              standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
            });

            if (worker.destroyed) {
              throw new Error("Worker was destroyed");
            }

            return workerId;
          });
          return _fetchDocument2.apply(this, arguments);
        }

        class PDFDocumentLoadingTask {
          constructor() {
            var _PDFDocumentLoadingTa, _PDFDocumentLoadingTa2;

            this._capability = (0, _util.createPromiseCapability)();
            this._transport = null;
            this._worker = null;
            this.docId = "d".concat((_classStaticPrivateFieldSpecSet(PDFDocumentLoadingTask, PDFDocumentLoadingTask, _docId, (_PDFDocumentLoadingTa = _classStaticPrivateFieldSpecGet(PDFDocumentLoadingTask, PDFDocumentLoadingTask, _docId), _PDFDocumentLoadingTa2 = _PDFDocumentLoadingTa++, _PDFDocumentLoadingTa)), _PDFDocumentLoadingTa2));
            this.destroyed = false;
            this.onPassword = null;
            this.onProgress = null;
            this.onUnsupportedFeature = null;
          }

          get promise() {
            return this._capability.promise;
          }

          destroy() {
            var _this = this;

            return _asyncToGenerator(function* () {
              var _this$_transport;

              _this.destroyed = true;
              yield (_this$_transport = _this._transport) === null || _this$_transport === void 0 ? void 0 : _this$_transport.destroy();
              _this._transport = null;

              if (_this._worker) {
                _this._worker.destroy();

                _this._worker = null;
              }
            })();
          }

        }

        var _docId = {
          writable: true,
          value: 0
        };
        exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;

        class PDFDataRangeTransport {
          constructor(length, initialData) {
            var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
            this.length = length;
            this.initialData = initialData;
            this.progressiveDone = progressiveDone;
            this.contentDispositionFilename = contentDispositionFilename;
            this._rangeListeners = [];
            this._progressListeners = [];
            this._progressiveReadListeners = [];
            this._progressiveDoneListeners = [];
            this._readyCapability = (0, _util.createPromiseCapability)();
          }

          addRangeListener(listener) {
            this._rangeListeners.push(listener);
          }

          addProgressListener(listener) {
            this._progressListeners.push(listener);
          }

          addProgressiveReadListener(listener) {
            this._progressiveReadListeners.push(listener);
          }

          addProgressiveDoneListener(listener) {
            this._progressiveDoneListeners.push(listener);
          }

          onDataRange(begin, chunk) {
            for (var listener of this._rangeListeners) {
              listener(begin, chunk);
            }
          }

          onDataProgress(loaded, total) {
            this._readyCapability.promise.then(() => {
              for (var listener of this._progressListeners) {
                listener(loaded, total);
              }
            });
          }

          onDataProgressiveRead(chunk) {
            this._readyCapability.promise.then(() => {
              for (var listener of this._progressiveReadListeners) {
                listener(chunk);
              }
            });
          }

          onDataProgressiveDone() {
            this._readyCapability.promise.then(() => {
              for (var listener of this._progressiveDoneListeners) {
                listener();
              }
            });
          }

          transportReady() {
            this._readyCapability.resolve();
          }

          requestDataRange(begin, end) {
            (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
          }

          abort() {}

        }

        exports.PDFDataRangeTransport = PDFDataRangeTransport;

        class PDFDocumentProxy {
          constructor(pdfInfo, transport) {
            var _this2 = this;

            this._pdfInfo = pdfInfo;
            this._transport = transport;
            Object.defineProperty(this, "fingerprint", {
              get() {
                (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, " + "please use `PDFDocumentProxy.fingerprints` instead.");
                return this.fingerprints[0];
              }

            });
            Object.defineProperty(this, "getStats", {
              value: function () {
                var _value = _asyncToGenerator(function* () {
                  (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, " + "please use the `PDFDocumentProxy.stats`-getter instead.");
                  return _this2.stats || {
                    streamTypes: {},
                    fontTypes: {}
                  };
                });

                function value() {
                  return _value.apply(this, arguments);
                }

                return value;
              }()
            });
          }

          get annotationStorage() {
            return this._transport.annotationStorage;
          }

          get numPages() {
            return this._pdfInfo.numPages;
          }

          get fingerprints() {
            return this._pdfInfo.fingerprints;
          }

          get stats() {
            return this._transport.stats;
          }

          get isPureXfa() {
            return !!this._transport._htmlForXfa;
          }

          get allXfaHtml() {
            return this._transport._htmlForXfa;
          }

          getPage(pageNumber) {
            return this._transport.getPage(pageNumber);
          }

          getPageIndex(ref) {
            return this._transport.getPageIndex(ref);
          }

          getDestinations() {
            return this._transport.getDestinations();
          }

          getDestination(id) {
            return this._transport.getDestination(id);
          }

          getPageLabels() {
            return this._transport.getPageLabels();
          }

          getPageLayout() {
            return this._transport.getPageLayout();
          }

          getPageMode() {
            return this._transport.getPageMode();
          }

          getViewerPreferences() {
            return this._transport.getViewerPreferences();
          }

          getOpenAction() {
            return this._transport.getOpenAction();
          }

          getAttachments() {
            return this._transport.getAttachments();
          }

          getJavaScript() {
            return this._transport.getJavaScript();
          }

          getJSActions() {
            return this._transport.getDocJSActions();
          }

          getOutline() {
            return this._transport.getOutline();
          }

          getOptionalContentConfig() {
            return this._transport.getOptionalContentConfig();
          }

          getPermissions() {
            return this._transport.getPermissions();
          }

          getMetadata() {
            return this._transport.getMetadata();
          }

          getMarkInfo() {
            return this._transport.getMarkInfo();
          }

          getData() {
            return this._transport.getData();
          }

          getDownloadInfo() {
            return this._transport.downloadInfoCapability.promise;
          }

          cleanup() {
            var keepLoadedFonts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
          }

          destroy() {
            return this.loadingTask.destroy();
          }

          get loadingParams() {
            return this._transport.loadingParams;
          }

          get loadingTask() {
            return this._transport.loadingTask;
          }

          saveDocument() {
            if (this._transport.annotationStorage.size <= 0) {
              (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
            }

            return this._transport.saveDocument();
          }

          getFieldObjects() {
            return this._transport.getFieldObjects();
          }

          hasJSActions() {
            return this._transport.hasJSActions();
          }

          getCalculationOrderIds() {
            return this._transport.getCalculationOrderIds();
          }

        }

        exports.PDFDocumentProxy = PDFDocumentProxy;

        class PDFPageProxy {
          constructor(pageIndex, pageInfo, transport, ownerDocument) {
            var pdfBug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            this._pageIndex = pageIndex;
            this._pageInfo = pageInfo;
            this._ownerDocument = ownerDocument;
            this._transport = transport;
            this._stats = pdfBug ? new _display_utils.StatTimer() : null;
            this._pdfBug = pdfBug;
            this.commonObjs = transport.commonObjs;
            this.objs = new PDFObjects();
            this._bitmaps = new Set();
            this.cleanupAfterRender = false;
            this.pendingCleanup = false;
            this._intentStates = new Map();
            this._annotationPromises = new Map();
            this.destroyed = false;
          }

          get pageNumber() {
            return this._pageIndex + 1;
          }

          get rotate() {
            return this._pageInfo.rotate;
          }

          get ref() {
            return this._pageInfo.ref;
          }

          get userUnit() {
            return this._pageInfo.userUnit;
          }

          get view() {
            return this._pageInfo.view;
          }

          getViewport() {
            var {
              scale,
              rotation = this.rotate,
              offsetX = 0,
              offsetY = 0,
              dontFlip = false
            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return new _display_utils.PageViewport({
              viewBox: this.view,
              scale,
              rotation,
              offsetX,
              offsetY,
              dontFlip
            });
          }

          getAnnotations() {
            var {
              intent = "display"
            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var intentArgs = this._transport.getRenderingIntent(intent);

            var promise = this._annotationPromises.get(intentArgs.cacheKey);

            if (!promise) {
              promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);

              this._annotationPromises.set(intentArgs.cacheKey, promise);

              promise = promise.then(annotations => {
                var _loop = function _loop(annotation) {
                  if (annotation.titleObj !== undefined) {
                    Object.defineProperty(annotation, "title", {
                      get() {
                        (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                        return annotation.titleObj.str;
                      }

                    });
                  }

                  if (annotation.contentsObj !== undefined) {
                    Object.defineProperty(annotation, "contents", {
                      get() {
                        (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                        return annotation.contentsObj.str;
                      }

                    });
                  }
                };

                for (var annotation of annotations) {
                  _loop(annotation);
                }

                return annotations;
              });
            }

            return promise;
          }

          getJSActions() {
            return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
          }

          getXfa() {
            var _this3 = this;

            return _asyncToGenerator(function* () {
              var _this3$_transport$_ht;

              return ((_this3$_transport$_ht = _this3._transport._htmlForXfa) === null || _this3$_transport$_ht === void 0 ? void 0 : _this3$_transport$_ht.children[_this3._pageIndex]) || null;
            })();
          }

          render(_ref2) {
            var _arguments$, _arguments$2, _intentState;

            var {
              canvasContext,
              viewport,
              intent = "display",
              annotationMode = _util.AnnotationMode.ENABLE,
              transform = null,
              imageLayer = null,
              canvasFactory = null,
              background = null,
              optionalContentConfigPromise = null,
              annotationCanvasMap = null,
              pageColors = null
            } = _ref2;

            if (((_arguments$ = arguments[0]) === null || _arguments$ === void 0 ? void 0 : _arguments$.renderInteractiveForms) !== undefined) {
              (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, " + "please use the `annotationMode`-option instead.");

              if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
                annotationMode = _util.AnnotationMode.ENABLE_FORMS;
              }
            }

            if (((_arguments$2 = arguments[0]) === null || _arguments$2 === void 0 ? void 0 : _arguments$2.includeAnnotationStorage) !== undefined) {
              (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, " + "please use the `annotationMode`-option instead.");

              if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
                annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
              }
            }

            if (this._stats) {
              this._stats.time("Overall");
            }

            var intentArgs = this._transport.getRenderingIntent(intent, annotationMode);

            this.pendingCleanup = false;

            if (!optionalContentConfigPromise) {
              optionalContentConfigPromise = this._transport.getOptionalContentConfig();
            }

            var intentState = this._intentStates.get(intentArgs.cacheKey);

            if (!intentState) {
              intentState = Object.create(null);

              this._intentStates.set(intentArgs.cacheKey, intentState);
            }

            if (intentState.streamReaderCancelTimeout) {
              clearTimeout(intentState.streamReaderCancelTimeout);
              intentState.streamReaderCancelTimeout = null;
            }

            var canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
              ownerDocument: this._ownerDocument
            });
            var intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);

            if (!intentState.displayReadyCapability) {
              intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
              intentState.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: false
              };

              if (this._stats) {
                this._stats.time("Page Request");
              }

              this._pumpOperatorList(intentArgs);
            }

            var complete = error => {
              intentState.renderTasks.delete(internalRenderTask);

              if (this.cleanupAfterRender || intentPrint) {
                this.pendingCleanup = true;
              }

              this._tryCleanup();

              if (error) {
                internalRenderTask.capability.reject(error);

                this._abortOperatorList({
                  intentState,
                  reason: error instanceof Error ? error : new Error(error)
                });
              } else {
                internalRenderTask.capability.resolve();
              }

              if (this._stats) {
                this._stats.timeEnd("Rendering");

                this._stats.timeEnd("Overall");
              }
            };

            var internalRenderTask = new InternalRenderTask({
              callback: complete,
              params: {
                canvasContext,
                viewport,
                transform,
                imageLayer,
                background
              },
              objs: this.objs,
              commonObjs: this.commonObjs,
              annotationCanvasMap,
              operatorList: intentState.operatorList,
              pageIndex: this._pageIndex,
              canvasFactory: canvasFactoryInstance,
              useRequestAnimationFrame: !intentPrint,
              pdfBug: this._pdfBug,
              pageColors
            });
            ((_intentState = intentState).renderTasks || (_intentState.renderTasks = new Set())).add(internalRenderTask);
            var renderTask = internalRenderTask.task;
            Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(_ref3 => {
              var [transparency, optionalContentConfig] = _ref3;

              if (this.pendingCleanup) {
                complete();
                return;
              }

              if (this._stats) {
                this._stats.time("Rendering");
              }

              internalRenderTask.initializeGraphics({
                transparency,
                optionalContentConfig
              });
              internalRenderTask.operatorListChanged();
            }).catch(complete);
            return renderTask;
          }

          getOperatorList() {
            var {
              intent = "display",
              annotationMode = _util.AnnotationMode.ENABLE
            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            function operatorListChanged() {
              if (intentState.operatorList.lastChunk) {
                intentState.opListReadCapability.resolve(intentState.operatorList);
                intentState.renderTasks.delete(opListTask);
              }
            }

            var intentArgs = this._transport.getRenderingIntent(intent, annotationMode, true);

            var intentState = this._intentStates.get(intentArgs.cacheKey);

            if (!intentState) {
              intentState = Object.create(null);

              this._intentStates.set(intentArgs.cacheKey, intentState);
            }

            var opListTask;

            if (!intentState.opListReadCapability) {
              var _intentState2;

              opListTask = Object.create(null);
              opListTask.operatorListChanged = operatorListChanged;
              intentState.opListReadCapability = (0, _util.createPromiseCapability)();
              ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = new Set())).add(opListTask);
              intentState.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: false
              };

              if (this._stats) {
                this._stats.time("Page Request");
              }

              this._pumpOperatorList(intentArgs);
            }

            return intentState.opListReadCapability.promise;
          }

          streamTextContent() {
            var {
              disableCombineTextItems = false,
              includeMarkedContent = false
            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var TEXT_CONTENT_CHUNK_SIZE = 100;
            return this._transport.messageHandler.sendWithStream("GetTextContent", {
              pageIndex: this._pageIndex,
              combineTextItems: disableCombineTextItems !== true,
              includeMarkedContent: includeMarkedContent === true
            }, {
              highWaterMark: TEXT_CONTENT_CHUNK_SIZE,

              size(textContent) {
                return textContent.items.length;
              }

            });
          }

          getTextContent() {
            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (this._transport._htmlForXfa) {
              return this.getXfa().then(xfa => {
                return _xfa_text.XfaText.textContent(xfa);
              });
            }

            var readableStream = this.streamTextContent(params);
            return new Promise(function (resolve, reject) {
              function pump() {
                reader.read().then(function (_ref4) {
                  var {
                    value,
                    done
                  } = _ref4;

                  if (done) {
                    resolve(textContent);
                    return;
                  }

                  Object.assign(textContent.styles, value.styles);
                  textContent.items.push(...value.items);
                  pump();
                }, reject);
              }

              var reader = readableStream.getReader();
              var textContent = {
                items: [],
                styles: Object.create(null)
              };
              pump();
            });
          }

          getStructTree() {
            return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
          }

          _destroy() {
            this.destroyed = true;
            var waitOn = [];

            for (var intentState of this._intentStates.values()) {
              this._abortOperatorList({
                intentState,
                reason: new Error("Page was destroyed."),
                force: true
              });

              if (intentState.opListReadCapability) {
                continue;
              }

              for (var internalRenderTask of intentState.renderTasks) {
                waitOn.push(internalRenderTask.completed);
                internalRenderTask.cancel();
              }
            }

            this.objs.clear();

            for (var bitmap of this._bitmaps) {
              bitmap.close();
            }

            this._bitmaps.clear();

            this._annotationPromises.clear();

            this._jsActionsPromise = null;
            this._structTreePromise = null;
            this.pendingCleanup = false;
            return Promise.all(waitOn);
          }

          cleanup() {
            var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            this.pendingCleanup = true;
            return this._tryCleanup(resetStats);
          }

          _tryCleanup() {
            var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            if (!this.pendingCleanup) {
              return false;
            }

            for (var {
              renderTasks,
              operatorList
            } of this._intentStates.values()) {
              if (renderTasks.size > 0 || !operatorList.lastChunk) {
                return false;
              }
            }

            this._intentStates.clear();

            this.objs.clear();

            this._annotationPromises.clear();

            this._jsActionsPromise = null;
            this._structTreePromise = null;

            if (resetStats && this._stats) {
              this._stats = new _display_utils.StatTimer();
            }

            for (var bitmap of this._bitmaps) {
              bitmap.close();
            }

            this._bitmaps.clear();

            this.pendingCleanup = false;
            return true;
          }

          _startRenderPage(transparency, cacheKey) {
            var intentState = this._intentStates.get(cacheKey);

            if (!intentState) {
              return;
            }

            if (this._stats) {
              this._stats.timeEnd("Page Request");
            }

            if (intentState.displayReadyCapability) {
              intentState.displayReadyCapability.resolve(transparency);
            }
          }

          _renderPageChunk(operatorListChunk, intentState) {
            for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {
              intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
              intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
            }

            intentState.operatorList.lastChunk = operatorListChunk.lastChunk;

            for (var internalRenderTask of intentState.renderTasks) {
              internalRenderTask.operatorListChanged();
            }

            if (operatorListChunk.lastChunk) {
              this._tryCleanup();
            }
          }

          _pumpOperatorList(_ref5) {
            var {
              renderingIntent,
              cacheKey
            } = _ref5;

            var readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
              pageIndex: this._pageIndex,
              intent: renderingIntent,
              cacheKey,
              annotationStorage: renderingIntent & _util.RenderingIntentFlag.ANNOTATIONS_STORAGE ? this._transport.annotationStorage.serializable : null
            });

            var reader = readableStream.getReader();

            var intentState = this._intentStates.get(cacheKey);

            intentState.streamReader = reader;

            var pump = () => {
              reader.read().then(_ref6 => {
                var {
                  value,
                  done
                } = _ref6;

                if (done) {
                  intentState.streamReader = null;
                  return;
                }

                if (this._transport.destroyed) {
                  return;
                }

                this._renderPageChunk(value, intentState);

                pump();
              }, reason => {
                intentState.streamReader = null;

                if (this._transport.destroyed) {
                  return;
                }

                if (intentState.operatorList) {
                  intentState.operatorList.lastChunk = true;

                  for (var internalRenderTask of intentState.renderTasks) {
                    internalRenderTask.operatorListChanged();
                  }

                  this._tryCleanup();
                }

                if (intentState.displayReadyCapability) {
                  intentState.displayReadyCapability.reject(reason);
                } else if (intentState.opListReadCapability) {
                  intentState.opListReadCapability.reject(reason);
                } else {
                  throw reason;
                }
              });
            };

            pump();
          }

          _abortOperatorList(_ref7) {
            var {
              intentState,
              reason,
              force = false
            } = _ref7;

            if (!intentState.streamReader) {
              return;
            }

            if (!force) {
              if (intentState.renderTasks.size > 0) {
                return;
              }

              if (reason instanceof _display_utils.RenderingCancelledException) {
                intentState.streamReaderCancelTimeout = setTimeout(() => {
                  this._abortOperatorList({
                    intentState,
                    reason,
                    force: true
                  });

                  intentState.streamReaderCancelTimeout = null;
                }, RENDERING_CANCELLED_TIMEOUT);
                return;
              }
            }

            intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});
            intentState.streamReader = null;

            if (this._transport.destroyed) {
              return;
            }

            for (var [curCacheKey, curIntentState] of this._intentStates) {
              if (curIntentState === intentState) {
                this._intentStates.delete(curCacheKey);

                break;
              }
            }

            this.cleanup();
          }

          get stats() {
            return this._stats;
          }

        }

        exports.PDFPageProxy = PDFPageProxy;

        class LoopbackPort {
          constructor() {
            this._listeners = [];
            this._deferred = Promise.resolve();
          }

          postMessage(obj, transfers) {
            var event = {
              data: structuredClone(obj, transfers)
            };

            this._deferred.then(() => {
              for (var listener of this._listeners) {
                listener.call(this, event);
              }
            });
          }

          addEventListener(name, listener) {
            this._listeners.push(listener);
          }

          removeEventListener(name, listener) {
            var i = this._listeners.indexOf(listener);

            this._listeners.splice(i, 1);
          }

          terminate() {
            this._listeners.length = 0;
          }

        }

        exports.LoopbackPort = LoopbackPort;
        var PDFWorkerUtil = {
          isWorkerDisabled: false,
          fallbackWorkerSrc: null,
          fakeWorkerId: 0
        };
        exports.PDFWorkerUtil = PDFWorkerUtil;
        {
          if (_is_node.isNodeJS && "function" === "function") {
            PDFWorkerUtil.isWorkerDisabled = true;
            PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
          } else if (typeof document === "object") {
            var _document, _document$currentScri;

            var pdfjsFilePath = (_document = document) === null || _document === void 0 ? void 0 : (_document$currentScri = _document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;

            if (pdfjsFilePath) {
              PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
            }
          }

          PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {
            var base;

            try {
              base = new URL(baseUrl);

              if (!base.origin || base.origin === "null") {
                return false;
              }
            } catch (e) {
              return false;
            }

            var other = new URL(otherUrl, base);
            return base.origin === other.origin;
          };

          PDFWorkerUtil.createCDNWrapper = function (url) {
            var wrapper = "importScripts(\"".concat(url, "\");");
            return URL.createObjectURL(new Blob([wrapper]));
          };
        }

        class PDFWorker {
          constructor() {
            var {
              name = null,
              port = null,
              verbosity = (0, _util.getVerbosityLevel)()
            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (port && _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).has(port)) {
              throw new Error("Cannot use more than one PDFWorker per port.");
            }

            this.name = name;
            this.destroyed = false;
            this.verbosity = verbosity;
            this._readyCapability = (0, _util.createPromiseCapability)();
            this._port = null;
            this._webWorker = null;
            this._messageHandler = null;

            if (port) {
              _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).set(port, this);

              this._initializeFromPort(port);

              return;
            }

            this._initialize();
          }

          get promise() {
            return this._readyCapability.promise;
          }

          get port() {
            return this._port;
          }

          get messageHandler() {
            return this._messageHandler;
          }

          _initializeFromPort(port) {
            this._port = port;
            this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);

            this._messageHandler.on("ready", function () {});

            this._readyCapability.resolve();
          }

          _initialize() {
            if (typeof Worker !== "undefined" && !PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
              var workerSrc = PDFWorker.workerSrc;

              try {
                if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                  workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                }

                var worker = new Worker(workerSrc);
                var messageHandler = new _message_handler.MessageHandler("main", "worker", worker);

                var terminateEarly = () => {
                  worker.removeEventListener("error", onWorkerError);
                  messageHandler.destroy();
                  worker.terminate();

                  if (this.destroyed) {
                    this._readyCapability.reject(new Error("Worker was destroyed"));
                  } else {
                    this._setupFakeWorker();
                  }
                };

                var onWorkerError = () => {
                  if (!this._webWorker) {
                    terminateEarly();
                  }
                };

                worker.addEventListener("error", onWorkerError);
                messageHandler.on("test", data => {
                  worker.removeEventListener("error", onWorkerError);

                  if (this.destroyed) {
                    terminateEarly();
                    return;
                  }

                  if (data) {
                    this._messageHandler = messageHandler;
                    this._port = worker;
                    this._webWorker = worker;

                    this._readyCapability.resolve();

                    messageHandler.send("configure", {
                      verbosity: this.verbosity
                    });
                  } else {
                    this._setupFakeWorker();

                    messageHandler.destroy();
                    worker.terminate();
                  }
                });
                messageHandler.on("ready", data => {
                  worker.removeEventListener("error", onWorkerError);

                  if (this.destroyed) {
                    terminateEarly();
                    return;
                  }

                  try {
                    sendTest();
                  } catch (e) {
                    this._setupFakeWorker();
                  }
                });

                var sendTest = () => {
                  var testObj = new Uint8Array();
                  messageHandler.send("test", testObj, [testObj.buffer]);
                };

                sendTest();
                return;
              } catch (e) {
                (0, _util.info)("The worker has been disabled.");
              }
            }

            this._setupFakeWorker();
          }

          _setupFakeWorker() {
            if (!PDFWorkerUtil.isWorkerDisabled) {
              (0, _util.warn)("Setting up fake worker.");
              PDFWorkerUtil.isWorkerDisabled = true;
            }

            PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {
              if (this.destroyed) {
                this._readyCapability.reject(new Error("Worker was destroyed"));

                return;
              }

              var port = new LoopbackPort();
              this._port = port;
              var id = "fake".concat(PDFWorkerUtil.fakeWorkerId++);
              var workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
              WorkerMessageHandler.setup(workerHandler, port);
              var messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
              this._messageHandler = messageHandler;

              this._readyCapability.resolve();

              messageHandler.send("configure", {
                verbosity: this.verbosity
              });
            }).catch(reason => {
              this._readyCapability.reject(new Error("Setting up fake worker failed: \"".concat(reason.message, "\".")));
            });
          }

          destroy() {
            this.destroyed = true;

            if (this._webWorker) {
              this._webWorker.terminate();

              this._webWorker = null;
            }

            _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).delete(this._port);

            this._port = null;

            if (this._messageHandler) {
              this._messageHandler.destroy();

              this._messageHandler = null;
            }
          }

          static fromPort(params) {
            if (!(params !== null && params !== void 0 && params.port)) {
              throw new Error("PDFWorker.fromPort - invalid method signature.");
            }

            if (_classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).has(params.port)) {
              return _classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).get(params.port);
            }

            return new PDFWorker(params);
          }

          static get workerSrc() {
            if (_worker_options.GlobalWorkerOptions.workerSrc) {
              return _worker_options.GlobalWorkerOptions.workerSrc;
            }

            if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
              if (!_is_node.isNodeJS) {
                (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
              }

              return PDFWorkerUtil.fallbackWorkerSrc;
            }

            throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
          }

          static get _mainThreadWorkerMessageHandler() {
            try {
              var _globalThis$pdfjsWork;

              return ((_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler) || null;
            } catch (ex) {
              return null;
            }
          }

          static get _setupFakeWorkerGlobal() {
            var _this4 = this;

            var loader = /*#__PURE__*/function () {
              var _ref8 = _asyncToGenerator(function* () {
                var mainWorkerMessageHandler = _this4._mainThreadWorkerMessageHandler;

                if (mainWorkerMessageHandler) {
                  return mainWorkerMessageHandler;
                }

                if (_is_node.isNodeJS && "function" === "function") {
                  var worker = eval("require")(_this4.workerSrc);
                  return worker.WorkerMessageHandler;
                }

                yield (0, _display_utils.loadScript)(_this4.workerSrc);
                return window.pdfjsWorker.WorkerMessageHandler;
              });

              return function loader() {
                return _ref8.apply(this, arguments);
              };
            }();

            return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
          }

        }

        var _workerPorts = {
          writable: true,
          value: new WeakMap()
        };
        exports.PDFWorker = PDFWorker;
        {
          PDFWorker.getWorkerSrc = function () {
            (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
            return this.workerSrc;
          };
        }

        var _docStats = /*#__PURE__*/new WeakMap();

        var _pageCache = /*#__PURE__*/new WeakMap();

        var _pagePromises = /*#__PURE__*/new WeakMap();

        var _metadataPromise = /*#__PURE__*/new WeakMap();

        class WorkerTransport {
          constructor(messageHandler, loadingTask, networkStream, params) {
            _classPrivateFieldInitSpec(this, _docStats, {
              writable: true,
              value: null
            });

            _classPrivateFieldInitSpec(this, _pageCache, {
              writable: true,
              value: new Map()
            });

            _classPrivateFieldInitSpec(this, _pagePromises, {
              writable: true,
              value: new Map()
            });

            _classPrivateFieldInitSpec(this, _metadataPromise, {
              writable: true,
              value: null
            });

            this.messageHandler = messageHandler;
            this.loadingTask = loadingTask;
            this.commonObjs = new PDFObjects();
            this.fontLoader = new _font_loader.FontLoader({
              docId: loadingTask.docId,
              onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
              ownerDocument: params.ownerDocument,
              styleElement: params.styleElement
            });
            this._params = params;

            if (!params.useWorkerFetch) {
              this.CMapReaderFactory = new params.CMapReaderFactory({
                baseUrl: params.cMapUrl,
                isCompressed: params.cMapPacked
              });
              this.StandardFontDataFactory = new params.StandardFontDataFactory({
                baseUrl: params.standardFontDataUrl
              });
            }

            this.destroyed = false;
            this.destroyCapability = null;
            this._passwordCapability = null;
            this._networkStream = networkStream;
            this._fullReader = null;
            this._lastProgress = null;
            this.downloadInfoCapability = (0, _util.createPromiseCapability)();
            this.setupMessageHandler();
          }

          get annotationStorage() {
            return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
          }

          get stats() {
            return _classPrivateFieldGet(this, _docStats);
          }

          getRenderingIntent(intent) {
            var annotationMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _util.AnnotationMode.ENABLE;
            var isOpList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var renderingIntent = _util.RenderingIntentFlag.DISPLAY;
            var annotationHash = "";

            switch (intent) {
              case "any":
                renderingIntent = _util.RenderingIntentFlag.ANY;
                break;

              case "display":
                break;

              case "print":
                renderingIntent = _util.RenderingIntentFlag.PRINT;
                break;

              default:
                (0, _util.warn)("getRenderingIntent - invalid intent: ".concat(intent));
            }

            switch (annotationMode) {
              case _util.AnnotationMode.DISABLE:
                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                break;

              case _util.AnnotationMode.ENABLE:
                break;

              case _util.AnnotationMode.ENABLE_FORMS:
                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                break;

              case _util.AnnotationMode.ENABLE_STORAGE:
                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                annotationHash = this.annotationStorage.hash;
                break;

              default:
                (0, _util.warn)("getRenderingIntent - invalid annotationMode: ".concat(annotationMode));
            }

            if (isOpList) {
              renderingIntent += _util.RenderingIntentFlag.OPLIST;
            }

            return {
              renderingIntent,
              cacheKey: "".concat(renderingIntent, "_").concat(annotationHash)
            };
          }

          destroy() {
            if (this.destroyCapability) {
              return this.destroyCapability.promise;
            }

            this.destroyed = true;
            this.destroyCapability = (0, _util.createPromiseCapability)();

            if (this._passwordCapability) {
              this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
            }

            var waitOn = [];

            for (var page of _classPrivateFieldGet(this, _pageCache).values()) {
              waitOn.push(page._destroy());
            }

            _classPrivateFieldGet(this, _pageCache).clear();

            _classPrivateFieldGet(this, _pagePromises).clear();

            if (this.hasOwnProperty("annotationStorage")) {
              this.annotationStorage.resetModified();
            }

            var terminated = this.messageHandler.sendWithPromise("Terminate", null);
            waitOn.push(terminated);
            Promise.all(waitOn).then(() => {
              this.commonObjs.clear();
              this.fontLoader.clear();

              _classPrivateFieldSet(this, _metadataPromise, null);

              this._getFieldObjectsPromise = null;
              this._hasJSActionsPromise = null;

              if (this._networkStream) {
                this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
              }

              if (this.messageHandler) {
                this.messageHandler.destroy();
                this.messageHandler = null;
              }

              this.destroyCapability.resolve();
            }, this.destroyCapability.reject);
            return this.destroyCapability.promise;
          }

          setupMessageHandler() {
            var {
              messageHandler,
              loadingTask
            } = this;
            messageHandler.on("GetReader", (data, sink) => {
              (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
              this._fullReader = this._networkStream.getFullReader();

              this._fullReader.onProgress = evt => {
                this._lastProgress = {
                  loaded: evt.loaded,
                  total: evt.total
                };
              };

              sink.onPull = () => {
                this._fullReader.read().then(function (_ref9) {
                  var {
                    value,
                    done
                  } = _ref9;

                  if (done) {
                    sink.close();
                    return;
                  }

                  (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
                  sink.enqueue(new Uint8Array(value), 1, [value]);
                }).catch(reason => {
                  sink.error(reason);
                });
              };

              sink.onCancel = reason => {
                this._fullReader.cancel(reason);

                sink.ready.catch(readyReason => {
                  if (this.destroyed) {
                    return;
                  }

                  throw readyReason;
                });
              };
            });
            messageHandler.on("ReaderHeadersReady", data => {
              var headersCapability = (0, _util.createPromiseCapability)();
              var fullReader = this._fullReader;
              fullReader.headersReady.then(() => {
                if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                  if (this._lastProgress) {
                    var _loadingTask$onProgre;

                    (_loadingTask$onProgre = loadingTask.onProgress) === null || _loadingTask$onProgre === void 0 ? void 0 : _loadingTask$onProgre.call(loadingTask, this._lastProgress);
                  }

                  fullReader.onProgress = evt => {
                    var _loadingTask$onProgre2;

                    (_loadingTask$onProgre2 = loadingTask.onProgress) === null || _loadingTask$onProgre2 === void 0 ? void 0 : _loadingTask$onProgre2.call(loadingTask, {
                      loaded: evt.loaded,
                      total: evt.total
                    });
                  };
                }

                headersCapability.resolve({
                  isStreamingSupported: fullReader.isStreamingSupported,
                  isRangeSupported: fullReader.isRangeSupported,
                  contentLength: fullReader.contentLength
                });
              }, headersCapability.reject);
              return headersCapability.promise;
            });
            messageHandler.on("GetRangeReader", (data, sink) => {
              (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");

              var rangeReader = this._networkStream.getRangeReader(data.begin, data.end);

              if (!rangeReader) {
                sink.close();
                return;
              }

              sink.onPull = () => {
                rangeReader.read().then(function (_ref10) {
                  var {
                    value,
                    done
                  } = _ref10;

                  if (done) {
                    sink.close();
                    return;
                  }

                  (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
                  sink.enqueue(new Uint8Array(value), 1, [value]);
                }).catch(reason => {
                  sink.error(reason);
                });
              };

              sink.onCancel = reason => {
                rangeReader.cancel(reason);
                sink.ready.catch(readyReason => {
                  if (this.destroyed) {
                    return;
                  }

                  throw readyReason;
                });
              };
            });
            messageHandler.on("GetDoc", _ref11 => {
              var {
                pdfInfo
              } = _ref11;
              this._numPages = pdfInfo.numPages;
              this._htmlForXfa = pdfInfo.htmlForXfa;
              delete pdfInfo.htmlForXfa;

              loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
            });
            messageHandler.on("DocException", function (ex) {
              var reason;

              switch (ex.name) {
                case "PasswordException":
                  reason = new _util.PasswordException(ex.message, ex.code);
                  break;

                case "InvalidPDFException":
                  reason = new _util.InvalidPDFException(ex.message);
                  break;

                case "MissingPDFException":
                  reason = new _util.MissingPDFException(ex.message);
                  break;

                case "UnexpectedResponseException":
                  reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                  break;

                case "UnknownErrorException":
                  reason = new _util.UnknownErrorException(ex.message, ex.details);
                  break;

                default:
                  (0, _util.unreachable)("DocException - expected a valid Error.");
              }

              loadingTask._capability.reject(reason);
            });
            messageHandler.on("PasswordRequest", exception => {
              this._passwordCapability = (0, _util.createPromiseCapability)();

              if (loadingTask.onPassword) {
                var updatePassword = password => {
                  if (password instanceof Error) {
                    this._passwordCapability.reject(password);
                  } else {
                    this._passwordCapability.resolve({
                      password
                    });
                  }
                };

                try {
                  loadingTask.onPassword(updatePassword, exception.code);
                } catch (ex) {
                  this._passwordCapability.reject(ex);
                }
              } else {
                this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
              }

              return this._passwordCapability.promise;
            });
            messageHandler.on("DataLoaded", data => {
              var _loadingTask$onProgre3;

              (_loadingTask$onProgre3 = loadingTask.onProgress) === null || _loadingTask$onProgre3 === void 0 ? void 0 : _loadingTask$onProgre3.call(loadingTask, {
                loaded: data.length,
                total: data.length
              });
              this.downloadInfoCapability.resolve(data);
            });
            messageHandler.on("StartRenderPage", data => {
              if (this.destroyed) {
                return;
              }

              var page = _classPrivateFieldGet(this, _pageCache).get(data.pageIndex);

              page._startRenderPage(data.transparency, data.cacheKey);
            });
            messageHandler.on("commonobj", _ref12 => {
              var _globalThis$FontInspe;

              var [id, type, exportedData] = _ref12;

              if (this.destroyed) {
                return;
              }

              if (this.commonObjs.has(id)) {
                return;
              }

              switch (type) {
                case "Font":
                  var params = this._params;

                  if ("error" in exportedData) {
                    var exportedError = exportedData.error;
                    (0, _util.warn)("Error during font loading: ".concat(exportedError));
                    this.commonObjs.resolve(id, exportedError);
                    break;
                  }

                  var fontRegistry = null;

                  if (params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled) {
                    fontRegistry = {
                      registerFont(font, url) {
                        globalThis.FontInspector.fontAdded(font, url);
                      }

                    };
                  }

                  var font = new _font_loader.FontFaceObject(exportedData, {
                    isEvalSupported: params.isEvalSupported,
                    disableFontFace: params.disableFontFace,
                    ignoreErrors: params.ignoreErrors,
                    onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                    fontRegistry
                  });
                  this.fontLoader.bind(font).catch(reason => {
                    return messageHandler.sendWithPromise("FontFallback", {
                      id
                    });
                  }).finally(() => {
                    if (!params.fontExtraProperties && font.data) {
                      font.data = null;
                    }

                    this.commonObjs.resolve(id, font);
                  });
                  break;

                case "FontPath":
                case "Image":
                  this.commonObjs.resolve(id, exportedData);
                  break;

                default:
                  throw new Error("Got unknown common object type ".concat(type));
              }
            });
            messageHandler.on("obj", _ref13 => {
              var [id, pageIndex, type, imageData] = _ref13;

              if (this.destroyed) {
                return;
              }

              var pageProxy = _classPrivateFieldGet(this, _pageCache).get(pageIndex);

              if (pageProxy.objs.has(id)) {
                return;
              }

              switch (type) {
                case "Image":
                  pageProxy.objs.resolve(id, imageData);
                  var MAX_IMAGE_SIZE_TO_STORE = 8000000;

                  if (imageData) {
                    var length;

                    if (imageData.bitmap) {
                      var {
                        bitmap,
                        width,
                        height
                      } = imageData;
                      length = width * height * 4;

                      pageProxy._bitmaps.add(bitmap);
                    } else {
                      var _imageData$data;

                      length = ((_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) || 0;
                    }

                    if (length > MAX_IMAGE_SIZE_TO_STORE) {
                      pageProxy.cleanupAfterRender = true;
                    }
                  }

                  break;

                case "Pattern":
                  pageProxy.objs.resolve(id, imageData);
                  break;

                default:
                  throw new Error("Got unknown object type ".concat(type));
              }
            });
            messageHandler.on("DocProgress", data => {
              var _loadingTask$onProgre4;

              if (this.destroyed) {
                return;
              }

              (_loadingTask$onProgre4 = loadingTask.onProgress) === null || _loadingTask$onProgre4 === void 0 ? void 0 : _loadingTask$onProgre4.call(loadingTask, {
                loaded: data.loaded,
                total: data.total
              });
            });
            messageHandler.on("DocStats", data => {
              if (this.destroyed) {
                return;
              }

              _classPrivateFieldSet(this, _docStats, Object.freeze({
                streamTypes: Object.freeze(data.streamTypes),
                fontTypes: Object.freeze(data.fontTypes)
              }));
            });
            messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
            messageHandler.on("FetchBuiltInCMap", data => {
              if (this.destroyed) {
                return Promise.reject(new Error("Worker was destroyed."));
              }

              if (!this.CMapReaderFactory) {
                return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
              }

              return this.CMapReaderFactory.fetch(data);
            });
            messageHandler.on("FetchStandardFontData", data => {
              if (this.destroyed) {
                return Promise.reject(new Error("Worker was destroyed."));
              }

              if (!this.StandardFontDataFactory) {
                return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
              }

              return this.StandardFontDataFactory.fetch(data);
            });
          }

          _onUnsupportedFeature(_ref14) {
            var _this$loadingTask$onU, _this$loadingTask;

            var {
              featureId
            } = _ref14;

            if (this.destroyed) {
              return;
            }

            (_this$loadingTask$onU = (_this$loadingTask = this.loadingTask).onUnsupportedFeature) === null || _this$loadingTask$onU === void 0 ? void 0 : _this$loadingTask$onU.call(_this$loadingTask, featureId);
          }

          getData() {
            return this.messageHandler.sendWithPromise("GetData", null);
          }

          getPage(pageNumber) {
            if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
              return Promise.reject(new Error("Invalid page request."));
            }

            var pageIndex = pageNumber - 1,
                cachedPromise = _classPrivateFieldGet(this, _pagePromises).get(pageIndex);

            if (cachedPromise) {
              return cachedPromise;
            }

            var promise = this.messageHandler.sendWithPromise("GetPage", {
              pageIndex
            }).then(pageInfo => {
              if (this.destroyed) {
                throw new Error("Transport destroyed");
              }

              var page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);

              _classPrivateFieldGet(this, _pageCache).set(pageIndex, page);

              return page;
            });

            _classPrivateFieldGet(this, _pagePromises).set(pageIndex, promise);

            return promise;
          }

          getPageIndex(ref) {
            if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
              return Promise.reject(new Error("Invalid pageIndex request."));
            }

            return this.messageHandler.sendWithPromise("GetPageIndex", {
              num: ref.num,
              gen: ref.gen
            });
          }

          getAnnotations(pageIndex, intent) {
            return this.messageHandler.sendWithPromise("GetAnnotations", {
              pageIndex,
              intent
            });
          }

          saveDocument() {
            var _this$_fullReader$fil, _this$_fullReader;

            return this.messageHandler.sendWithPromise("SaveDocument", {
              isPureXfa: !!this._htmlForXfa,
              numPages: this._numPages,
              annotationStorage: this.annotationStorage.serializable,
              filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null
            }).finally(() => {
              this.annotationStorage.resetModified();
            });
          }

          getFieldObjects() {
            return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
          }

          hasJSActions() {
            return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
          }

          getCalculationOrderIds() {
            return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
          }

          getDestinations() {
            return this.messageHandler.sendWithPromise("GetDestinations", null);
          }

          getDestination(id) {
            if (typeof id !== "string") {
              return Promise.reject(new Error("Invalid destination request."));
            }

            return this.messageHandler.sendWithPromise("GetDestination", {
              id
            });
          }

          getPageLabels() {
            return this.messageHandler.sendWithPromise("GetPageLabels", null);
          }

          getPageLayout() {
            return this.messageHandler.sendWithPromise("GetPageLayout", null);
          }

          getPageMode() {
            return this.messageHandler.sendWithPromise("GetPageMode", null);
          }

          getViewerPreferences() {
            return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
          }

          getOpenAction() {
            return this.messageHandler.sendWithPromise("GetOpenAction", null);
          }

          getAttachments() {
            return this.messageHandler.sendWithPromise("GetAttachments", null);
          }

          getJavaScript() {
            return this.messageHandler.sendWithPromise("GetJavaScript", null);
          }

          getDocJSActions() {
            return this.messageHandler.sendWithPromise("GetDocJSActions", null);
          }

          getPageJSActions(pageIndex) {
            return this.messageHandler.sendWithPromise("GetPageJSActions", {
              pageIndex
            });
          }

          getStructTree(pageIndex) {
            return this.messageHandler.sendWithPromise("GetStructTree", {
              pageIndex
            });
          }

          getOutline() {
            return this.messageHandler.sendWithPromise("GetOutline", null);
          }

          getOptionalContentConfig() {
            return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => {
              return new _optional_content_config.OptionalContentConfig(results);
            });
          }

          getPermissions() {
            return this.messageHandler.sendWithPromise("GetPermissions", null);
          }

          getMetadata() {
            return _classPrivateFieldGet(this, _metadataPromise) || _classPrivateFieldSet(this, _metadataPromise, this.messageHandler.sendWithPromise("GetMetadata", null).then(results => {
              var _this$_fullReader$fil2, _this$_fullReader2, _this$_fullReader$con, _this$_fullReader3;

              return {
                info: results[0],
                metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                contentDispositionFilename: (_this$_fullReader$fil2 = (_this$_fullReader2 = this._fullReader) === null || _this$_fullReader2 === void 0 ? void 0 : _this$_fullReader2.filename) !== null && _this$_fullReader$fil2 !== void 0 ? _this$_fullReader$fil2 : null,
                contentLength: (_this$_fullReader$con = (_this$_fullReader3 = this._fullReader) === null || _this$_fullReader3 === void 0 ? void 0 : _this$_fullReader3.contentLength) !== null && _this$_fullReader$con !== void 0 ? _this$_fullReader$con : null
              };
            }));
          }

          getMarkInfo() {
            return this.messageHandler.sendWithPromise("GetMarkInfo", null);
          }

          startCleanup() {
            var _arguments = arguments,
                _this5 = this;

            return _asyncToGenerator(function* () {
              var keepLoadedFonts = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : false;
              yield _this5.messageHandler.sendWithPromise("Cleanup", null);

              if (_this5.destroyed) {
                return;
              }

              for (var page of _classPrivateFieldGet(_this5, _pageCache).values()) {
                var cleanupSuccessful = page.cleanup();

                if (!cleanupSuccessful) {
                  throw new Error("startCleanup: Page ".concat(page.pageNumber, " is currently rendering."));
                }
              }

              _this5.commonObjs.clear();

              if (!keepLoadedFonts) {
                _this5.fontLoader.clear();
              }

              _classPrivateFieldSet(_this5, _metadataPromise, null);

              _this5._getFieldObjectsPromise = null;
              _this5._hasJSActionsPromise = null;
            })();
          }

          get loadingParams() {
            var params = this._params;
            return (0, _util.shadow)(this, "loadingParams", {
              disableAutoFetch: params.disableAutoFetch,
              enableXfa: params.enableXfa
            });
          }

        }

        var _objs = /*#__PURE__*/new WeakMap();

        var _ensureObj = /*#__PURE__*/new WeakSet();

        class PDFObjects {
          constructor() {
            _classPrivateMethodInitSpec(this, _ensureObj);

            _classPrivateFieldInitSpec(this, _objs, {
              writable: true,
              value: Object.create(null)
            });
          }

          get(objId) {
            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (callback) {
              var _obj = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, objId);

              _obj.capability.promise.then(() => callback(_obj.data));

              return null;
            }

            var obj = _classPrivateFieldGet(this, _objs)[objId];

            if (!(obj !== null && obj !== void 0 && obj.capability.settled)) {
              throw new Error("Requesting object that isn't resolved yet ".concat(objId, "."));
            }

            return obj.data;
          }

          has(objId) {
            var obj = _classPrivateFieldGet(this, _objs)[objId];

            return (obj === null || obj === void 0 ? void 0 : obj.capability.settled) || false;
          }

          resolve(objId) {
            var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            var obj = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, objId);

            obj.data = data;
            obj.capability.resolve();
          }

          clear() {
            _classPrivateFieldSet(this, _objs, Object.create(null));
          }

        }

        function _ensureObj2(objId) {
          var obj = _classPrivateFieldGet(this, _objs)[objId];

          if (obj) {
            return obj;
          }

          return _classPrivateFieldGet(this, _objs)[objId] = {
            capability: (0, _util.createPromiseCapability)(),
            data: null
          };
        }

        class RenderTask {
          constructor(internalRenderTask) {
            this._internalRenderTask = internalRenderTask;
            this.onContinue = null;
          }

          get promise() {
            return this._internalRenderTask.capability.promise;
          }

          cancel() {
            this._internalRenderTask.cancel();
          }

        }

        exports.RenderTask = RenderTask;

        class InternalRenderTask {
          constructor(_ref15) {
            var {
              callback,
              params,
              objs,
              commonObjs,
              annotationCanvasMap,
              operatorList,
              pageIndex,
              canvasFactory,
              useRequestAnimationFrame = false,
              pdfBug = false,
              pageColors = null
            } = _ref15;
            this.callback = callback;
            this.params = params;
            this.objs = objs;
            this.commonObjs = commonObjs;
            this.annotationCanvasMap = annotationCanvasMap;
            this.operatorListIdx = null;
            this.operatorList = operatorList;
            this._pageIndex = pageIndex;
            this.canvasFactory = canvasFactory;
            this._pdfBug = pdfBug;
            this.pageColors = pageColors;
            this.running = false;
            this.graphicsReadyCallback = null;
            this.graphicsReady = false;
            this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
            this.cancelled = false;
            this.capability = (0, _util.createPromiseCapability)();
            this.task = new RenderTask(this);
            this._cancelBound = this.cancel.bind(this);
            this._continueBound = this._continue.bind(this);
            this._scheduleNextBound = this._scheduleNext.bind(this);
            this._nextBound = this._next.bind(this);
            this._canvas = params.canvasContext.canvas;
          }

          get completed() {
            return this.capability.promise.catch(function () {});
          }

          initializeGraphics(_ref16) {
            var _globalThis$StepperMa;

            var {
              transparency = false,
              optionalContentConfig
            } = _ref16;

            if (this.cancelled) {
              return;
            }

            if (this._canvas) {
              if (_classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).has(this._canvas)) {
                throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
              }

              _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).add(this._canvas);
            }

            if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {
              this.stepper = globalThis.StepperManager.create(this._pageIndex);
              this.stepper.init(this.operatorList);
              this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
            }

            var {
              canvasContext,
              viewport,
              transform,
              imageLayer,
              background
            } = this.params;
            this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);
            this.gfx.beginDrawing({
              transform,
              viewport,
              transparency,
              background
            });
            this.operatorListIdx = 0;
            this.graphicsReady = true;

            if (this.graphicsReadyCallback) {
              this.graphicsReadyCallback();
            }
          }

          cancel() {
            var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            this.running = false;
            this.cancelled = true;

            if (this.gfx) {
              this.gfx.endDrawing();
            }

            if (this._canvas) {
              _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).delete(this._canvas);
            }

            this.callback(error || new _display_utils.RenderingCancelledException("Rendering cancelled, page ".concat(this._pageIndex + 1), "canvas"));
          }

          operatorListChanged() {
            if (!this.graphicsReady) {
              if (!this.graphicsReadyCallback) {
                this.graphicsReadyCallback = this._continueBound;
              }

              return;
            }

            if (this.stepper) {
              this.stepper.updateOperatorList(this.operatorList);
            }

            if (this.running) {
              return;
            }

            this._continue();
          }

          _continue() {
            this.running = true;

            if (this.cancelled) {
              return;
            }

            if (this.task.onContinue) {
              this.task.onContinue(this._scheduleNextBound);
            } else {
              this._scheduleNext();
            }
          }

          _scheduleNext() {
            if (this._useRequestAnimationFrame) {
              window.requestAnimationFrame(() => {
                this._nextBound().catch(this._cancelBound);
              });
            } else {
              Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
          }

          _next() {
            var _this6 = this;

            return _asyncToGenerator(function* () {
              if (_this6.cancelled) {
                return;
              }

              _this6.operatorListIdx = _this6.gfx.executeOperatorList(_this6.operatorList, _this6.operatorListIdx, _this6._continueBound, _this6.stepper);

              if (_this6.operatorListIdx === _this6.operatorList.argsArray.length) {
                _this6.running = false;

                if (_this6.operatorList.lastChunk) {
                  _this6.gfx.endDrawing();

                  if (_this6._canvas) {
                    _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).delete(_this6._canvas);
                  }

                  _this6.callback();
                }
              }
            })();
          }

        }

        var _canvasInUse = {
          writable: true,
          value: new WeakSet()
        };
        var version = '2.14.0';
        exports.version = version;
        var build = '904344f';
        exports.build = build;
        /***/
      },
      /* 5 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;
        exports.deprecated = deprecated;
        exports.getFilenameFromUrl = getFilenameFromUrl;
        exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
        exports.getXfaPageViewport = getXfaPageViewport;
        exports.isDataScheme = isDataScheme;
        exports.isPdfFile = isPdfFile;
        exports.isValidFetchUrl = isValidFetchUrl;
        exports.loadScript = loadScript;

        var _base_factory = __w_pdfjs_require__(6);

        var _util = __w_pdfjs_require__(1);

        var SVG_NS = "http://www.w3.org/2000/svg";

        class PixelsPerInch {}

        _defineProperty(PixelsPerInch, "CSS", 96.0);

        _defineProperty(PixelsPerInch, "PDF", 72.0);

        _defineProperty(PixelsPerInch, "PDF_TO_CSS_UNITS", PixelsPerInch.CSS / PixelsPerInch.PDF);

        exports.PixelsPerInch = PixelsPerInch;

        class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
          constructor() {
            var {
              ownerDocument = globalThis.document
            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            super();
            this._document = ownerDocument;
          }

          _createCanvas(width, height) {
            var canvas = this._document.createElement("canvas");

            canvas.width = width;
            canvas.height = height;
            return canvas;
          }

        }

        exports.DOMCanvasFactory = DOMCanvasFactory;

        function fetchData(_x5) {
          return _fetchData.apply(this, arguments);
        }

        function _fetchData() {
          _fetchData = _asyncToGenerator(function* (url) {
            var asTypedArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            if (isValidFetchUrl(url, document.baseURI)) {
              var response = yield fetch(url);

              if (!response.ok) {
                throw new Error(response.statusText);
              }

              return asTypedArray ? new Uint8Array(yield response.arrayBuffer()) : (0, _util.stringToBytes)(yield response.text());
            }

            return new Promise((resolve, reject) => {
              var request = new XMLHttpRequest();
              request.open("GET", url, true);

              if (asTypedArray) {
                request.responseType = "arraybuffer";
              }

              request.onreadystatechange = () => {
                if (request.readyState !== XMLHttpRequest.DONE) {
                  return;
                }

                if (request.status === 200 || request.status === 0) {
                  var data;

                  if (asTypedArray && request.response) {
                    data = new Uint8Array(request.response);
                  } else if (!asTypedArray && request.responseText) {
                    data = (0, _util.stringToBytes)(request.responseText);
                  }

                  if (data) {
                    resolve(data);
                    return;
                  }
                }

                reject(new Error(request.statusText));
              };

              request.send(null);
            });
          });
          return _fetchData.apply(this, arguments);
        }

        class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
          _fetchData(url, compressionType) {
            return fetchData(url, this.isCompressed).then(data => {
              return {
                cMapData: data,
                compressionType
              };
            });
          }

        }

        exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

        class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
          _fetchData(url) {
            return fetchData(url, true);
          }

        }

        exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;

        class DOMSVGFactory extends _base_factory.BaseSVGFactory {
          _createSVG(type) {
            return document.createElementNS(SVG_NS, type);
          }

        }

        exports.DOMSVGFactory = DOMSVGFactory;

        class PageViewport {
          constructor(_ref17) {
            var {
              viewBox,
              scale,
              rotation,
              offsetX = 0,
              offsetY = 0,
              dontFlip = false
            } = _ref17;
            this.viewBox = viewBox;
            this.scale = scale;
            this.rotation = rotation;
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            var centerX = (viewBox[2] + viewBox[0]) / 2;
            var centerY = (viewBox[3] + viewBox[1]) / 2;
            var rotateA, rotateB, rotateC, rotateD;
            rotation %= 360;

            if (rotation < 0) {
              rotation += 360;
            }

            switch (rotation) {
              case 180:
                rotateA = -1;
                rotateB = 0;
                rotateC = 0;
                rotateD = 1;
                break;

              case 90:
                rotateA = 0;
                rotateB = 1;
                rotateC = 1;
                rotateD = 0;
                break;

              case 270:
                rotateA = 0;
                rotateB = -1;
                rotateC = -1;
                rotateD = 0;
                break;

              case 0:
                rotateA = 1;
                rotateB = 0;
                rotateC = 0;
                rotateD = -1;
                break;

              default:
                throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
            }

            if (dontFlip) {
              rotateC = -rotateC;
              rotateD = -rotateD;
            }

            var offsetCanvasX, offsetCanvasY;
            var width, height;

            if (rotateA === 0) {
              offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
              offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
              width = Math.abs(viewBox[3] - viewBox[1]) * scale;
              height = Math.abs(viewBox[2] - viewBox[0]) * scale;
            } else {
              offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
              offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
              width = Math.abs(viewBox[2] - viewBox[0]) * scale;
              height = Math.abs(viewBox[3] - viewBox[1]) * scale;
            }

            this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
            this.width = width;
            this.height = height;
          }

          clone() {
            var {
              scale = this.scale,
              rotation = this.rotation,
              offsetX = this.offsetX,
              offsetY = this.offsetY,
              dontFlip = false
            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return new PageViewport({
              viewBox: this.viewBox.slice(),
              scale,
              rotation,
              offsetX,
              offsetY,
              dontFlip
            });
          }

          convertToViewportPoint(x, y) {
            return _util.Util.applyTransform([x, y], this.transform);
          }

          convertToViewportRectangle(rect) {
            var topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

            var bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

            return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
          }

          convertToPdfPoint(x, y) {
            return _util.Util.applyInverseTransform([x, y], this.transform);
          }

        }

        exports.PageViewport = PageViewport;

        class RenderingCancelledException extends _util.BaseException {
          constructor(msg, type) {
            super(msg, "RenderingCancelledException");
            this.type = type;
          }

        }

        exports.RenderingCancelledException = RenderingCancelledException;

        function isDataScheme(url) {
          var ii = url.length;
          var i = 0;

          while (i < ii && url[i].trim() === "") {
            i++;
          }

          return url.substring(i, i + 5).toLowerCase() === "data:";
        }

        function isPdfFile(filename) {
          return typeof filename === "string" && /\.pdf$/i.test(filename);
        }

        function getFilenameFromUrl(url) {
          var anchor = url.indexOf("#");
          var query = url.indexOf("?");
          var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
          return url.substring(url.lastIndexOf("/", end) + 1, end);
        }

        function getPdfFilenameFromUrl(url) {
          var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "document.pdf";

          if (typeof url !== "string") {
            return defaultFilename;
          }

          if (isDataScheme(url)) {
            (0, _util.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
            return defaultFilename;
          }

          var reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
          var reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
          var splitURI = reURI.exec(url);
          var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

          if (suggestedFilename) {
            suggestedFilename = suggestedFilename[0];

            if (suggestedFilename.includes("%")) {
              try {
                suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
              } catch (ex) {}
            }
          }

          return suggestedFilename || defaultFilename;
        }

        class StatTimer {
          constructor() {
            this.started = Object.create(null);
            this.times = [];
          }

          time(name) {
            if (name in this.started) {
              (0, _util.warn)("Timer is already running for ".concat(name));
            }

            this.started[name] = Date.now();
          }

          timeEnd(name) {
            if (!(name in this.started)) {
              (0, _util.warn)("Timer has not been started for ".concat(name));
            }

            this.times.push({
              name,
              start: this.started[name],
              end: Date.now()
            });
            delete this.started[name];
          }

          toString() {
            var outBuf = [];
            var longest = 0;

            for (var time of this.times) {
              var name = time.name;

              if (name.length > longest) {
                longest = name.length;
              }
            }

            for (var _time2 of this.times) {
              var duration = _time2.end - _time2.start;
              outBuf.push("".concat(_time2.name.padEnd(longest), " ").concat(duration, "ms\n"));
            }

            return outBuf.join("");
          }

        }

        exports.StatTimer = StatTimer;

        function isValidFetchUrl(url, baseUrl) {
          try {
            var {
              protocol
            } = baseUrl ? new URL(url, baseUrl) : new URL(url);
            return protocol === "http:" || protocol === "https:";
          } catch (ex) {
            return false;
          }
        }

        function loadScript(src) {
          var removeScriptElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return new Promise((resolve, reject) => {
            var script = document.createElement("script");
            script.src = src;

            script.onload = function (evt) {
              if (removeScriptElement) {
                script.remove();
              }

              resolve(evt);
            };

            script.onerror = function () {
              reject(new Error("Cannot load script at: ".concat(script.src)));
            };

            (document.head || document.documentElement).appendChild(script);
          });
        }

        function deprecated(details) {
          console.log("Deprecated API usage: " + details);
        }

        var pdfDateStringRegex;

        class PDFDateString {
          static toDateObject(input) {
            if (!input || typeof input !== "string") {
              return null;
            }

            if (!pdfDateStringRegex) {
              pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
            }

            var matches = pdfDateStringRegex.exec(input);

            if (!matches) {
              return null;
            }

            var year = parseInt(matches[1], 10);
            var month = parseInt(matches[2], 10);
            month = month >= 1 && month <= 12 ? month - 1 : 0;
            var day = parseInt(matches[3], 10);
            day = day >= 1 && day <= 31 ? day : 1;
            var hour = parseInt(matches[4], 10);
            hour = hour >= 0 && hour <= 23 ? hour : 0;
            var minute = parseInt(matches[5], 10);
            minute = minute >= 0 && minute <= 59 ? minute : 0;
            var second = parseInt(matches[6], 10);
            second = second >= 0 && second <= 59 ? second : 0;
            var universalTimeRelation = matches[7] || "Z";
            var offsetHour = parseInt(matches[8], 10);
            offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
            var offsetMinute = parseInt(matches[9], 10) || 0;
            offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

            if (universalTimeRelation === "-") {
              hour += offsetHour;
              minute += offsetMinute;
            } else if (universalTimeRelation === "+") {
              hour -= offsetHour;
              minute -= offsetMinute;
            }

            return new Date(Date.UTC(year, month, day, hour, minute, second));
          }

        }

        exports.PDFDateString = PDFDateString;

        function getXfaPageViewport(xfaPage, _ref18) {
          var {
            scale = 1,
            rotation = 0
          } = _ref18;
          var {
            width,
            height
          } = xfaPage.attributes.style;
          var viewBox = [0, 0, parseInt(width), parseInt(height)];
          return new PageViewport({
            viewBox,
            scale,
            rotation
          });
        }
        /***/

      },
      /* 6 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;

        var _util = __w_pdfjs_require__(1);

        class BaseCanvasFactory {
          constructor() {
            if (this.constructor === BaseCanvasFactory) {
              (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
            }
          }

          create(width, height) {
            if (width <= 0 || height <= 0) {
              throw new Error("Invalid canvas size");
            }

            var canvas = this._createCanvas(width, height);

            return {
              canvas,
              context: canvas.getContext("2d")
            };
          }

          reset(canvasAndContext, width, height) {
            if (!canvasAndContext.canvas) {
              throw new Error("Canvas is not specified");
            }

            if (width <= 0 || height <= 0) {
              throw new Error("Invalid canvas size");
            }

            canvasAndContext.canvas.width = width;
            canvasAndContext.canvas.height = height;
          }

          destroy(canvasAndContext) {
            if (!canvasAndContext.canvas) {
              throw new Error("Canvas is not specified");
            }

            canvasAndContext.canvas.width = 0;
            canvasAndContext.canvas.height = 0;
            canvasAndContext.canvas = null;
            canvasAndContext.context = null;
          }

          _createCanvas(width, height) {
            (0, _util.unreachable)("Abstract method `_createCanvas` called.");
          }

        }

        exports.BaseCanvasFactory = BaseCanvasFactory;

        class BaseCMapReaderFactory {
          constructor(_ref19) {
            var {
              baseUrl = null,
              isCompressed = false
            } = _ref19;

            if (this.constructor === BaseCMapReaderFactory) {
              (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
            }

            this.baseUrl = baseUrl;
            this.isCompressed = isCompressed;
          }

          fetch(_ref20) {
            var _this7 = this;

            return _asyncToGenerator(function* () {
              var {
                name
              } = _ref20;

              if (!_this7.baseUrl) {
                throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
              }

              if (!name) {
                throw new Error("CMap name must be specified.");
              }

              var url = _this7.baseUrl + name + (_this7.isCompressed ? ".bcmap" : "");
              var compressionType = _this7.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
              return _this7._fetchData(url, compressionType).catch(reason => {
                throw new Error("Unable to load ".concat(_this7.isCompressed ? "binary " : "", "CMap at: ").concat(url));
              });
            })();
          }

          _fetchData(url, compressionType) {
            (0, _util.unreachable)("Abstract method `_fetchData` called.");
          }

        }

        exports.BaseCMapReaderFactory = BaseCMapReaderFactory;

        class BaseStandardFontDataFactory {
          constructor(_ref21) {
            var {
              baseUrl = null
            } = _ref21;

            if (this.constructor === BaseStandardFontDataFactory) {
              (0, _util.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
            }

            this.baseUrl = baseUrl;
          }

          fetch(_ref22) {
            var _this8 = this;

            return _asyncToGenerator(function* () {
              var {
                filename
              } = _ref22;

              if (!_this8.baseUrl) {
                throw new Error('The standard font "baseUrl" parameter must be specified, ensure that ' + 'the "standardFontDataUrl" API parameter is provided.');
              }

              if (!filename) {
                throw new Error("Font filename must be specified.");
              }

              var url = "".concat(_this8.baseUrl).concat(filename);
              return _this8._fetchData(url).catch(reason => {
                throw new Error("Unable to load font data at: ".concat(url));
              });
            })();
          }

          _fetchData(url) {
            (0, _util.unreachable)("Abstract method `_fetchData` called.");
          }

        }

        exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;

        class BaseSVGFactory {
          constructor() {
            if (this.constructor === BaseSVGFactory) {
              (0, _util.unreachable)("Cannot initialize BaseSVGFactory.");
            }
          }

          create(width, height) {
            if (width <= 0 || height <= 0) {
              throw new Error("Invalid SVG dimensions");
            }

            var svg = this._createSVG("svg:svg");

            svg.setAttribute("version", "1.1");
            svg.setAttribute("width", "".concat(width, "px"));
            svg.setAttribute("height", "".concat(height, "px"));
            svg.setAttribute("preserveAspectRatio", "none");
            svg.setAttribute("viewBox", "0 0 ".concat(width, " ").concat(height));
            return svg;
          }

          createElement(type) {
            if (typeof type !== "string") {
              throw new Error("Invalid SVG element type");
            }

            return this._createSVG(type);
          }

          _createSVG(type) {
            (0, _util.unreachable)("Abstract method `_createSVG` called.");
          }

        }

        exports.BaseSVGFactory = BaseSVGFactory;
        /***/
      },
      /* 7 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.FontLoader = exports.FontFaceObject = void 0;

        var _util = __w_pdfjs_require__(1);

        class BaseFontLoader {
          constructor(_ref23) {
            var {
              docId,
              onUnsupportedFeature,
              ownerDocument = globalThis.document,
              styleElement = null
            } = _ref23;

            if (this.constructor === BaseFontLoader) {
              (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
            }

            this.docId = docId;
            this._onUnsupportedFeature = onUnsupportedFeature;
            this._document = ownerDocument;
            this.nativeFontFaces = [];
            this.styleElement = null;
          }

          addNativeFontFace(nativeFontFace) {
            this.nativeFontFaces.push(nativeFontFace);

            this._document.fonts.add(nativeFontFace);
          }

          insertRule(rule) {
            var styleElement = this.styleElement;

            if (!styleElement) {
              styleElement = this.styleElement = this._document.createElement("style");
              styleElement.id = "PDFJS_FONT_STYLE_TAG_".concat(this.docId);

              this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
            }

            var styleSheet = styleElement.sheet;
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
          }

          clear() {
            for (var nativeFontFace of this.nativeFontFaces) {
              this._document.fonts.delete(nativeFontFace);
            }

            this.nativeFontFaces.length = 0;

            if (this.styleElement) {
              this.styleElement.remove();
              this.styleElement = null;
            }
          }

          bind(font) {
            var _this9 = this;

            return _asyncToGenerator(function* () {
              if (font.attached || font.missingFile) {
                return;
              }

              font.attached = true;

              if (_this9.isFontLoadingAPISupported) {
                var nativeFontFace = font.createNativeFontFace();

                if (nativeFontFace) {
                  _this9.addNativeFontFace(nativeFontFace);

                  try {
                    yield nativeFontFace.loaded;
                  } catch (ex) {
                    _this9._onUnsupportedFeature({
                      featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative
                    });

                    (0, _util.warn)("Failed to load font '".concat(nativeFontFace.family, "': '").concat(ex, "'."));
                    font.disableFontFace = true;
                    throw ex;
                  }
                }

                return;
              }

              var rule = font.createFontFaceRule();

              if (rule) {
                _this9.insertRule(rule);

                if (_this9.isSyncFontLoadingSupported) {
                  return;
                }

                yield new Promise(resolve => {
                  var request = _this9._queueLoadingCallback(resolve);

                  _this9._prepareFontLoadEvent([rule], [font], request);
                });
              }
            })();
          }

          _queueLoadingCallback(callback) {
            (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
          }

          get isFontLoadingAPISupported() {
            var _this$_document;

            var hasFonts = !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts);
            return (0, _util.shadow)(this, "isFontLoadingAPISupported", hasFonts);
          }

          get isSyncFontLoadingSupported() {
            (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
          }

          get _loadTestFont() {
            (0, _util.unreachable)("Abstract method `_loadTestFont`.");
          }

          _prepareFontLoadEvent(rules, fontsToLoad, request) {
            (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
          }

        }

        var FontLoader;
        exports.FontLoader = FontLoader;
        {
          exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
            constructor(params) {
              super(params);
              this.loadingContext = {
                requests: [],
                nextRequestId: 0
              };
              this.loadTestFontId = 0;
            }

            get isSyncFontLoadingSupported() {
              var supported = false;

              if (typeof navigator === "undefined") {
                supported = true;
              } else {
                var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

                if ((m === null || m === void 0 ? void 0 : m[1]) >= 14) {
                  supported = true;
                }
              }

              return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
            }

            _queueLoadingCallback(callback) {
              function completeRequest() {
                (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
                request.done = true;

                while (context.requests.length > 0 && context.requests[0].done) {
                  var otherRequest = context.requests.shift();
                  setTimeout(otherRequest.callback, 0);
                }
              }

              var context = this.loadingContext;
              var request = {
                id: "pdfjs-font-loading-".concat(context.nextRequestId++),
                done: false,
                complete: completeRequest,
                callback
              };
              context.requests.push(request);
              return request;
            }

            get _loadTestFont() {
              var getLoadTestFont = function getLoadTestFont() {
                return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
              };

              return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
            }

            _prepareFontLoadEvent(rules, fonts, request) {
              function int32(data, offset) {
                return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
              }

              function spliceString(s, offset, remove, insert) {
                var chunk1 = s.substring(0, offset);
                var chunk2 = s.substring(offset + remove);
                return chunk1 + insert + chunk2;
              }

              var i, ii;

              var canvas = this._document.createElement("canvas");

              canvas.width = 1;
              canvas.height = 1;
              var ctx = canvas.getContext("2d");
              var called = 0;

              function isFontReady(name, callback) {
                called++;

                if (called > 30) {
                  (0, _util.warn)("Load test font never loaded.");
                  callback();
                  return;
                }

                ctx.font = "30px " + name;
                ctx.fillText(".", 0, 20);
                var imageData = ctx.getImageData(0, 0, 1, 1);

                if (imageData.data[3] > 0) {
                  callback();
                  return;
                }

                setTimeout(isFontReady.bind(null, name, callback));
              }

              var loadTestFontId = "lt".concat(Date.now()).concat(this.loadTestFontId++);
              var data = this._loadTestFont;
              var COMMENT_OFFSET = 976;
              data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
              var CFF_CHECKSUM_OFFSET = 16;
              var XXXX_VALUE = 0x58585858;
              var checksum = int32(data, CFF_CHECKSUM_OFFSET);

              for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
              }

              if (i < loadTestFontId.length) {
                checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
              }

              data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
              var url = "url(data:font/opentype;base64,".concat(btoa(data), ");");
              var rule = "@font-face {font-family:\"".concat(loadTestFontId, "\";src:").concat(url, "}");
              this.insertRule(rule);
              var names = [];

              for (var font of fonts) {
                names.push(font.loadedName);
              }

              names.push(loadTestFontId);

              var div = this._document.createElement("div");

              div.style.visibility = "hidden";
              div.style.width = div.style.height = "10px";
              div.style.position = "absolute";
              div.style.top = div.style.left = "0px";

              for (var name of names) {
                var span = this._document.createElement("span");

                span.textContent = "Hi";
                span.style.fontFamily = name;
                div.appendChild(span);
              }

              this._document.body.appendChild(div);

              isFontReady(loadTestFontId, () => {
                div.remove();
                request.complete();
              });
            }

          };
        }

        class FontFaceObject {
          constructor(translatedData, _ref24) {
            var {
              isEvalSupported = true,
              disableFontFace = false,
              ignoreErrors = false,
              onUnsupportedFeature,
              fontRegistry = null
            } = _ref24;
            this.compiledGlyphs = Object.create(null);

            for (var i in translatedData) {
              this[i] = translatedData[i];
            }

            this.isEvalSupported = isEvalSupported !== false;
            this.disableFontFace = disableFontFace === true;
            this.ignoreErrors = ignoreErrors === true;
            this._onUnsupportedFeature = onUnsupportedFeature;
            this.fontRegistry = fontRegistry;
          }

          createNativeFontFace() {
            if (!this.data || this.disableFontFace) {
              return null;
            }

            var nativeFontFace;

            if (!this.cssFontInfo) {
              nativeFontFace = new FontFace(this.loadedName, this.data, {});
            } else {
              var css = {
                weight: this.cssFontInfo.fontWeight
              };

              if (this.cssFontInfo.italicAngle) {
                css.style = "oblique ".concat(this.cssFontInfo.italicAngle, "deg");
              }

              nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
            }

            if (this.fontRegistry) {
              this.fontRegistry.registerFont(this);
            }

            return nativeFontFace;
          }

          createFontFaceRule() {
            if (!this.data || this.disableFontFace) {
              return null;
            }

            var data = (0, _util.bytesToString)(this.data);
            var url = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(data), ");");
            var rule;

            if (!this.cssFontInfo) {
              rule = "@font-face {font-family:\"".concat(this.loadedName, "\";src:").concat(url, "}");
            } else {
              var css = "font-weight: ".concat(this.cssFontInfo.fontWeight, ";");

              if (this.cssFontInfo.italicAngle) {
                css += "font-style: oblique ".concat(this.cssFontInfo.italicAngle, "deg;");
              }

              rule = "@font-face {font-family:\"".concat(this.cssFontInfo.fontFamily, "\";").concat(css, "src:").concat(url, "}");
            }

            if (this.fontRegistry) {
              this.fontRegistry.registerFont(this, url);
            }

            return rule;
          }

          getPathGenerator(objs, character) {
            if (this.compiledGlyphs[character] !== undefined) {
              return this.compiledGlyphs[character];
            }

            var cmds;

            try {
              cmds = objs.get(this.loadedName + "_path_" + character);
            } catch (ex) {
              if (!this.ignoreErrors) {
                throw ex;
              }

              this._onUnsupportedFeature({
                featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath
              });

              (0, _util.warn)("getPathGenerator - ignoring character: \"".concat(ex, "\"."));
              return this.compiledGlyphs[character] = function (c, size) {};
            }

            if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {
              var jsBuf = [];

              for (var current of cmds) {
                var args = current.args !== undefined ? current.args.join(",") : "";
                jsBuf.push("c.", current.cmd, "(", args, ");\n");
              }

              return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
            }

            return this.compiledGlyphs[character] = function (c, size) {
              for (var _current2 of cmds) {
                if (_current2.cmd === "scale") {
                  _current2.args = [size, -size];
                }

                c[_current2.cmd].apply(c, _current2.args);
              }
            };
          }

        }

        exports.FontFaceObject = FontFaceObject;
        /***/
      },
      /* 8 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.AnnotationStorage = void 0;

        var _murmurhash = __w_pdfjs_require__(9);

        var _util = __w_pdfjs_require__(1);

        class AnnotationStorage {
          constructor() {
            this._storage = new Map();
            this._modified = false;
            this.onSetModified = null;
            this.onResetModified = null;
          }

          getValue(key, defaultValue) {
            var value = this._storage.get(key);

            if (value === undefined) {
              return defaultValue;
            }

            return Object.assign(defaultValue, value);
          }

          getRawValue(key) {
            return this._storage.get(key);
          }

          setValue(key, value) {
            var obj = this._storage.get(key);

            var modified = false;

            if (obj !== undefined) {
              for (var [entry, val] of Object.entries(value)) {
                if (obj[entry] !== val) {
                  modified = true;
                  obj[entry] = val;
                }
              }
            } else {
              modified = true;

              this._storage.set(key, value);
            }

            if (modified) {
              this._setModified();
            }
          }

          getAll() {
            return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;
          }

          get size() {
            return this._storage.size;
          }

          _setModified() {
            if (!this._modified) {
              this._modified = true;

              if (typeof this.onSetModified === "function") {
                this.onSetModified();
              }
            }
          }

          resetModified() {
            if (this._modified) {
              this._modified = false;

              if (typeof this.onResetModified === "function") {
                this.onResetModified();
              }
            }
          }

          get serializable() {
            return this._storage.size > 0 ? this._storage : null;
          }

          get hash() {
            var hash = new _murmurhash.MurmurHash3_64();

            for (var [key, value] of this._storage) {
              hash.update("".concat(key, ":").concat(JSON.stringify(value)));
            }

            return hash.hexdigest();
          }

        }

        exports.AnnotationStorage = AnnotationStorage;
        /***/
      },
      /* 9 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.MurmurHash3_64 = void 0;

        var _util = __w_pdfjs_require__(1);

        var SEED = 0xc3d2e1f0;
        var MASK_HIGH = 0xffff0000;
        var MASK_LOW = 0xffff;

        class MurmurHash3_64 {
          constructor(seed) {
            this.h1 = seed ? seed & 0xffffffff : SEED;
            this.h2 = seed ? seed & 0xffffffff : SEED;
          }

          update(input) {
            var data, length;

            if (typeof input === "string") {
              data = new Uint8Array(input.length * 2);
              length = 0;

              for (var i = 0, ii = input.length; i < ii; i++) {
                var code = input.charCodeAt(i);

                if (code <= 0xff) {
                  data[length++] = code;
                } else {
                  data[length++] = code >>> 8;
                  data[length++] = code & 0xff;
                }
              }
            } else if ((0, _util.isArrayBuffer)(input)) {
              data = input.slice();
              length = data.byteLength;
            } else {
              throw new Error("Wrong data format in MurmurHash3_64_update. " + "Input must be a string or array.");
            }

            var blockCounts = length >> 2;
            var tailLength = length - blockCounts * 4;
            var dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
            var k1 = 0,
                k2 = 0;
            var h1 = this.h1,
                h2 = this.h2;
            var C1 = 0xcc9e2d51,
                C2 = 0x1b873593;
            var C1_LOW = C1 & MASK_LOW,
                C2_LOW = C2 & MASK_LOW;

            for (var _i4 = 0; _i4 < blockCounts; _i4++) {
              if (_i4 & 1) {
                k1 = dataUint32[_i4];
                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                k1 = k1 << 15 | k1 >>> 17;
                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                h1 ^= k1;
                h1 = h1 << 13 | h1 >>> 19;
                h1 = h1 * 5 + 0xe6546b64;
              } else {
                k2 = dataUint32[_i4];
                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                k2 = k2 << 15 | k2 >>> 17;
                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                h2 ^= k2;
                h2 = h2 << 13 | h2 >>> 19;
                h2 = h2 * 5 + 0xe6546b64;
              }
            }

            k1 = 0;

            switch (tailLength) {
              case 3:
                k1 ^= data[blockCounts * 4 + 2] << 16;

              case 2:
                k1 ^= data[blockCounts * 4 + 1] << 8;

              case 1:
                k1 ^= data[blockCounts * 4];
                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                k1 = k1 << 15 | k1 >>> 17;
                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;

                if (blockCounts & 1) {
                  h1 ^= k1;
                } else {
                  h2 ^= k1;
                }

            }

            this.h1 = h1;
            this.h2 = h2;
          }

          hexdigest() {
            var h1 = this.h1,
                h2 = this.h2;
            h1 ^= h2 >>> 1;
            h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
            h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
            h1 ^= h2 >>> 1;
            h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
            h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
            h1 ^= h2 >>> 1;
            var hex1 = (h1 >>> 0).toString(16),
                hex2 = (h2 >>> 0).toString(16);
            return hex1.padStart(8, "0") + hex2.padStart(8, "0");
          }

        }

        exports.MurmurHash3_64 = MurmurHash3_64;
        /***/
      },
      /* 10 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.CanvasGraphics = void 0;

        var _util = __w_pdfjs_require__(1);

        var _pattern_helper = __w_pdfjs_require__(11);

        var _image_utils = __w_pdfjs_require__(12);

        var _is_node = __w_pdfjs_require__(3);

        var _display_utils = __w_pdfjs_require__(5);

        var MIN_FONT_SIZE = 16;
        var MAX_FONT_SIZE = 100;
        var MAX_GROUP_SIZE = 4096;
        var EXECUTION_TIME = 15;
        var EXECUTION_STEPS = 10;
        var COMPILE_TYPE3_GLYPHS = true;
        var MAX_SIZE_TO_COMPILE = 1000;
        var FULL_CHUNK_HEIGHT = 16;
        var LINEWIDTH_SCALE_FACTOR = 1.000001;

        function mirrorContextOperations(ctx, destCtx) {
          if (ctx._removeMirroring) {
            throw new Error("Context is already forwarding operations.");
          }

          ctx.__originalSave = ctx.save;
          ctx.__originalRestore = ctx.restore;
          ctx.__originalRotate = ctx.rotate;
          ctx.__originalScale = ctx.scale;
          ctx.__originalTranslate = ctx.translate;
          ctx.__originalTransform = ctx.transform;
          ctx.__originalSetTransform = ctx.setTransform;
          ctx.__originalResetTransform = ctx.resetTransform;
          ctx.__originalClip = ctx.clip;
          ctx.__originalMoveTo = ctx.moveTo;
          ctx.__originalLineTo = ctx.lineTo;
          ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
          ctx.__originalRect = ctx.rect;
          ctx.__originalClosePath = ctx.closePath;
          ctx.__originalBeginPath = ctx.beginPath;

          ctx._removeMirroring = () => {
            ctx.save = ctx.__originalSave;
            ctx.restore = ctx.__originalRestore;
            ctx.rotate = ctx.__originalRotate;
            ctx.scale = ctx.__originalScale;
            ctx.translate = ctx.__originalTranslate;
            ctx.transform = ctx.__originalTransform;
            ctx.setTransform = ctx.__originalSetTransform;
            ctx.resetTransform = ctx.__originalResetTransform;
            ctx.clip = ctx.__originalClip;
            ctx.moveTo = ctx.__originalMoveTo;
            ctx.lineTo = ctx.__originalLineTo;
            ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
            ctx.rect = ctx.__originalRect;
            ctx.closePath = ctx.__originalClosePath;
            ctx.beginPath = ctx.__originalBeginPath;
            delete ctx._removeMirroring;
          };

          ctx.save = function ctxSave() {
            destCtx.save();

            this.__originalSave();
          };

          ctx.restore = function ctxRestore() {
            destCtx.restore();

            this.__originalRestore();
          };

          ctx.translate = function ctxTranslate(x, y) {
            destCtx.translate(x, y);

            this.__originalTranslate(x, y);
          };

          ctx.scale = function ctxScale(x, y) {
            destCtx.scale(x, y);

            this.__originalScale(x, y);
          };

          ctx.transform = function ctxTransform(a, b, c, d, e, f) {
            destCtx.transform(a, b, c, d, e, f);

            this.__originalTransform(a, b, c, d, e, f);
          };

          ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
            destCtx.setTransform(a, b, c, d, e, f);

            this.__originalSetTransform(a, b, c, d, e, f);
          };

          ctx.resetTransform = function ctxResetTransform() {
            destCtx.resetTransform();

            this.__originalResetTransform();
          };

          ctx.rotate = function ctxRotate(angle) {
            destCtx.rotate(angle);

            this.__originalRotate(angle);
          };

          ctx.clip = function ctxRotate(rule) {
            destCtx.clip(rule);

            this.__originalClip(rule);
          };

          ctx.moveTo = function (x, y) {
            destCtx.moveTo(x, y);

            this.__originalMoveTo(x, y);
          };

          ctx.lineTo = function (x, y) {
            destCtx.lineTo(x, y);

            this.__originalLineTo(x, y);
          };

          ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
            destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);

            this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
          };

          ctx.rect = function (x, y, width, height) {
            destCtx.rect(x, y, width, height);

            this.__originalRect(x, y, width, height);
          };

          ctx.closePath = function () {
            destCtx.closePath();

            this.__originalClosePath();
          };

          ctx.beginPath = function () {
            destCtx.beginPath();

            this.__originalBeginPath();
          };
        }

        function addContextCurrentTransform(ctx) {
          if (ctx._transformStack) {
            ctx._transformStack = [];
          }

          if (ctx.mozCurrentTransform) {
            return;
          }

          ctx._originalSave = ctx.save;
          ctx._originalRestore = ctx.restore;
          ctx._originalRotate = ctx.rotate;
          ctx._originalScale = ctx.scale;
          ctx._originalTranslate = ctx.translate;
          ctx._originalTransform = ctx.transform;
          ctx._originalSetTransform = ctx.setTransform;
          ctx._originalResetTransform = ctx.resetTransform;
          ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
          ctx._transformStack = [];

          try {
            var desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), "lineWidth");
            ctx._setLineWidth = desc.set;
            ctx._getLineWidth = desc.get;
            Object.defineProperty(ctx, "lineWidth", {
              set: function setLineWidth(width) {
                this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);
              },
              get: function getLineWidth() {
                return this._getLineWidth();
              }
            });
          } catch (_) {}

          Object.defineProperty(ctx, "mozCurrentTransform", {
            get: function getCurrentTransform() {
              return this._transformMatrix;
            }
          });
          Object.defineProperty(ctx, "mozCurrentTransformInverse", {
            get: function getCurrentTransformInverse() {
              var [a, b, c, d, e, f] = this._transformMatrix;
              var ad_bc = a * d - b * c;
              var bc_ad = b * c - a * d;
              return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
            }
          });

          ctx.save = function ctxSave() {
            var old = this._transformMatrix;

            this._transformStack.push(old);

            this._transformMatrix = old.slice(0, 6);

            this._originalSave();
          };

          ctx.restore = function ctxRestore() {
            if (this._transformStack.length === 0) {
              (0, _util.warn)("Tried to restore a ctx when the stack was already empty.");
            }

            var prev = this._transformStack.pop();

            if (prev) {
              this._transformMatrix = prev;

              this._originalRestore();
            }
          };

          ctx.translate = function ctxTranslate(x, y) {
            var m = this._transformMatrix;
            m[4] = m[0] * x + m[2] * y + m[4];
            m[5] = m[1] * x + m[3] * y + m[5];

            this._originalTranslate(x, y);
          };

          ctx.scale = function ctxScale(x, y) {
            var m = this._transformMatrix;
            m[0] *= x;
            m[1] *= x;
            m[2] *= y;
            m[3] *= y;

            this._originalScale(x, y);
          };

          ctx.transform = function ctxTransform(a, b, c, d, e, f) {
            var m = this._transformMatrix;
            this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];

            ctx._originalTransform(a, b, c, d, e, f);
          };

          ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
            this._transformMatrix = [a, b, c, d, e, f];

            ctx._originalSetTransform(a, b, c, d, e, f);
          };

          ctx.resetTransform = function ctxResetTransform() {
            this._transformMatrix = [1, 0, 0, 1, 0, 0];

            ctx._originalResetTransform();
          };

          ctx.rotate = function ctxRotate(angle) {
            var cosValue = Math.cos(angle);
            var sinValue = Math.sin(angle);
            var m = this._transformMatrix;
            this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];

            this._originalRotate(angle);
          };
        }

        class CachedCanvases {
          constructor(canvasFactory) {
            this.canvasFactory = canvasFactory;
            this.cache = Object.create(null);
          }

          getCanvas(id, width, height, trackTransform) {
            var canvasEntry;

            if (this.cache[id] !== undefined) {
              canvasEntry = this.cache[id];
              this.canvasFactory.reset(canvasEntry, width, height);
              canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
            } else {
              canvasEntry = this.canvasFactory.create(width, height);
              this.cache[id] = canvasEntry;
            }

            if (trackTransform) {
              addContextCurrentTransform(canvasEntry.context);
            }

            return canvasEntry;
          }

          delete(id) {
            delete this.cache[id];
          }

          clear() {
            for (var id in this.cache) {
              var canvasEntry = this.cache[id];
              this.canvasFactory.destroy(canvasEntry);
              delete this.cache[id];
            }
          }

        }

        function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
          var [a, b, c, d, tx, ty] = ctx.mozCurrentTransform;

          if (b === 0 && c === 0) {
            var tlX = destX * a + tx;
            var rTlX = Math.round(tlX);
            var tlY = destY * d + ty;
            var rTlY = Math.round(tlY);
            var brX = (destX + destW) * a + tx;
            var rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
            var brY = (destY + destH) * d + ty;
            var rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
            ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
            ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
            ctx.setTransform(a, b, c, d, tx, ty);
            return [rWidth, rHeight];
          }

          if (a === 0 && d === 0) {
            var _tlX = destY * c + tx;

            var _rTlX = Math.round(_tlX);

            var _tlY = destX * b + ty;

            var _rTlY = Math.round(_tlY);

            var _brX = (destY + destH) * c + tx;

            var _rWidth = Math.abs(Math.round(_brX) - _rTlX) || 1;

            var _brY = (destX + destW) * b + ty;

            var _rHeight = Math.abs(Math.round(_brY) - _rTlY) || 1;

            ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, _rTlX, _rTlY);
            ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, _rHeight, _rWidth);
            ctx.setTransform(a, b, c, d, tx, ty);
            return [_rHeight, _rWidth];
          }

          ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
          var scaleX = Math.hypot(a, b);
          var scaleY = Math.hypot(c, d);
          return [scaleX * destW, scaleY * destH];
        }

        function compileType3Glyph(imgData) {
          var {
            width,
            height
          } = imgData;

          if (!COMPILE_TYPE3_GLYPHS || width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
            return null;
          }

          var POINT_TO_PROCESS_LIMIT = 1000;
          var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
          var width1 = width + 1;
          var points = new Uint8Array(width1 * (height + 1));
          var i, j, j0;
          var lineSize = width + 7 & ~7;
          var data = new Uint8Array(lineSize * height),
              pos = 0;

          for (var elem of imgData.data) {
            var mask = 128;

            while (mask > 0) {
              data[pos++] = elem & mask ? 0 : 255;
              mask >>= 1;
            }
          }

          var count = 0;
          pos = 0;

          if (data[pos] !== 0) {
            points[0] = 1;
            ++count;
          }

          for (j = 1; j < width; j++) {
            if (data[pos] !== data[pos + 1]) {
              points[j] = data[pos] ? 2 : 1;
              ++count;
            }

            pos++;
          }

          if (data[pos] !== 0) {
            points[j] = 2;
            ++count;
          }

          for (i = 1; i < height; i++) {
            pos = i * lineSize;
            j0 = i * width1;

            if (data[pos - lineSize] !== data[pos]) {
              points[j0] = data[pos] ? 1 : 8;
              ++count;
            }

            var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

            for (j = 1; j < width; j++) {
              sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

              if (POINT_TYPES[sum]) {
                points[j0 + j] = POINT_TYPES[sum];
                ++count;
              }

              pos++;
            }

            if (data[pos - lineSize] !== data[pos]) {
              points[j0 + j] = data[pos] ? 2 : 4;
              ++count;
            }

            if (count > POINT_TO_PROCESS_LIMIT) {
              return null;
            }
          }

          pos = lineSize * (height - 1);
          j0 = i * width1;

          if (data[pos] !== 0) {
            points[j0] = 8;
            ++count;
          }

          for (j = 1; j < width; j++) {
            if (data[pos] !== data[pos + 1]) {
              points[j0 + j] = data[pos] ? 4 : 8;
              ++count;
            }

            pos++;
          }

          if (data[pos] !== 0) {
            points[j0 + j] = 4;
            ++count;
          }

          if (count > POINT_TO_PROCESS_LIMIT) {
            return null;
          }

          var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
          var path, outlines, coords;

          if (!_is_node.isNodeJS) {
            path = new Path2D();
          } else {
            outlines = [];
          }

          for (i = 0; count && i <= height; i++) {
            var p = i * width1;
            var end = p + width;

            while (p < end && !points[p]) {
              p++;
            }

            if (p === end) {
              continue;
            }

            if (path) {
              path.moveTo(p % width1, i);
            } else {
              coords = [p % width1, i];
            }

            var p0 = p;
            var type = points[p];

            do {
              var step = steps[type];

              do {
                p += step;
              } while (!points[p]);

              var pp = points[p];

              if (pp !== 5 && pp !== 10) {
                type = pp;
                points[p] = 0;
              } else {
                type = pp & 0x33 * type >> 4;
                points[p] &= type >> 2 | type << 2;
              }

              if (path) {
                path.lineTo(p % width1, p / width1 | 0);
              } else {
                coords.push(p % width1, p / width1 | 0);
              }

              if (!points[p]) {
                --count;
              }
            } while (p0 !== p);

            if (!path) {
              outlines.push(coords);
            }

            --i;
          }

          data = null;
          points = null;

          var drawOutline = function drawOutline(c) {
            c.save();
            c.scale(1 / width, -1 / height);
            c.translate(0, -height);

            if (path) {
              c.fill(path);
            } else {
              c.beginPath();

              for (var o of outlines) {
                c.moveTo(o[0], o[1]);

                for (var l = 2, ll = o.length; l < ll; l += 2) {
                  c.lineTo(o[l], o[l + 1]);
                }
              }

              c.fill();
            }

            c.beginPath();
            c.restore();
          };

          return drawOutline;
        }

        class CanvasExtraState {
          constructor(width, height) {
            this.alphaIsShape = false;
            this.fontSize = 0;
            this.fontSizeScale = 1;
            this.textMatrix = _util.IDENTITY_MATRIX;
            this.textMatrixScale = 1;
            this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
            this.leading = 0;
            this.x = 0;
            this.y = 0;
            this.lineX = 0;
            this.lineY = 0;
            this.charSpacing = 0;
            this.wordSpacing = 0;
            this.textHScale = 1;
            this.textRenderingMode = _util.TextRenderingMode.FILL;
            this.textRise = 0;
            this.fillColor = "#000000";
            this.strokeColor = "#000000";
            this.patternFill = false;
            this.fillAlpha = 1;
            this.strokeAlpha = 1;
            this.lineWidth = 1;
            this.activeSMask = null;
            this.transferMaps = null;
            this.startNewPathAndClipBox([0, 0, width, height]);
          }

          clone() {
            var clone = Object.create(this);
            clone.clipBox = this.clipBox.slice();
            return clone;
          }

          setCurrentPoint(x, y) {
            this.x = x;
            this.y = y;
          }

          updatePathMinMax(transform, x, y) {
            [x, y] = _util.Util.applyTransform([x, y], transform);
            this.minX = Math.min(this.minX, x);
            this.minY = Math.min(this.minY, y);
            this.maxX = Math.max(this.maxX, x);
            this.maxY = Math.max(this.maxY, y);
          }

          updateRectMinMax(transform, rect) {
            var p1 = _util.Util.applyTransform(rect, transform);

            var p2 = _util.Util.applyTransform(rect.slice(2), transform);

            this.minX = Math.min(this.minX, p1[0], p2[0]);
            this.minY = Math.min(this.minY, p1[1], p2[1]);
            this.maxX = Math.max(this.maxX, p1[0], p2[0]);
            this.maxY = Math.max(this.maxY, p1[1], p2[1]);
          }

          updateScalingPathMinMax(transform, minMax) {
            _util.Util.scaleMinMax(transform, minMax);

            this.minX = Math.min(this.minX, minMax[0]);
            this.maxX = Math.max(this.maxX, minMax[1]);
            this.minY = Math.min(this.minY, minMax[2]);
            this.maxY = Math.max(this.maxY, minMax[3]);
          }

          updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
            var box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);

            if (minMax) {
              minMax[0] = Math.min(minMax[0], box[0], box[2]);
              minMax[1] = Math.max(minMax[1], box[0], box[2]);
              minMax[2] = Math.min(minMax[2], box[1], box[3]);
              minMax[3] = Math.max(minMax[3], box[1], box[3]);
              return;
            }

            this.updateRectMinMax(transform, box);
          }

          getPathBoundingBox() {
            var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;
            var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var box = [this.minX, this.minY, this.maxX, this.maxY];

            if (pathType === _pattern_helper.PathType.STROKE) {
              if (!transform) {
                (0, _util.unreachable)("Stroke bounding box must include transform.");
              }

              var scale = _util.Util.singularValueDecompose2dScale(transform);

              var xStrokePad = scale[0] * this.lineWidth / 2;
              var yStrokePad = scale[1] * this.lineWidth / 2;
              box[0] -= xStrokePad;
              box[1] -= yStrokePad;
              box[2] += xStrokePad;
              box[3] += yStrokePad;
            }

            return box;
          }

          updateClipFromPath() {
            var intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());

            this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
          }

          isEmptyClip() {
            return this.minX === Infinity;
          }

          startNewPathAndClipBox(box) {
            this.clipBox = box;
            this.minX = Infinity;
            this.minY = Infinity;
            this.maxX = 0;
            this.maxY = 0;
          }

          getClippedPathBoundingBox() {
            var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;
            var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
          }

        }

        function putBinaryImageData(ctx, imgData) {
          var transferMaps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
            ctx.putImageData(imgData, 0, 0);
            return;
          }

          var height = imgData.height,
              width = imgData.width;
          var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
          var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
          var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
          var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
          var srcPos = 0,
              destPos;
          var src = imgData.data;
          var dest = chunkImgData.data;
          var i, j, thisChunkHeight, elemsInThisChunk;
          var transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;

          if (transferMaps) {
            switch (transferMaps.length) {
              case 1:
                transferMapRed = transferMaps[0];
                transferMapGreen = transferMaps[0];
                transferMapBlue = transferMaps[0];
                transferMapGray = transferMaps[0];
                break;

              case 4:
                transferMapRed = transferMaps[0];
                transferMapGreen = transferMaps[1];
                transferMapBlue = transferMaps[2];
                transferMapGray = transferMaps[3];
                break;
            }
          }

          if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
            var srcLength = src.byteLength;
            var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
            var dest32DataLength = dest32.length;
            var fullSrcDiff = width + 7 >> 3;
            var white = 0xffffffff;
            var black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;

            if (transferMapGray) {
              if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {
                [white, black] = [black, white];
              }
            }

            for (i = 0; i < totalChunks; i++) {
              thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
              destPos = 0;

              for (j = 0; j < thisChunkHeight; j++) {
                var srcDiff = srcLength - srcPos;
                var k = 0;
                var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                var kEndUnrolled = kEnd & ~7;
                var mask = 0;
                var srcByte = 0;

                for (; k < kEndUnrolled; k += 8) {
                  srcByte = src[srcPos++];
                  dest32[destPos++] = srcByte & 128 ? white : black;
                  dest32[destPos++] = srcByte & 64 ? white : black;
                  dest32[destPos++] = srcByte & 32 ? white : black;
                  dest32[destPos++] = srcByte & 16 ? white : black;
                  dest32[destPos++] = srcByte & 8 ? white : black;
                  dest32[destPos++] = srcByte & 4 ? white : black;
                  dest32[destPos++] = srcByte & 2 ? white : black;
                  dest32[destPos++] = srcByte & 1 ? white : black;
                }

                for (; k < kEnd; k++) {
                  if (mask === 0) {
                    srcByte = src[srcPos++];
                    mask = 128;
                  }

                  dest32[destPos++] = srcByte & mask ? white : black;
                  mask >>= 1;
                }
              }

              while (destPos < dest32DataLength) {
                dest32[destPos++] = 0;
              }

              ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
            }
          } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
            var hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
            j = 0;
            elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

            for (i = 0; i < fullChunks; i++) {
              dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
              srcPos += elemsInThisChunk;

              if (hasTransferMaps) {
                for (var _k2 = 0; _k2 < elemsInThisChunk; _k2 += 4) {
                  if (transferMapRed) {
                    dest[_k2 + 0] = transferMapRed[dest[_k2 + 0]];
                  }

                  if (transferMapGreen) {
                    dest[_k2 + 1] = transferMapGreen[dest[_k2 + 1]];
                  }

                  if (transferMapBlue) {
                    dest[_k2 + 2] = transferMapBlue[dest[_k2 + 2]];
                  }
                }
              }

              ctx.putImageData(chunkImgData, 0, j);
              j += FULL_CHUNK_HEIGHT;
            }

            if (i < totalChunks) {
              elemsInThisChunk = width * partialChunkHeight * 4;
              dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));

              if (hasTransferMaps) {
                for (var _k4 = 0; _k4 < elemsInThisChunk; _k4 += 4) {
                  if (transferMapRed) {
                    dest[_k4 + 0] = transferMapRed[dest[_k4 + 0]];
                  }

                  if (transferMapGreen) {
                    dest[_k4 + 1] = transferMapGreen[dest[_k4 + 1]];
                  }

                  if (transferMapBlue) {
                    dest[_k4 + 2] = transferMapBlue[dest[_k4 + 2]];
                  }
                }
              }

              ctx.putImageData(chunkImgData, 0, j);
            }
          } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
            var _hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);

            thisChunkHeight = FULL_CHUNK_HEIGHT;
            elemsInThisChunk = width * thisChunkHeight;

            for (i = 0; i < totalChunks; i++) {
              if (i >= fullChunks) {
                thisChunkHeight = partialChunkHeight;
                elemsInThisChunk = width * thisChunkHeight;
              }

              destPos = 0;

              for (j = elemsInThisChunk; j--;) {
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = 255;
              }

              if (_hasTransferMaps) {
                for (var _k6 = 0; _k6 < destPos; _k6 += 4) {
                  if (transferMapRed) {
                    dest[_k6 + 0] = transferMapRed[dest[_k6 + 0]];
                  }

                  if (transferMapGreen) {
                    dest[_k6 + 1] = transferMapGreen[dest[_k6 + 1]];
                  }

                  if (transferMapBlue) {
                    dest[_k6 + 2] = transferMapBlue[dest[_k6 + 2]];
                  }
                }
              }

              ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
            }
          } else {
            throw new Error("bad image kind: ".concat(imgData.kind));
          }
        }

        function putBinaryImageMask(ctx, imgData) {
          if (imgData.bitmap) {
            ctx.drawImage(imgData.bitmap, 0, 0);
            return;
          }

          var height = imgData.height,
              width = imgData.width;
          var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
          var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
          var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
          var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
          var srcPos = 0;
          var src = imgData.data;
          var dest = chunkImgData.data;

          for (var i = 0; i < totalChunks; i++) {
            var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
            ({
              srcPos
            } = (0, _image_utils.applyMaskImageData)({
              src,
              srcPos,
              dest,
              width,
              height: thisChunkHeight
            }));
            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
          }
        }

        function copyCtxState(sourceCtx, destCtx) {
          var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];

          for (var i = 0, ii = properties.length; i < ii; i++) {
            var property = properties[i];

            if (sourceCtx[property] !== undefined) {
              destCtx[property] = sourceCtx[property];
            }
          }

          if (sourceCtx.setLineDash !== undefined) {
            destCtx.setLineDash(sourceCtx.getLineDash());
            destCtx.lineDashOffset = sourceCtx.lineDashOffset;
          }
        }

        function resetCtxToDefault(ctx, foregroundColor) {
          ctx.strokeStyle = ctx.fillStyle = foregroundColor || "#000000";
          ctx.fillRule = "nonzero";
          ctx.globalAlpha = 1;
          ctx.lineWidth = 1;
          ctx.lineCap = "butt";
          ctx.lineJoin = "miter";
          ctx.miterLimit = 10;
          ctx.globalCompositeOperation = "source-over";
          ctx.font = "10px sans-serif";

          if (ctx.setLineDash !== undefined) {
            ctx.setLineDash([]);
            ctx.lineDashOffset = 0;
          }
        }

        function composeSMaskBackdrop(bytes, r0, g0, b0) {
          var length = bytes.length;

          for (var i = 3; i < length; i += 4) {
            var alpha = bytes[i];

            if (alpha === 0) {
              bytes[i - 3] = r0;
              bytes[i - 2] = g0;
              bytes[i - 1] = b0;
            } else if (alpha < 255) {
              var alpha_ = 255 - alpha;
              bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
              bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
              bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
            }
          }
        }

        function composeSMaskAlpha(maskData, layerData, transferMap) {
          var length = maskData.length;
          var scale = 1 / 255;

          for (var i = 3; i < length; i += 4) {
            var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
            layerData[i] = layerData[i] * alpha * scale | 0;
          }
        }

        function composeSMaskLuminosity(maskData, layerData, transferMap) {
          var length = maskData.length;

          for (var i = 3; i < length; i += 4) {
            var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
            layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
          }
        }

        function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
          var hasBackdrop = !!backdrop;
          var r0 = hasBackdrop ? backdrop[0] : 0;
          var g0 = hasBackdrop ? backdrop[1] : 0;
          var b0 = hasBackdrop ? backdrop[2] : 0;
          var composeFn;

          if (subtype === "Luminosity") {
            composeFn = composeSMaskLuminosity;
          } else {
            composeFn = composeSMaskAlpha;
          }

          var PIXELS_TO_PROCESS = 1048576;
          var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

          for (var row = 0; row < height; row += chunkSize) {
            var chunkHeight = Math.min(chunkSize, height - row);
            var maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
            var layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);

            if (hasBackdrop) {
              composeSMaskBackdrop(maskData.data, r0, g0, b0);
            }

            composeFn(maskData.data, layerData.data, transferMap);
            layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
          }
        }

        function composeSMask(ctx, smask, layerCtx, layerBox) {
          var layerOffsetX = layerBox[0];
          var layerOffsetY = layerBox[1];
          var layerWidth = layerBox[2] - layerOffsetX;
          var layerHeight = layerBox[3] - layerOffsetY;

          if (layerWidth === 0 || layerHeight === 0) {
            return;
          }

          genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.globalCompositeOperation = "source-over";
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.drawImage(layerCtx.canvas, 0, 0);
          ctx.restore();
        }

        function getImageSmoothingEnabled(transform, interpolate) {
          var scale = _util.Util.singularValueDecompose2dScale(transform);

          scale[0] = Math.fround(scale[0]);
          scale[1] = Math.fround(scale[1]);
          var actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);

          if (interpolate !== undefined) {
            return interpolate;
          } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
            return true;
          }

          return false;
        }

        var LINE_CAP_STYLES = ["butt", "round", "square"];
        var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
        var NORMAL_CLIP = {};
        var EO_CLIP = {};

        class CanvasGraphics {
          constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {
            this.ctx = canvasCtx;
            this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
            this.stateStack = [];
            this.pendingClip = null;
            this.pendingEOFill = false;
            this.res = null;
            this.xobjs = null;
            this.commonObjs = commonObjs;
            this.objs = objs;
            this.canvasFactory = canvasFactory;
            this.imageLayer = imageLayer;
            this.groupStack = [];
            this.processingType3 = null;
            this.baseTransform = null;
            this.baseTransformStack = [];
            this.groupLevel = 0;
            this.smaskStack = [];
            this.smaskCounter = 0;
            this.tempSMask = null;
            this.suspendedCtx = null;
            this.contentVisible = true;
            this.markedContentStack = [];
            this.optionalContentConfig = optionalContentConfig;
            this.cachedCanvases = new CachedCanvases(this.canvasFactory);
            this.cachedPatterns = new Map();
            this.annotationCanvasMap = annotationCanvasMap;
            this.viewportScale = 1;
            this.outputScaleX = 1;
            this.outputScaleY = 1;
            this.backgroundColor = (pageColors === null || pageColors === void 0 ? void 0 : pageColors.background) || null;
            this.foregroundColor = (pageColors === null || pageColors === void 0 ? void 0 : pageColors.foreground) || null;

            if (canvasCtx) {
              addContextCurrentTransform(canvasCtx);
            }

            this._cachedScaleForStroking = null;
            this._cachedGetSinglePixelWidth = null;
            this._cachedBitmapsMap = new Map();
          }

          getObject(data) {
            var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (typeof data === "string") {
              return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
            }

            return fallback;
          }

          beginDrawing(_ref25) {
            var {
              transform,
              viewport,
              transparency = false,
              background = null
            } = _ref25;
            var width = this.ctx.canvas.width;
            var height = this.ctx.canvas.height;
            var defaultBackgroundColor = background || "#ffffff";
            this.ctx.save();

            if (this.foregroundColor && this.backgroundColor) {
              this.ctx.fillStyle = this.foregroundColor;
              var fg = this.foregroundColor = this.ctx.fillStyle;
              this.ctx.fillStyle = this.backgroundColor;
              var bg = this.backgroundColor = this.ctx.fillStyle;
              var isValidDefaultBg = true;
              var defaultBg = defaultBackgroundColor;
              this.ctx.fillStyle = defaultBackgroundColor;
              defaultBg = this.ctx.fillStyle;
              isValidDefaultBg = typeof defaultBg === "string" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);

              if (fg === "#000000" && bg === "#ffffff" || fg === bg || !isValidDefaultBg) {
                this.foregroundColor = this.backgroundColor = null;
              } else {
                var cB = parseInt(defaultBg.slice(1), 16);
                var rB = (cB && 0xff0000) >> 16;
                var gB = (cB && 0x00ff00) >> 8;
                var bB = cB && 0x0000ff;

                var newComp = x => {
                  x /= 255;
                  return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
                };

                var lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));

                this.selectColor = (r, g, b) => {
                  var lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);
                  return Math.round(lumC) === lumB ? bg : fg;
                };
              }
            }

            this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;
            this.ctx.fillRect(0, 0, width, height);
            this.ctx.restore();

            if (transparency) {
              var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
              this.compositeCtx = this.ctx;
              this.transparentCanvas = transparentCanvas.canvas;
              this.ctx = transparentCanvas.context;
              this.ctx.save();
              this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
            }

            this.ctx.save();
            resetCtxToDefault(this.ctx, this.foregroundColor);

            if (transform) {
              this.ctx.transform.apply(this.ctx, transform);
              this.outputScaleX = transform[0];
              this.outputScaleY = transform[0];
            }

            this.ctx.transform.apply(this.ctx, viewport.transform);
            this.viewportScale = viewport.scale;
            this.baseTransform = this.ctx.mozCurrentTransform.slice();

            if (this.imageLayer) {
              this.imageLayer.beginLayout();
            }
          }

          executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
            var argsArray = operatorList.argsArray;
            var fnArray = operatorList.fnArray;
            var i = executionStartIdx || 0;
            var argsArrayLen = argsArray.length;

            if (argsArrayLen === i) {
              return i;
            }

            var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
            var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
            var steps = 0;
            var commonObjs = this.commonObjs;
            var objs = this.objs;
            var fnId;

            while (true) {
              if (stepper !== undefined && i === stepper.nextBreakPoint) {
                stepper.breakIt(i, continueCallback);
                return i;
              }

              fnId = fnArray[i];

              if (fnId !== _util.OPS.dependency) {
                this[fnId].apply(this, argsArray[i]);
              } else {
                for (var depObjId of argsArray[i]) {
                  var objsPool = depObjId.startsWith("g_") ? commonObjs : objs;

                  if (!objsPool.has(depObjId)) {
                    objsPool.get(depObjId, continueCallback);
                    return i;
                  }
                }
              }

              i++;

              if (i === argsArrayLen) {
                return i;
              }

              if (chunkOperations && ++steps > EXECUTION_STEPS) {
                if (Date.now() > endTime) {
                  continueCallback();
                  return i;
                }

                steps = 0;
              }
            }
          }

          endDrawing() {
            while (this.stateStack.length || this.inSMaskMode) {
              this.restore();
            }

            this.ctx.restore();

            if (this.transparentCanvas) {
              this.ctx = this.compositeCtx;
              this.ctx.save();
              this.ctx.setTransform(1, 0, 0, 1, 0, 0);
              this.ctx.drawImage(this.transparentCanvas, 0, 0);
              this.ctx.restore();
              this.transparentCanvas = null;
            }

            this.cachedCanvases.clear();
            this.cachedPatterns.clear();

            for (var cache of this._cachedBitmapsMap.values()) {
              for (var canvas of cache.values()) {
                if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                  canvas.width = canvas.height = 0;
                }
              }

              cache.clear();
            }

            this._cachedBitmapsMap.clear();

            if (this.imageLayer) {
              this.imageLayer.endLayout();
            }
          }

          _scaleImage(img, inverseTransform) {
            var width = img.width;
            var height = img.height;
            var widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
            var heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
            var paintWidth = width,
                paintHeight = height;
            var tmpCanvasId = "prescale1";
            var tmpCanvas, tmpCtx;

            while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
              var newWidth = paintWidth,
                  newHeight = paintHeight;

              if (widthScale > 2 && paintWidth > 1) {
                newWidth = Math.ceil(paintWidth / 2);
                widthScale /= paintWidth / newWidth;
              }

              if (heightScale > 2 && paintHeight > 1) {
                newHeight = Math.ceil(paintHeight / 2);
                heightScale /= paintHeight / newHeight;
              }

              tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight, false);
              tmpCtx = tmpCanvas.context;
              tmpCtx.clearRect(0, 0, newWidth, newHeight);
              tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
              img = tmpCanvas.canvas;
              paintWidth = newWidth;
              paintHeight = newHeight;
              tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
            }

            return {
              img,
              paintWidth,
              paintHeight
            };
          }

          _createMaskCanvas(img) {
            var ctx = this.ctx;
            var {
              width,
              height
            } = img;
            var fillColor = this.current.fillColor;
            var isPatternFill = this.current.patternFill;
            var currentTransform = ctx.mozCurrentTransform;
            var cache, cacheKey, scaled, maskCanvas;

            if ((img.bitmap || img.data) && img.count > 1) {
              var mainKey = img.bitmap || img.data.buffer;
              var withoutTranslation = currentTransform.slice(0, 4);
              cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);
              cache = this._cachedBitmapsMap.get(mainKey);

              if (!cache) {
                cache = new Map();

                this._cachedBitmapsMap.set(mainKey, cache);
              }

              var cachedImage = cache.get(cacheKey);

              if (cachedImage && !isPatternFill) {
                var _offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);

                var _offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);

                return {
                  canvas: cachedImage,
                  offsetX: _offsetX,
                  offsetY: _offsetY
                };
              }

              scaled = cachedImage;
            }

            if (!scaled) {
              maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height, false);
              putBinaryImageMask(maskCanvas.context, img);
            }

            var maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);

            maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);

            var cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);

            var cord2 = _util.Util.applyTransform([width, height], maskToCanvas);

            var rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);

            var drawnWidth = Math.round(rect[2] - rect[0]) || 1;
            var drawnHeight = Math.round(rect[3] - rect[1]) || 1;
            var fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight, true);
            var fillCtx = fillCanvas.context;
            var offsetX = Math.min(cord1[0], cord2[0]);
            var offsetY = Math.min(cord1[1], cord2[1]);
            fillCtx.translate(-offsetX, -offsetY);
            fillCtx.transform.apply(fillCtx, maskToCanvas);

            if (!scaled) {
              scaled = this._scaleImage(maskCanvas.canvas, fillCtx.mozCurrentTransformInverse);
              scaled = scaled.img;

              if (cache && isPatternFill) {
                cache.set(cacheKey, scaled);
              }
            }

            fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(fillCtx.mozCurrentTransform, img.interpolate);
            drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
            fillCtx.globalCompositeOperation = "source-in";

            var inverse = _util.Util.transform(fillCtx.mozCurrentTransformInverse, [1, 0, 0, 1, -offsetX, -offsetY]);

            fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
            fillCtx.fillRect(0, 0, width, height);

            if (cache && !isPatternFill) {
              this.cachedCanvases.delete("fillCanvas");
              cache.set(cacheKey, fillCanvas.canvas);
            }

            return {
              canvas: fillCanvas.canvas,
              offsetX: Math.round(offsetX),
              offsetY: Math.round(offsetY)
            };
          }

          setLineWidth(width) {
            if (width !== this.current.lineWidth) {
              this._cachedScaleForStroking = null;
            }

            this.current.lineWidth = width;
            this.ctx.lineWidth = width;
          }

          setLineCap(style) {
            this.ctx.lineCap = LINE_CAP_STYLES[style];
          }

          setLineJoin(style) {
            this.ctx.lineJoin = LINE_JOIN_STYLES[style];
          }

          setMiterLimit(limit) {
            this.ctx.miterLimit = limit;
          }

          setDash(dashArray, dashPhase) {
            var ctx = this.ctx;

            if (ctx.setLineDash !== undefined) {
              ctx.setLineDash(dashArray);
              ctx.lineDashOffset = dashPhase;
            }
          }

          setRenderingIntent(intent) {}

          setFlatness(flatness) {}

          setGState(states) {
            for (var i = 0, ii = states.length; i < ii; i++) {
              var state = states[i];
              var key = state[0];
              var value = state[1];

              switch (key) {
                case "LW":
                  this.setLineWidth(value);
                  break;

                case "LC":
                  this.setLineCap(value);
                  break;

                case "LJ":
                  this.setLineJoin(value);
                  break;

                case "ML":
                  this.setMiterLimit(value);
                  break;

                case "D":
                  this.setDash(value[0], value[1]);
                  break;

                case "RI":
                  this.setRenderingIntent(value);
                  break;

                case "FL":
                  this.setFlatness(value);
                  break;

                case "Font":
                  this.setFont(value[0], value[1]);
                  break;

                case "CA":
                  this.current.strokeAlpha = state[1];
                  break;

                case "ca":
                  this.current.fillAlpha = state[1];
                  this.ctx.globalAlpha = state[1];
                  break;

                case "BM":
                  this.ctx.globalCompositeOperation = value;
                  break;

                case "SMask":
                  this.current.activeSMask = value ? this.tempSMask : null;
                  this.tempSMask = null;
                  this.checkSMaskState();
                  break;

                case "TR":
                  this.current.transferMaps = value;
              }
            }
          }

          get inSMaskMode() {
            return !!this.suspendedCtx;
          }

          checkSMaskState() {
            var inSMaskMode = this.inSMaskMode;

            if (this.current.activeSMask && !inSMaskMode) {
              this.beginSMaskMode();
            } else if (!this.current.activeSMask && inSMaskMode) {
              this.endSMaskMode();
            }
          }

          beginSMaskMode() {
            if (this.inSMaskMode) {
              throw new Error("beginSMaskMode called while already in smask mode");
            }

            var drawnWidth = this.ctx.canvas.width;
            var drawnHeight = this.ctx.canvas.height;
            var cacheId = "smaskGroupAt" + this.groupLevel;
            var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
            this.suspendedCtx = this.ctx;
            this.ctx = scratchCanvas.context;
            var ctx = this.ctx;
            ctx.setTransform.apply(ctx, this.suspendedCtx.mozCurrentTransform);
            copyCtxState(this.suspendedCtx, ctx);
            mirrorContextOperations(ctx, this.suspendedCtx);
            this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
          }

          endSMaskMode() {
            if (!this.inSMaskMode) {
              throw new Error("endSMaskMode called while not in smask mode");
            }

            this.ctx._removeMirroring();

            copyCtxState(this.ctx, this.suspendedCtx);
            this.ctx = this.suspendedCtx;
            this.suspendedCtx = null;
          }

          compose(dirtyBox) {
            if (!this.current.activeSMask) {
              return;
            }

            if (!dirtyBox) {
              dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
            } else {
              dirtyBox[0] = Math.floor(dirtyBox[0]);
              dirtyBox[1] = Math.floor(dirtyBox[1]);
              dirtyBox[2] = Math.ceil(dirtyBox[2]);
              dirtyBox[3] = Math.ceil(dirtyBox[3]);
            }

            var smask = this.current.activeSMask;
            var suspendedCtx = this.suspendedCtx;
            composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            this.ctx.restore();
          }

          save() {
            if (this.inSMaskMode) {
              copyCtxState(this.ctx, this.suspendedCtx);
              this.suspendedCtx.save();
            } else {
              this.ctx.save();
            }

            var old = this.current;
            this.stateStack.push(old);
            this.current = old.clone();
          }

          restore() {
            if (this.stateStack.length === 0 && this.inSMaskMode) {
              this.endSMaskMode();
            }

            if (this.stateStack.length !== 0) {
              this.current = this.stateStack.pop();

              if (this.inSMaskMode) {
                this.suspendedCtx.restore();
                copyCtxState(this.suspendedCtx, this.ctx);
              } else {
                this.ctx.restore();
              }

              this.checkSMaskState();
              this.pendingClip = null;
              this._cachedScaleForStroking = null;
              this._cachedGetSinglePixelWidth = null;
            }
          }

          transform(a, b, c, d, e, f) {
            this.ctx.transform(a, b, c, d, e, f);
            this._cachedScaleForStroking = null;
            this._cachedGetSinglePixelWidth = null;
          }

          constructPath(ops, args, minMax) {
            var ctx = this.ctx;
            var current = this.current;
            var x = current.x,
                y = current.y;
            var startX, startY;
            var currentTransform = ctx.mozCurrentTransform;
            var isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
            var minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;

            for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
              switch (ops[i] | 0) {
                case _util.OPS.rectangle:
                  x = args[j++];
                  y = args[j++];
                  var width = args[j++];
                  var height = args[j++];
                  var xw = x + width;
                  var yh = y + height;
                  ctx.moveTo(x, y);

                  if (width === 0 || height === 0) {
                    ctx.lineTo(xw, yh);
                  } else {
                    ctx.lineTo(xw, y);
                    ctx.lineTo(xw, yh);
                    ctx.lineTo(x, yh);
                  }

                  if (!isScalingMatrix) {
                    current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
                  }

                  ctx.closePath();
                  break;

                case _util.OPS.moveTo:
                  x = args[j++];
                  y = args[j++];
                  ctx.moveTo(x, y);

                  if (!isScalingMatrix) {
                    current.updatePathMinMax(currentTransform, x, y);
                  }

                  break;

                case _util.OPS.lineTo:
                  x = args[j++];
                  y = args[j++];
                  ctx.lineTo(x, y);

                  if (!isScalingMatrix) {
                    current.updatePathMinMax(currentTransform, x, y);
                  }

                  break;

                case _util.OPS.curveTo:
                  startX = x;
                  startY = y;
                  x = args[j + 4];
                  y = args[j + 5];
                  ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                  current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                  j += 6;
                  break;

                case _util.OPS.curveTo2:
                  startX = x;
                  startY = y;
                  ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                  current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                  x = args[j + 2];
                  y = args[j + 3];
                  j += 4;
                  break;

                case _util.OPS.curveTo3:
                  startX = x;
                  startY = y;
                  x = args[j + 2];
                  y = args[j + 3];
                  ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                  current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                  j += 4;
                  break;

                case _util.OPS.closePath:
                  ctx.closePath();
                  break;
              }
            }

            if (isScalingMatrix) {
              current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
            }

            current.setCurrentPoint(x, y);
          }

          closePath() {
            this.ctx.closePath();
          }

          stroke(consumePath) {
            consumePath = typeof consumePath !== "undefined" ? consumePath : true;
            var ctx = this.ctx;
            var strokeColor = this.current.strokeColor;
            ctx.globalAlpha = this.current.strokeAlpha;

            if (this.contentVisible) {
              if (typeof strokeColor === "object" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {
                ctx.save();
                ctx.strokeStyle = strokeColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.STROKE);
                this.rescaleAndStroke(false);
                ctx.restore();
              } else {
                this.rescaleAndStroke(true);
              }
            }

            if (consumePath) {
              this.consumePath(this.current.getClippedPathBoundingBox());
            }

            ctx.globalAlpha = this.current.fillAlpha;
          }

          closeStroke() {
            this.closePath();
            this.stroke();
          }

          fill(consumePath) {
            consumePath = typeof consumePath !== "undefined" ? consumePath : true;
            var ctx = this.ctx;
            var fillColor = this.current.fillColor;
            var isPatternFill = this.current.patternFill;
            var needRestore = false;

            if (isPatternFill) {
              ctx.save();
              ctx.fillStyle = fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
              needRestore = true;
            }

            var intersect = this.current.getClippedPathBoundingBox();

            if (this.contentVisible && intersect !== null) {
              if (this.pendingEOFill) {
                ctx.fill("evenodd");
                this.pendingEOFill = false;
              } else {
                ctx.fill();
              }
            }

            if (needRestore) {
              ctx.restore();
            }

            if (consumePath) {
              this.consumePath(intersect);
            }
          }

          eoFill() {
            this.pendingEOFill = true;
            this.fill();
          }

          fillStroke() {
            this.fill(false);
            this.stroke(false);
            this.consumePath();
          }

          eoFillStroke() {
            this.pendingEOFill = true;
            this.fillStroke();
          }

          closeFillStroke() {
            this.closePath();
            this.fillStroke();
          }

          closeEOFillStroke() {
            this.pendingEOFill = true;
            this.closePath();
            this.fillStroke();
          }

          endPath() {
            this.consumePath();
          }

          clip() {
            this.pendingClip = NORMAL_CLIP;
          }

          eoClip() {
            this.pendingClip = EO_CLIP;
          }

          beginText() {
            this.current.textMatrix = _util.IDENTITY_MATRIX;
            this.current.textMatrixScale = 1;
            this.current.x = this.current.lineX = 0;
            this.current.y = this.current.lineY = 0;
          }

          endText() {
            var paths = this.pendingTextPaths;
            var ctx = this.ctx;

            if (paths === undefined) {
              ctx.beginPath();
              return;
            }

            ctx.save();
            ctx.beginPath();

            for (var i = 0; i < paths.length; i++) {
              var path = paths[i];
              ctx.setTransform.apply(ctx, path.transform);
              ctx.translate(path.x, path.y);
              path.addToPath(ctx, path.fontSize);
            }

            ctx.restore();
            ctx.clip();
            ctx.beginPath();
            delete this.pendingTextPaths;
          }

          setCharSpacing(spacing) {
            this.current.charSpacing = spacing;
          }

          setWordSpacing(spacing) {
            this.current.wordSpacing = spacing;
          }

          setHScale(scale) {
            this.current.textHScale = scale / 100;
          }

          setLeading(leading) {
            this.current.leading = -leading;
          }

          setFont(fontRefName, size) {
            var fontObj = this.commonObjs.get(fontRefName);
            var current = this.current;

            if (!fontObj) {
              throw new Error("Can't find font for ".concat(fontRefName));
            }

            current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;

            if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
              (0, _util.warn)("Invalid font matrix for font " + fontRefName);
            }

            if (size < 0) {
              size = -size;
              current.fontDirection = -1;
            } else {
              current.fontDirection = 1;
            }

            this.current.font = fontObj;
            this.current.fontSize = size;

            if (fontObj.isType3Font) {
              return;
            }

            var name = fontObj.loadedName || "sans-serif";
            var bold = "normal";

            if (fontObj.black) {
              bold = "900";
            } else if (fontObj.bold) {
              bold = "bold";
            }

            var italic = fontObj.italic ? "italic" : "normal";
            var typeface = "\"".concat(name, "\", ").concat(fontObj.fallbackName);
            var browserFontSize = size;

            if (size < MIN_FONT_SIZE) {
              browserFontSize = MIN_FONT_SIZE;
            } else if (size > MAX_FONT_SIZE) {
              browserFontSize = MAX_FONT_SIZE;
            }

            this.current.fontSizeScale = size / browserFontSize;
            this.ctx.font = "".concat(italic, " ").concat(bold, " ").concat(browserFontSize, "px ").concat(typeface);
          }

          setTextRenderingMode(mode) {
            this.current.textRenderingMode = mode;
          }

          setTextRise(rise) {
            this.current.textRise = rise;
          }

          moveText(x, y) {
            this.current.x = this.current.lineX += x;
            this.current.y = this.current.lineY += y;
          }

          setLeadingMoveText(x, y) {
            this.setLeading(-y);
            this.moveText(x, y);
          }

          setTextMatrix(a, b, c, d, e, f) {
            this.current.textMatrix = [a, b, c, d, e, f];
            this.current.textMatrixScale = Math.hypot(a, b);
            this.current.x = this.current.lineX = 0;
            this.current.y = this.current.lineY = 0;
          }

          nextLine() {
            this.moveText(0, this.current.leading);
          }

          paintChar(character, x, y, patternTransform) {
            var ctx = this.ctx;
            var current = this.current;
            var font = current.font;
            var textRenderingMode = current.textRenderingMode;
            var fontSize = current.fontSize / current.fontSizeScale;
            var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
            var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
            var patternFill = current.patternFill && !font.missingFile;
            var addToPath;

            if (font.disableFontFace || isAddToPathSet || patternFill) {
              addToPath = font.getPathGenerator(this.commonObjs, character);
            }

            if (font.disableFontFace || patternFill) {
              ctx.save();
              ctx.translate(x, y);
              ctx.beginPath();
              addToPath(ctx, fontSize);

              if (patternTransform) {
                ctx.setTransform.apply(ctx, patternTransform);
              }

              if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                ctx.fill();
              }

              if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                ctx.stroke();
              }

              ctx.restore();
            } else {
              if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                ctx.fillText(character, x, y);
              }

              if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                ctx.strokeText(character, x, y);
              }
            }

            if (isAddToPathSet) {
              var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
              paths.push({
                transform: ctx.mozCurrentTransform,
                x,
                y,
                fontSize,
                addToPath
              });
            }
          }

          get isFontSubpixelAAEnabled() {
            var {
              context: ctx
            } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10, false);
            ctx.scale(1.5, 1);
            ctx.fillText("I", 0, 10);
            var data = ctx.getImageData(0, 0, 10, 10).data;
            var enabled = false;

            for (var i = 3; i < data.length; i += 4) {
              if (data[i] > 0 && data[i] < 255) {
                enabled = true;
                break;
              }
            }

            return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
          }

          showText(glyphs) {
            var current = this.current;
            var font = current.font;

            if (font.isType3Font) {
              return this.showType3Text(glyphs);
            }

            var fontSize = current.fontSize;

            if (fontSize === 0) {
              return undefined;
            }

            var ctx = this.ctx;
            var fontSizeScale = current.fontSizeScale;
            var charSpacing = current.charSpacing;
            var wordSpacing = current.wordSpacing;
            var fontDirection = current.fontDirection;
            var textHScale = current.textHScale * fontDirection;
            var glyphsLength = glyphs.length;
            var vertical = font.vertical;
            var spacingDir = vertical ? 1 : -1;
            var defaultVMetrics = font.defaultVMetrics;
            var widthAdvanceScale = fontSize * current.fontMatrix[0];
            var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
            ctx.save();
            ctx.transform.apply(ctx, current.textMatrix);
            ctx.translate(current.x, current.y + current.textRise);

            if (fontDirection > 0) {
              ctx.scale(textHScale, -1);
            } else {
              ctx.scale(textHScale, 1);
            }

            var patternTransform;

            if (current.patternFill) {
              ctx.save();
              var pattern = current.fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
              patternTransform = ctx.mozCurrentTransform;
              ctx.restore();
              ctx.fillStyle = pattern;
            }

            var lineWidth = current.lineWidth;
            var scale = current.textMatrixScale;

            if (scale === 0 || lineWidth === 0) {
              var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

              if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                lineWidth = this.getSinglePixelWidth();
              }
            } else {
              lineWidth /= scale;
            }

            if (fontSizeScale !== 1.0) {
              ctx.scale(fontSizeScale, fontSizeScale);
              lineWidth /= fontSizeScale;
            }

            ctx.lineWidth = lineWidth;
            var x = 0,
                i;

            for (i = 0; i < glyphsLength; ++i) {
              var glyph = glyphs[i];

              if (typeof glyph === "number") {
                x += spacingDir * glyph * fontSize / 1000;
                continue;
              }

              var restoreNeeded = false;
              var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
              var character = glyph.fontChar;
              var accent = glyph.accent;
              var scaledX = void 0,
                  scaledY = void 0;
              var width = glyph.width;

              if (vertical) {
                var vmetric = glyph.vmetric || defaultVMetrics;
                var vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                var vy = vmetric[2] * widthAdvanceScale;
                width = vmetric ? -vmetric[0] : width;
                scaledX = vx / fontSizeScale;
                scaledY = (x + vy) / fontSizeScale;
              } else {
                scaledX = x / fontSizeScale;
                scaledY = 0;
              }

              if (font.remeasure && width > 0) {
                var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                  var characterScaleX = width / measuredWidth;
                  restoreNeeded = true;
                  ctx.save();
                  ctx.scale(characterScaleX, 1);
                  scaledX /= characterScaleX;
                } else if (width !== measuredWidth) {
                  scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
                }
              }

              if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                if (simpleFillText && !accent) {
                  ctx.fillText(character, scaledX, scaledY);
                } else {
                  this.paintChar(character, scaledX, scaledY, patternTransform);

                  if (accent) {
                    var scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                    var scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                    this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                  }
                }
              }

              var charWidth = void 0;

              if (vertical) {
                charWidth = width * widthAdvanceScale - spacing * fontDirection;
              } else {
                charWidth = width * widthAdvanceScale + spacing * fontDirection;
              }

              x += charWidth;

              if (restoreNeeded) {
                ctx.restore();
              }
            }

            if (vertical) {
              current.y -= x;
            } else {
              current.x += x * textHScale;
            }

            ctx.restore();
            this.compose();
            return undefined;
          }

          showType3Text(glyphs) {
            var ctx = this.ctx;
            var current = this.current;
            var font = current.font;
            var fontSize = current.fontSize;
            var fontDirection = current.fontDirection;
            var spacingDir = font.vertical ? 1 : -1;
            var charSpacing = current.charSpacing;
            var wordSpacing = current.wordSpacing;
            var textHScale = current.textHScale * fontDirection;
            var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
            var glyphsLength = glyphs.length;
            var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
            var i, glyph, width, spacingLength;

            if (isTextInvisible || fontSize === 0) {
              return;
            }

            this._cachedScaleForStroking = null;
            this._cachedGetSinglePixelWidth = null;
            ctx.save();
            ctx.transform.apply(ctx, current.textMatrix);
            ctx.translate(current.x, current.y);
            ctx.scale(textHScale, fontDirection);

            for (i = 0; i < glyphsLength; ++i) {
              glyph = glyphs[i];

              if (typeof glyph === "number") {
                spacingLength = spacingDir * glyph * fontSize / 1000;
                this.ctx.translate(spacingLength, 0);
                current.x += spacingLength * textHScale;
                continue;
              }

              var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
              var operatorList = font.charProcOperatorList[glyph.operatorListId];

              if (!operatorList) {
                (0, _util.warn)("Type3 character \"".concat(glyph.operatorListId, "\" is not available."));
                continue;
              }

              if (this.contentVisible) {
                this.processingType3 = glyph;
                this.save();
                ctx.scale(fontSize, fontSize);
                ctx.transform.apply(ctx, fontMatrix);
                this.executeOperatorList(operatorList);
                this.restore();
              }

              var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

              width = transformed[0] * fontSize + spacing;
              ctx.translate(width, 0);
              current.x += width * textHScale;
            }

            ctx.restore();
            this.processingType3 = null;
          }

          setCharWidth(xWidth, yWidth) {}

          setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
            this.ctx.rect(llx, lly, urx - llx, ury - lly);
            this.ctx.clip();
            this.endPath();
          }

          getColorN_Pattern(IR) {
            var pattern;

            if (IR[0] === "TilingPattern") {
              var color = IR[1];
              var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
              var canvasGraphicsFactory = {
                createCanvasGraphics: ctx => {
                  return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
                }
              };
              pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
            } else {
              pattern = this._getPattern(IR[1], IR[2]);
            }

            return pattern;
          }

          setStrokeColorN() {
            this.current.strokeColor = this.getColorN_Pattern(arguments);
          }

          setFillColorN() {
            this.current.fillColor = this.getColorN_Pattern(arguments);
            this.current.patternFill = true;
          }

          setStrokeRGBColor(r, g, b) {
            var _this$selectColor;

            var color = ((_this$selectColor = this.selectColor) === null || _this$selectColor === void 0 ? void 0 : _this$selectColor.call(this, r, g, b)) || _util.Util.makeHexColor(r, g, b);

            this.ctx.strokeStyle = color;
            this.current.strokeColor = color;
          }

          setFillRGBColor(r, g, b) {
            var _this$selectColor2;

            var color = ((_this$selectColor2 = this.selectColor) === null || _this$selectColor2 === void 0 ? void 0 : _this$selectColor2.call(this, r, g, b)) || _util.Util.makeHexColor(r, g, b);

            this.ctx.fillStyle = color;
            this.current.fillColor = color;
            this.current.patternFill = false;
          }

          _getPattern(objId) {
            var matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var pattern;

            if (this.cachedPatterns.has(objId)) {
              pattern = this.cachedPatterns.get(objId);
            } else {
              pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
              this.cachedPatterns.set(objId, pattern);
            }

            if (matrix) {
              pattern.matrix = matrix;
            }

            return pattern;
          }

          shadingFill(objId) {
            if (!this.contentVisible) {
              return;
            }

            var ctx = this.ctx;
            this.save();

            var pattern = this._getPattern(objId);

            ctx.fillStyle = pattern.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.SHADING);
            var inv = ctx.mozCurrentTransformInverse;

            if (inv) {
              var canvas = ctx.canvas;
              var width = canvas.width;
              var height = canvas.height;

              var bl = _util.Util.applyTransform([0, 0], inv);

              var br = _util.Util.applyTransform([0, height], inv);

              var ul = _util.Util.applyTransform([width, 0], inv);

              var ur = _util.Util.applyTransform([width, height], inv);

              var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
              var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
              var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
              var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
              this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
            } else {
              this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
            }

            this.compose(this.current.getClippedPathBoundingBox());
            this.restore();
          }

          beginInlineImage() {
            (0, _util.unreachable)("Should not call beginInlineImage");
          }

          beginImageData() {
            (0, _util.unreachable)("Should not call beginImageData");
          }

          paintFormXObjectBegin(matrix, bbox) {
            if (!this.contentVisible) {
              return;
            }

            this.save();
            this.baseTransformStack.push(this.baseTransform);

            if (Array.isArray(matrix) && matrix.length === 6) {
              this.transform.apply(this, matrix);
            }

            this.baseTransform = this.ctx.mozCurrentTransform;

            if (bbox) {
              var width = bbox[2] - bbox[0];
              var height = bbox[3] - bbox[1];
              this.ctx.rect(bbox[0], bbox[1], width, height);
              this.current.updateRectMinMax(this.ctx.mozCurrentTransform, bbox);
              this.clip();
              this.endPath();
            }
          }

          paintFormXObjectEnd() {
            if (!this.contentVisible) {
              return;
            }

            this.restore();
            this.baseTransform = this.baseTransformStack.pop();
          }

          beginGroup(group) {
            if (!this.contentVisible) {
              return;
            }

            this.save();

            if (this.inSMaskMode) {
              this.endSMaskMode();
              this.current.activeSMask = null;
            }

            var currentCtx = this.ctx;

            if (!group.isolated) {
              (0, _util.info)("TODO: Support non-isolated groups.");
            }

            if (group.knockout) {
              (0, _util.warn)("Knockout groups not supported.");
            }

            var currentTransform = currentCtx.mozCurrentTransform;

            if (group.matrix) {
              currentCtx.transform.apply(currentCtx, group.matrix);
            }

            if (!group.bbox) {
              throw new Error("Bounding box is required.");
            }

            var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);

            var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
            bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
            var offsetX = Math.floor(bounds[0]);
            var offsetY = Math.floor(bounds[1]);
            var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
            var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
            var scaleX = 1,
                scaleY = 1;

            if (drawnWidth > MAX_GROUP_SIZE) {
              scaleX = drawnWidth / MAX_GROUP_SIZE;
              drawnWidth = MAX_GROUP_SIZE;
            }

            if (drawnHeight > MAX_GROUP_SIZE) {
              scaleY = drawnHeight / MAX_GROUP_SIZE;
              drawnHeight = MAX_GROUP_SIZE;
            }

            this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
            var cacheId = "groupAt" + this.groupLevel;

            if (group.smask) {
              cacheId += "_smask_" + this.smaskCounter++ % 2;
            }

            var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
            var groupCtx = scratchCanvas.context;
            groupCtx.scale(1 / scaleX, 1 / scaleY);
            groupCtx.translate(-offsetX, -offsetY);
            groupCtx.transform.apply(groupCtx, currentTransform);

            if (group.smask) {
              this.smaskStack.push({
                canvas: scratchCanvas.canvas,
                context: groupCtx,
                offsetX,
                offsetY,
                scaleX,
                scaleY,
                subtype: group.smask.subtype,
                backdrop: group.smask.backdrop,
                transferMap: group.smask.transferMap || null,
                startTransformInverse: null
              });
            } else {
              currentCtx.setTransform(1, 0, 0, 1, 0, 0);
              currentCtx.translate(offsetX, offsetY);
              currentCtx.scale(scaleX, scaleY);
              currentCtx.save();
            }

            copyCtxState(currentCtx, groupCtx);
            this.ctx = groupCtx;
            this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            this.groupStack.push(currentCtx);
            this.groupLevel++;
          }

          endGroup(group) {
            if (!this.contentVisible) {
              return;
            }

            this.groupLevel--;
            var groupCtx = this.ctx;
            var ctx = this.groupStack.pop();
            this.ctx = ctx;
            this.ctx.imageSmoothingEnabled = false;

            if (group.smask) {
              this.tempSMask = this.smaskStack.pop();
              this.restore();
            } else {
              this.ctx.restore();
              var currentMtx = this.ctx.mozCurrentTransform;
              this.restore();
              this.ctx.save();
              this.ctx.setTransform.apply(this.ctx, currentMtx);

              var dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);

              this.ctx.drawImage(groupCtx.canvas, 0, 0);
              this.ctx.restore();
              this.compose(dirtyBox);
            }
          }

          beginAnnotations() {
            this.save();

            if (this.baseTransform) {
              this.ctx.setTransform.apply(this.ctx, this.baseTransform);
            }
          }

          endAnnotations() {
            this.restore();
          }

          beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
            this.save();

            if (Array.isArray(rect) && rect.length === 4) {
              var width = rect[2] - rect[0];
              var height = rect[3] - rect[1];

              if (hasOwnCanvas && this.annotationCanvasMap) {
                transform = transform.slice();
                transform[4] -= rect[0];
                transform[5] -= rect[1];
                rect = rect.slice();
                rect[0] = rect[1] = 0;
                rect[2] = width;
                rect[3] = height;

                var [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(this.ctx.mozCurrentTransform);

                var {
                  viewportScale
                } = this;
                var canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                var canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                var {
                  canvas,
                  context
                } = this.annotationCanvas;
                var viewportScaleFactorStr = "var(--zoom-factor) * ".concat(_display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);
                canvas.style.width = "calc(".concat(width, "px * ").concat(viewportScaleFactorStr, ")");
                canvas.style.height = "calc(".concat(height, "px * ").concat(viewportScaleFactorStr, ")");
                this.annotationCanvasMap.set(id, canvas);
                this.annotationCanvas.savedCtx = this.ctx;
                this.ctx = context;
                this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                addContextCurrentTransform(this.ctx);
                resetCtxToDefault(this.ctx, this.foregroundColor);
              } else {
                resetCtxToDefault(this.ctx, this.foregroundColor);
                this.ctx.rect(rect[0], rect[1], width, height);
                this.ctx.clip();
                this.endPath();
              }
            }

            this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
            this.transform.apply(this, transform);
            this.transform.apply(this, matrix);
          }

          endAnnotation() {
            if (this.annotationCanvas) {
              this.ctx = this.annotationCanvas.savedCtx;
              delete this.annotationCanvas.savedCtx;
              delete this.annotationCanvas;
            }

            this.restore();
          }

          paintImageMaskXObject(img) {
            if (!this.contentVisible) {
              return;
            }

            var count = img.count;
            img = this.getObject(img.data, img);
            img.count = count;
            var ctx = this.ctx;
            var glyph = this.processingType3;

            if (glyph) {
              if (glyph.compiled === undefined) {
                glyph.compiled = compileType3Glyph(img);
              }

              if (glyph.compiled) {
                glyph.compiled(ctx);
                return;
              }
            }

            var mask = this._createMaskCanvas(img);

            var maskCanvas = mask.canvas;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
            ctx.restore();
            this.compose();
          }

          paintImageMaskXObjectRepeat(img, scaleX) {
            var skewX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var skewY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var scaleY = arguments.length > 4 ? arguments[4] : undefined;
            var positions = arguments.length > 5 ? arguments[5] : undefined;

            if (!this.contentVisible) {
              return;
            }

            img = this.getObject(img.data, img);
            var ctx = this.ctx;
            ctx.save();
            var currentTransform = ctx.mozCurrentTransform;
            ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);

            var mask = this._createMaskCanvas(img);

            ctx.setTransform(1, 0, 0, 1, 0, 0);

            for (var i = 0, ii = positions.length; i < ii; i += 2) {
              var trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);

              var [x, y] = _util.Util.applyTransform([0, 0], trans);

              ctx.drawImage(mask.canvas, x, y);
            }

            ctx.restore();
            this.compose();
          }

          paintImageMaskXObjectGroup(images) {
            if (!this.contentVisible) {
              return;
            }

            var ctx = this.ctx;
            var fillColor = this.current.fillColor;
            var isPatternFill = this.current.patternFill;

            for (var i = 0, ii = images.length; i < ii; i++) {
              var image = images[i];
              var width = image.width,
                  height = image.height;
              var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height, false);
              var maskCtx = maskCanvas.context;
              maskCtx.save();
              putBinaryImageMask(maskCtx, image);
              maskCtx.globalCompositeOperation = "source-in";
              maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL) : fillColor;
              maskCtx.fillRect(0, 0, width, height);
              maskCtx.restore();
              ctx.save();
              ctx.transform.apply(ctx, image.transform);
              ctx.scale(1, -1);
              drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
              ctx.restore();
            }

            this.compose();
          }

          paintImageXObject(objId) {
            if (!this.contentVisible) {
              return;
            }

            var imgData = this.getObject(objId);

            if (!imgData) {
              (0, _util.warn)("Dependent image isn't ready yet");
              return;
            }

            this.paintInlineImageXObject(imgData);
          }

          paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
            if (!this.contentVisible) {
              return;
            }

            var imgData = this.getObject(objId);

            if (!imgData) {
              (0, _util.warn)("Dependent image isn't ready yet");
              return;
            }

            var width = imgData.width;
            var height = imgData.height;
            var map = [];

            for (var i = 0, ii = positions.length; i < ii; i += 2) {
              map.push({
                transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                x: 0,
                y: 0,
                w: width,
                h: height
              });
            }

            this.paintInlineImageXObjectGroup(imgData, map);
          }

          paintInlineImageXObject(imgData) {
            if (!this.contentVisible) {
              return;
            }

            var width = imgData.width;
            var height = imgData.height;
            var ctx = this.ctx;
            this.save();
            ctx.scale(1 / width, -1 / height);
            var imgToPaint;

            if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
              imgToPaint = imgData;
            } else {
              var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height, false);
              var tmpCtx = tmpCanvas.context;
              putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
              imgToPaint = tmpCanvas.canvas;
            }

            var scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);

            ctx.imageSmoothingEnabled = getImageSmoothingEnabled(ctx.mozCurrentTransform, imgData.interpolate);
            var [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);

            if (this.imageLayer) {
              var position = this.getCanvasPosition(0, -height);
              this.imageLayer.appendImage({
                imgData,
                left: position[0],
                top: position[1],
                width: rWidth,
                height: rHeight
              });
            }

            this.compose();
            this.restore();
          }

          paintInlineImageXObjectGroup(imgData, map) {
            if (!this.contentVisible) {
              return;
            }

            var ctx = this.ctx;
            var w = imgData.width;
            var h = imgData.height;
            var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h, false);
            var tmpCtx = tmpCanvas.context;
            putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);

            for (var i = 0, ii = map.length; i < ii; i++) {
              var entry = map[i];
              ctx.save();
              ctx.transform.apply(ctx, entry.transform);
              ctx.scale(1, -1);
              drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

              if (this.imageLayer) {
                var position = this.getCanvasPosition(entry.x, entry.y);
                this.imageLayer.appendImage({
                  imgData,
                  left: position[0],
                  top: position[1],
                  width: w,
                  height: h
                });
              }

              ctx.restore();
            }

            this.compose();
          }

          paintSolidColorImageMask() {
            if (!this.contentVisible) {
              return;
            }

            this.ctx.fillRect(0, 0, 1, 1);
            this.compose();
          }

          markPoint(tag) {}

          markPointProps(tag, properties) {}

          beginMarkedContent(tag) {
            this.markedContentStack.push({
              visible: true
            });
          }

          beginMarkedContentProps(tag, properties) {
            if (tag === "OC") {
              this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(properties)
              });
            } else {
              this.markedContentStack.push({
                visible: true
              });
            }

            this.contentVisible = this.isContentVisible();
          }

          endMarkedContent() {
            this.markedContentStack.pop();
            this.contentVisible = this.isContentVisible();
          }

          beginCompat() {}

          endCompat() {}

          consumePath(clipBox) {
            var isEmpty = this.current.isEmptyClip();

            if (this.pendingClip) {
              this.current.updateClipFromPath();
            }

            if (!this.pendingClip) {
              this.compose(clipBox);
            }

            var ctx = this.ctx;

            if (this.pendingClip) {
              if (!isEmpty) {
                if (this.pendingClip === EO_CLIP) {
                  ctx.clip("evenodd");
                } else {
                  ctx.clip();
                }
              }

              this.pendingClip = null;
            }

            this.current.startNewPathAndClipBox(this.current.clipBox);
            ctx.beginPath();
          }

          getSinglePixelWidth() {
            if (!this._cachedGetSinglePixelWidth) {
              var m = this.ctx.mozCurrentTransform;

              if (m[1] === 0 && m[2] === 0) {
                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
              } else {
                var absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                var normX = Math.hypot(m[0], m[2]);
                var normY = Math.hypot(m[1], m[3]);
                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
              }
            }

            return this._cachedGetSinglePixelWidth;
          }

          getScaleForStroking() {
            if (!this._cachedScaleForStroking) {
              var {
                lineWidth
              } = this.current;
              var m = this.ctx.mozCurrentTransform;
              var scaleX, scaleY;

              if (m[1] === 0 && m[2] === 0) {
                var normX = Math.abs(m[0]);
                var normY = Math.abs(m[3]);

                if (lineWidth === 0) {
                  scaleX = 1 / normX;
                  scaleY = 1 / normY;
                } else {
                  var scaledXLineWidth = normX * lineWidth;
                  var scaledYLineWidth = normY * lineWidth;
                  scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                  scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                }
              } else {
                var absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);

                var _normX = Math.hypot(m[0], m[1]);

                var _normY = Math.hypot(m[2], m[3]);

                if (lineWidth === 0) {
                  scaleX = _normY / absDet;
                  scaleY = _normX / absDet;
                } else {
                  var baseArea = lineWidth * absDet;
                  scaleX = _normY > baseArea ? _normY / baseArea : 1;
                  scaleY = _normX > baseArea ? _normX / baseArea : 1;
                }
              }

              this._cachedScaleForStroking = [scaleX, scaleY];
            }

            return this._cachedScaleForStroking;
          }

          rescaleAndStroke(saveRestore) {
            var {
              ctx
            } = this;
            var {
              lineWidth
            } = this.current;
            var [scaleX, scaleY] = this.getScaleForStroking();
            ctx.lineWidth = lineWidth || 1;

            if (scaleX === 1 && scaleY === 1) {
              ctx.stroke();
              return;
            }

            var savedMatrix, savedDashes, savedDashOffset;

            if (saveRestore) {
              savedMatrix = ctx.mozCurrentTransform.slice();
              savedDashes = ctx.getLineDash().slice();
              savedDashOffset = ctx.lineDashOffset;
            }

            ctx.scale(scaleX, scaleY);
            var scale = Math.max(scaleX, scaleY);
            ctx.setLineDash(ctx.getLineDash().map(x => x / scale));
            ctx.lineDashOffset /= scale;
            ctx.stroke();

            if (saveRestore) {
              ctx.setTransform(...savedMatrix);
              ctx.setLineDash(savedDashes);
              ctx.lineDashOffset = savedDashOffset;
            }
          }

          getCanvasPosition(x, y) {
            var transform = this.ctx.mozCurrentTransform;
            return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
          }

          isContentVisible() {
            for (var i = this.markedContentStack.length - 1; i >= 0; i--) {
              if (!this.markedContentStack[i].visible) {
                return false;
              }
            }

            return true;
          }

        }

        exports.CanvasGraphics = CanvasGraphics;

        for (var op in _util.OPS) {
          if (CanvasGraphics.prototype[op] !== undefined) {
            CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
          }
        }
        /***/

      },
      /* 11 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.TilingPattern = exports.PathType = void 0;
        exports.getShadingPattern = getShadingPattern;

        var _util = __w_pdfjs_require__(1);

        var _is_node = __w_pdfjs_require__(3);

        var PathType = {
          FILL: "Fill",
          STROKE: "Stroke",
          SHADING: "Shading"
        };
        exports.PathType = PathType;

        function applyBoundingBox(ctx, bbox) {
          if (!bbox || _is_node.isNodeJS) {
            return;
          }

          var width = bbox[2] - bbox[0];
          var height = bbox[3] - bbox[1];
          var region = new Path2D();
          region.rect(bbox[0], bbox[1], width, height);
          ctx.clip(region);
        }

        class BaseShadingPattern {
          constructor() {
            if (this.constructor === BaseShadingPattern) {
              (0, _util.unreachable)("Cannot initialize BaseShadingPattern.");
            }
          }

          getPattern() {
            (0, _util.unreachable)("Abstract method `getPattern` called.");
          }

        }

        class RadialAxialShadingPattern extends BaseShadingPattern {
          constructor(IR) {
            super();
            this._type = IR[1];
            this._bbox = IR[2];
            this._colorStops = IR[3];
            this._p0 = IR[4];
            this._p1 = IR[5];
            this._r0 = IR[6];
            this._r1 = IR[7];
            this.matrix = null;
          }

          _createGradient(ctx) {
            var grad;

            if (this._type === "axial") {
              grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
            } else if (this._type === "radial") {
              grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
            }

            for (var colorStop of this._colorStops) {
              grad.addColorStop(colorStop[0], colorStop[1]);
            }

            return grad;
          }

          getPattern(ctx, owner, inverse, pathType) {
            var pattern;

            if (pathType === PathType.STROKE || pathType === PathType.FILL) {
              var ownerBBox = owner.current.getClippedPathBoundingBox(pathType, ctx.mozCurrentTransform) || [0, 0, 0, 0];
              var width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
              var height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
              var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
              var tmpCtx = tmpCanvas.context;
              tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
              tmpCtx.beginPath();
              tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
              tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
              inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
              tmpCtx.transform.apply(tmpCtx, owner.baseTransform);

              if (this.matrix) {
                tmpCtx.transform.apply(tmpCtx, this.matrix);
              }

              applyBoundingBox(tmpCtx, this._bbox);
              tmpCtx.fillStyle = this._createGradient(tmpCtx);
              tmpCtx.fill();
              pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
              var domMatrix = new DOMMatrix(inverse);

              try {
                pattern.setTransform(domMatrix);
              } catch (ex) {
                (0, _util.warn)("RadialAxialShadingPattern.getPattern: \"".concat(ex === null || ex === void 0 ? void 0 : ex.message, "\"."));
              }
            } else {
              applyBoundingBox(ctx, this._bbox);
              pattern = this._createGradient(ctx);
            }

            return pattern;
          }

        }

        function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
          var coords = context.coords,
              colors = context.colors;
          var bytes = data.data,
              rowSize = data.width * 4;
          var tmp;

          if (coords[p1 + 1] > coords[p2 + 1]) {
            tmp = p1;
            p1 = p2;
            p2 = tmp;
            tmp = c1;
            c1 = c2;
            c2 = tmp;
          }

          if (coords[p2 + 1] > coords[p3 + 1]) {
            tmp = p2;
            p2 = p3;
            p3 = tmp;
            tmp = c2;
            c2 = c3;
            c3 = tmp;
          }

          if (coords[p1 + 1] > coords[p2 + 1]) {
            tmp = p1;
            p1 = p2;
            p2 = tmp;
            tmp = c1;
            c1 = c2;
            c2 = tmp;
          }

          var x1 = (coords[p1] + context.offsetX) * context.scaleX;
          var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
          var x2 = (coords[p2] + context.offsetX) * context.scaleX;
          var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
          var x3 = (coords[p3] + context.offsetX) * context.scaleX;
          var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

          if (y1 >= y3) {
            return;
          }

          var c1r = colors[c1],
              c1g = colors[c1 + 1],
              c1b = colors[c1 + 2];
          var c2r = colors[c2],
              c2g = colors[c2 + 1],
              c2b = colors[c2 + 2];
          var c3r = colors[c3],
              c3g = colors[c3 + 1],
              c3b = colors[c3 + 2];
          var minY = Math.round(y1),
              maxY = Math.round(y3);
          var xa, car, cag, cab;
          var xb, cbr, cbg, cbb;

          for (var y = minY; y <= maxY; y++) {
            if (y < y2) {
              var _k7 = void 0;

              if (y < y1) {
                _k7 = 0;
              } else {
                _k7 = (y1 - y) / (y1 - y2);
              }

              xa = x1 - (x1 - x2) * _k7;
              car = c1r - (c1r - c2r) * _k7;
              cag = c1g - (c1g - c2g) * _k7;
              cab = c1b - (c1b - c2b) * _k7;
            } else {
              var _k8 = void 0;

              if (y > y3) {
                _k8 = 1;
              } else if (y2 === y3) {
                _k8 = 0;
              } else {
                _k8 = (y2 - y) / (y2 - y3);
              }

              xa = x2 - (x2 - x3) * _k8;
              car = c2r - (c2r - c3r) * _k8;
              cag = c2g - (c2g - c3g) * _k8;
              cab = c2b - (c2b - c3b) * _k8;
            }

            var k = void 0;

            if (y < y1) {
              k = 0;
            } else if (y > y3) {
              k = 1;
            } else {
              k = (y1 - y) / (y1 - y3);
            }

            xb = x1 - (x1 - x3) * k;
            cbr = c1r - (c1r - c3r) * k;
            cbg = c1g - (c1g - c3g) * k;
            cbb = c1b - (c1b - c3b) * k;
            var x1_ = Math.round(Math.min(xa, xb));
            var x2_ = Math.round(Math.max(xa, xb));
            var j = rowSize * y + x1_ * 4;

            for (var x = x1_; x <= x2_; x++) {
              k = (xa - x) / (xa - xb);

              if (k < 0) {
                k = 0;
              } else if (k > 1) {
                k = 1;
              }

              bytes[j++] = car - (car - cbr) * k | 0;
              bytes[j++] = cag - (cag - cbg) * k | 0;
              bytes[j++] = cab - (cab - cbb) * k | 0;
              bytes[j++] = 255;
            }
          }
        }

        function drawFigure(data, figure, context) {
          var ps = figure.coords;
          var cs = figure.colors;
          var i, ii;

          switch (figure.type) {
            case "lattice":
              var verticesPerRow = figure.verticesPerRow;
              var rows = Math.floor(ps.length / verticesPerRow) - 1;
              var cols = verticesPerRow - 1;

              for (i = 0; i < rows; i++) {
                var q = i * verticesPerRow;

                for (var j = 0; j < cols; j++, q++) {
                  drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                  drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                }
              }

              break;

            case "triangles":
              for (i = 0, ii = ps.length; i < ii; i += 3) {
                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
              }

              break;

            default:
              throw new Error("illegal figure");
          }
        }

        class MeshShadingPattern extends BaseShadingPattern {
          constructor(IR) {
            super();
            this._coords = IR[2];
            this._colors = IR[3];
            this._figures = IR[4];
            this._bounds = IR[5];
            this._bbox = IR[7];
            this._background = IR[8];
            this.matrix = null;
          }

          _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
            var EXPECTED_SCALE = 1.1;
            var MAX_PATTERN_SIZE = 3000;
            var BORDER_SIZE = 2;
            var offsetX = Math.floor(this._bounds[0]);
            var offsetY = Math.floor(this._bounds[1]);
            var boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
            var boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
            var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
            var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
            var scaleX = boundsWidth / width;
            var scaleY = boundsHeight / height;
            var context = {
              coords: this._coords,
              colors: this._colors,
              offsetX: -offsetX,
              offsetY: -offsetY,
              scaleX: 1 / scaleX,
              scaleY: 1 / scaleY
            };
            var paddedWidth = width + BORDER_SIZE * 2;
            var paddedHeight = height + BORDER_SIZE * 2;
            var tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
            var tmpCtx = tmpCanvas.context;
            var data = tmpCtx.createImageData(width, height);

            if (backgroundColor) {
              var bytes = data.data;

              for (var i = 0, ii = bytes.length; i < ii; i += 4) {
                bytes[i] = backgroundColor[0];
                bytes[i + 1] = backgroundColor[1];
                bytes[i + 2] = backgroundColor[2];
                bytes[i + 3] = 255;
              }
            }

            for (var figure of this._figures) {
              drawFigure(data, figure, context);
            }

            tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
            var canvas = tmpCanvas.canvas;
            return {
              canvas,
              offsetX: offsetX - BORDER_SIZE * scaleX,
              offsetY: offsetY - BORDER_SIZE * scaleY,
              scaleX,
              scaleY
            };
          }

          getPattern(ctx, owner, inverse, pathType) {
            applyBoundingBox(ctx, this._bbox);
            var scale;

            if (pathType === PathType.SHADING) {
              scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
            } else {
              scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

              if (this.matrix) {
                var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

                scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
              }
            }

            var temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);

            if (pathType !== PathType.SHADING) {
              ctx.setTransform.apply(ctx, owner.baseTransform);

              if (this.matrix) {
                ctx.transform.apply(ctx, this.matrix);
              }
            }

            ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
            ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
            return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
          }

        }

        class DummyShadingPattern extends BaseShadingPattern {
          getPattern() {
            return "hotpink";
          }

        }

        function getShadingPattern(IR) {
          switch (IR[0]) {
            case "RadialAxial":
              return new RadialAxialShadingPattern(IR);

            case "Mesh":
              return new MeshShadingPattern(IR);

            case "Dummy":
              return new DummyShadingPattern();
          }

          throw new Error("Unknown IR type: ".concat(IR[0]));
        }

        var PaintType = {
          COLORED: 1,
          UNCOLORED: 2
        };

        class TilingPattern {
          static get MAX_PATTERN_SIZE() {
            return (0, _util.shadow)(this, "MAX_PATTERN_SIZE", 3000);
          }

          constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
            this.operatorList = IR[2];
            this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
            this.bbox = IR[4];
            this.xstep = IR[5];
            this.ystep = IR[6];
            this.paintType = IR[7];
            this.tilingType = IR[8];
            this.color = color;
            this.ctx = ctx;
            this.canvasGraphicsFactory = canvasGraphicsFactory;
            this.baseTransform = baseTransform;
          }

          createPatternCanvas(owner) {
            var operatorList = this.operatorList;
            var bbox = this.bbox;
            var xstep = this.xstep;
            var ystep = this.ystep;
            var paintType = this.paintType;
            var tilingType = this.tilingType;
            var color = this.color;
            var canvasGraphicsFactory = this.canvasGraphicsFactory;
            (0, _util.info)("TilingType: " + tilingType);
            var x0 = bbox[0],
                y0 = bbox[1],
                x1 = bbox[2],
                y1 = bbox[3];

            var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

            var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

            var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
            var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
            var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
            var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
            var tmpCtx = tmpCanvas.context;
            var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
            graphics.groupLevel = owner.groupLevel;
            this.setFillAndStrokeStyleToContext(graphics, paintType, color);
            var adjustedX0 = x0;
            var adjustedY0 = y0;
            var adjustedX1 = x1;
            var adjustedY1 = y1;

            if (x0 < 0) {
              adjustedX0 = 0;
              adjustedX1 += Math.abs(x0);
            }

            if (y0 < 0) {
              adjustedY0 = 0;
              adjustedY1 += Math.abs(y0);
            }

            tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
            graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
            tmpCtx.save();
            this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
            graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();
            graphics.executeOperatorList(operatorList);
            graphics.endDrawing();
            return {
              canvas: tmpCanvas.canvas,
              scaleX: dimx.scale,
              scaleY: dimy.scale,
              offsetX: adjustedX0,
              offsetY: adjustedY0
            };
          }

          getSizeAndScale(step, realOutputSize, scale) {
            step = Math.abs(step);
            var maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
            var size = Math.ceil(step * scale);

            if (size >= maxSize) {
              size = maxSize;
            } else {
              scale = size / step;
            }

            return {
              scale,
              size
            };
          }

          clipBbox(graphics, x0, y0, x1, y1) {
            var bboxWidth = x1 - x0;
            var bboxHeight = y1 - y0;
            graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
            graphics.current.updateRectMinMax(graphics.ctx.mozCurrentTransform, [x0, y0, x1, y1]);
            graphics.clip();
            graphics.endPath();
          }

          setFillAndStrokeStyleToContext(graphics, paintType, color) {
            var context = graphics.ctx,
                current = graphics.current;

            switch (paintType) {
              case PaintType.COLORED:
                var ctx = this.ctx;
                context.fillStyle = ctx.fillStyle;
                context.strokeStyle = ctx.strokeStyle;
                current.fillColor = ctx.fillStyle;
                current.strokeColor = ctx.strokeStyle;
                break;

              case PaintType.UNCOLORED:
                var cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);

                context.fillStyle = cssColor;
                context.strokeStyle = cssColor;
                current.fillColor = cssColor;
                current.strokeColor = cssColor;
                break;

              default:
                throw new _util.FormatError("Unsupported paint type: ".concat(paintType));
            }
          }

          getPattern(ctx, owner, inverse, pathType) {
            var matrix = inverse;

            if (pathType !== PathType.SHADING) {
              matrix = _util.Util.transform(matrix, owner.baseTransform);

              if (this.matrix) {
                matrix = _util.Util.transform(matrix, this.matrix);
              }
            }

            var temporaryPatternCanvas = this.createPatternCanvas(owner);
            var domMatrix = new DOMMatrix(matrix);
            domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
            domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
            var pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");

            try {
              pattern.setTransform(domMatrix);
            } catch (ex) {
              (0, _util.warn)("TilingPattern.getPattern: \"".concat(ex === null || ex === void 0 ? void 0 : ex.message, "\"."));
            }

            return pattern;
          }

        }

        exports.TilingPattern = TilingPattern;
        /***/
      },
      /* 12 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.applyMaskImageData = applyMaskImageData;

        var _util = __w_pdfjs_require__(1);

        function applyMaskImageData(_ref26) {
          var {
            src,
            srcPos = 0,
            dest,
            destPos = 0,
            width,
            height,
            inverseDecode = false
          } = _ref26;
          var opaque = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
          var [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];
          var widthInSource = width >> 3;
          var widthRemainder = width & 7;
          var srcLength = src.length;
          dest = new Uint32Array(dest.buffer);

          for (var i = 0; i < height; i++) {
            for (var max = srcPos + widthInSource; srcPos < max; srcPos++) {
              var _elem = srcPos < srcLength ? src[srcPos] : 255;

              dest[destPos++] = _elem & 0b10000000 ? oneMapping : zeroMapping;
              dest[destPos++] = _elem & 0b1000000 ? oneMapping : zeroMapping;
              dest[destPos++] = _elem & 0b100000 ? oneMapping : zeroMapping;
              dest[destPos++] = _elem & 0b10000 ? oneMapping : zeroMapping;
              dest[destPos++] = _elem & 0b1000 ? oneMapping : zeroMapping;
              dest[destPos++] = _elem & 0b100 ? oneMapping : zeroMapping;
              dest[destPos++] = _elem & 0b10 ? oneMapping : zeroMapping;
              dest[destPos++] = _elem & 0b1 ? oneMapping : zeroMapping;
            }

            if (widthRemainder === 0) {
              continue;
            }

            var elem = srcPos < srcLength ? src[srcPos++] : 255;

            for (var j = 0; j < widthRemainder; j++) {
              dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
            }
          }

          return {
            srcPos,
            destPos
          };
        }
        /***/

      },
      /* 13 */

      /***/
      (__unused_webpack_module, exports) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.GlobalWorkerOptions = void 0;
        var GlobalWorkerOptions = Object.create(null);
        exports.GlobalWorkerOptions = GlobalWorkerOptions;
        GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
        GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;
        /***/
      },
      /* 14 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.MessageHandler = void 0;

        var _util = __w_pdfjs_require__(1);

        var CallbackKind = {
          UNKNOWN: 0,
          DATA: 1,
          ERROR: 2
        };
        var StreamKind = {
          UNKNOWN: 0,
          CANCEL: 1,
          CANCEL_COMPLETE: 2,
          CLOSE: 3,
          ENQUEUE: 4,
          ERROR: 5,
          PULL: 6,
          PULL_COMPLETE: 7,
          START_COMPLETE: 8
        };

        function wrapReason(reason) {
          if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
            (0, _util.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
          }

          switch (reason.name) {
            case "AbortException":
              return new _util.AbortException(reason.message);

            case "MissingPDFException":
              return new _util.MissingPDFException(reason.message);

            case "PasswordException":
              return new _util.PasswordException(reason.message, reason.code);

            case "UnexpectedResponseException":
              return new _util.UnexpectedResponseException(reason.message, reason.status);

            case "UnknownErrorException":
              return new _util.UnknownErrorException(reason.message, reason.details);

            default:
              return new _util.UnknownErrorException(reason.message, reason.toString());
          }
        }

        class MessageHandler {
          constructor(sourceName, targetName, comObj) {
            this.sourceName = sourceName;
            this.targetName = targetName;
            this.comObj = comObj;
            this.callbackId = 1;
            this.streamId = 1;
            this.streamSinks = Object.create(null);
            this.streamControllers = Object.create(null);
            this.callbackCapabilities = Object.create(null);
            this.actionHandler = Object.create(null);

            this._onComObjOnMessage = event => {
              var data = event.data;

              if (data.targetName !== this.sourceName) {
                return;
              }

              if (data.stream) {
                this._processStreamMessage(data);

                return;
              }

              if (data.callback) {
                var callbackId = data.callbackId;
                var capability = this.callbackCapabilities[callbackId];

                if (!capability) {
                  throw new Error("Cannot resolve callback ".concat(callbackId));
                }

                delete this.callbackCapabilities[callbackId];

                if (data.callback === CallbackKind.DATA) {
                  capability.resolve(data.data);
                } else if (data.callback === CallbackKind.ERROR) {
                  capability.reject(wrapReason(data.reason));
                } else {
                  throw new Error("Unexpected callback case");
                }

                return;
              }

              var action = this.actionHandler[data.action];

              if (!action) {
                throw new Error("Unknown action from worker: ".concat(data.action));
              }

              if (data.callbackId) {
                var cbSourceName = this.sourceName;
                var cbTargetName = data.sourceName;
                new Promise(function (resolve) {
                  resolve(action(data.data));
                }).then(function (result) {
                  comObj.postMessage({
                    sourceName: cbSourceName,
                    targetName: cbTargetName,
                    callback: CallbackKind.DATA,
                    callbackId: data.callbackId,
                    data: result
                  });
                }, function (reason) {
                  comObj.postMessage({
                    sourceName: cbSourceName,
                    targetName: cbTargetName,
                    callback: CallbackKind.ERROR,
                    callbackId: data.callbackId,
                    reason: wrapReason(reason)
                  });
                });
                return;
              }

              if (data.streamId) {
                this._createStreamSink(data);

                return;
              }

              action(data.data);
            };

            comObj.addEventListener("message", this._onComObjOnMessage);
          }

          on(actionName, handler) {
            var ah = this.actionHandler;

            if (ah[actionName]) {
              throw new Error("There is already an actionName called \"".concat(actionName, "\""));
            }

            ah[actionName] = handler;
          }

          send(actionName, data, transfers) {
            this.comObj.postMessage({
              sourceName: this.sourceName,
              targetName: this.targetName,
              action: actionName,
              data
            }, transfers);
          }

          sendWithPromise(actionName, data, transfers) {
            var callbackId = this.callbackId++;
            var capability = (0, _util.createPromiseCapability)();
            this.callbackCapabilities[callbackId] = capability;

            try {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: actionName,
                callbackId,
                data
              }, transfers);
            } catch (ex) {
              capability.reject(ex);
            }

            return capability.promise;
          }

          sendWithStream(actionName, data, queueingStrategy, transfers) {
            var streamId = this.streamId++,
                sourceName = this.sourceName,
                targetName = this.targetName,
                comObj = this.comObj;
            return new ReadableStream({
              start: controller => {
                var startCapability = (0, _util.createPromiseCapability)();
                this.streamControllers[streamId] = {
                  controller,
                  startCall: startCapability,
                  pullCall: null,
                  cancelCall: null,
                  isClosed: false
                };
                comObj.postMessage({
                  sourceName,
                  targetName,
                  action: actionName,
                  streamId,
                  data,
                  desiredSize: controller.desiredSize
                }, transfers);
                return startCapability.promise;
              },
              pull: controller => {
                var pullCapability = (0, _util.createPromiseCapability)();
                this.streamControllers[streamId].pullCall = pullCapability;
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.PULL,
                  streamId,
                  desiredSize: controller.desiredSize
                });
                return pullCapability.promise;
              },
              cancel: reason => {
                (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
                var cancelCapability = (0, _util.createPromiseCapability)();
                this.streamControllers[streamId].cancelCall = cancelCapability;
                this.streamControllers[streamId].isClosed = true;
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.CANCEL,
                  streamId,
                  reason: wrapReason(reason)
                });
                return cancelCapability.promise;
              }
            }, queueingStrategy);
          }

          _createStreamSink(data) {
            var streamId = data.streamId,
                sourceName = this.sourceName,
                targetName = data.sourceName,
                comObj = this.comObj;
            var self = this,
                action = this.actionHandler[data.action];
            var streamSink = {
              enqueue(chunk) {
                var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                var transfers = arguments.length > 2 ? arguments[2] : undefined;

                if (this.isCancelled) {
                  return;
                }

                var lastDesiredSize = this.desiredSize;
                this.desiredSize -= size;

                if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                  this.sinkCapability = (0, _util.createPromiseCapability)();
                  this.ready = this.sinkCapability.promise;
                }

                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.ENQUEUE,
                  streamId,
                  chunk
                }, transfers);
              },

              close() {
                if (this.isCancelled) {
                  return;
                }

                this.isCancelled = true;
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.CLOSE,
                  streamId
                });
                delete self.streamSinks[streamId];
              },

              error(reason) {
                (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

                if (this.isCancelled) {
                  return;
                }

                this.isCancelled = true;
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.ERROR,
                  streamId,
                  reason: wrapReason(reason)
                });
              },

              sinkCapability: (0, _util.createPromiseCapability)(),
              onPull: null,
              onCancel: null,
              isCancelled: false,
              desiredSize: data.desiredSize,
              ready: null
            };
            streamSink.sinkCapability.resolve();
            streamSink.ready = streamSink.sinkCapability.promise;
            this.streamSinks[streamId] = streamSink;
            new Promise(function (resolve) {
              resolve(action(data.data, streamSink));
            }).then(function () {
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.START_COMPLETE,
                streamId,
                success: true
              });
            }, function (reason) {
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.START_COMPLETE,
                streamId,
                reason: wrapReason(reason)
              });
            });
          }

          _processStreamMessage(data) {
            var streamId = data.streamId,
                sourceName = this.sourceName,
                targetName = data.sourceName,
                comObj = this.comObj;
            var streamController = this.streamControllers[streamId],
                streamSink = this.streamSinks[streamId];

            switch (data.stream) {
              case StreamKind.START_COMPLETE:
                if (data.success) {
                  streamController.startCall.resolve();
                } else {
                  streamController.startCall.reject(wrapReason(data.reason));
                }

                break;

              case StreamKind.PULL_COMPLETE:
                if (data.success) {
                  streamController.pullCall.resolve();
                } else {
                  streamController.pullCall.reject(wrapReason(data.reason));
                }

                break;

              case StreamKind.PULL:
                if (!streamSink) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.PULL_COMPLETE,
                    streamId,
                    success: true
                  });
                  break;
                }

                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                  streamSink.sinkCapability.resolve();
                }

                streamSink.desiredSize = data.desiredSize;
                new Promise(function (resolve) {
                  resolve(streamSink.onPull && streamSink.onPull());
                }).then(function () {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.PULL_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function (reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.PULL_COMPLETE,
                    streamId,
                    reason: wrapReason(reason)
                  });
                });
                break;

              case StreamKind.ENQUEUE:
                (0, _util.assert)(streamController, "enqueue should have stream controller");

                if (streamController.isClosed) {
                  break;
                }

                streamController.controller.enqueue(data.chunk);
                break;

              case StreamKind.CLOSE:
                (0, _util.assert)(streamController, "close should have stream controller");

                if (streamController.isClosed) {
                  break;
                }

                streamController.isClosed = true;
                streamController.controller.close();

                this._deleteStreamController(streamController, streamId);

                break;

              case StreamKind.ERROR:
                (0, _util.assert)(streamController, "error should have stream controller");
                streamController.controller.error(wrapReason(data.reason));

                this._deleteStreamController(streamController, streamId);

                break;

              case StreamKind.CANCEL_COMPLETE:
                if (data.success) {
                  streamController.cancelCall.resolve();
                } else {
                  streamController.cancelCall.reject(wrapReason(data.reason));
                }

                this._deleteStreamController(streamController, streamId);

                break;

              case StreamKind.CANCEL:
                if (!streamSink) {
                  break;
                }

                new Promise(function (resolve) {
                  resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
                }).then(function () {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.CANCEL_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function (reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.CANCEL_COMPLETE,
                    streamId,
                    reason: wrapReason(reason)
                  });
                });
                streamSink.sinkCapability.reject(wrapReason(data.reason));
                streamSink.isCancelled = true;
                delete this.streamSinks[streamId];
                break;

              default:
                throw new Error("Unexpected stream case");
            }
          }

          _deleteStreamController(streamController, streamId) {
            var _this10 = this;

            return _asyncToGenerator(function* () {
              yield Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
              delete _this10.streamControllers[streamId];
            })();
          }

          destroy() {
            this.comObj.removeEventListener("message", this._onComObjOnMessage);
          }

        }

        exports.MessageHandler = MessageHandler;
        /***/
      },
      /* 15 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.Metadata = void 0;

        var _util = __w_pdfjs_require__(1);

        var _metadataMap = /*#__PURE__*/new WeakMap();

        var _data = /*#__PURE__*/new WeakMap();

        class Metadata {
          constructor(_ref27) {
            var {
              parsedData,
              rawData
            } = _ref27;

            _classPrivateFieldInitSpec(this, _metadataMap, {
              writable: true,
              value: void 0
            });

            _classPrivateFieldInitSpec(this, _data, {
              writable: true,
              value: void 0
            });

            _classPrivateFieldSet(this, _metadataMap, parsedData);

            _classPrivateFieldSet(this, _data, rawData);
          }

          getRaw() {
            return _classPrivateFieldGet(this, _data);
          }

          get(name) {
            var _classPrivateFieldGet2;

            return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _metadataMap).get(name)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;
          }

          getAll() {
            return (0, _util.objectFromMap)(_classPrivateFieldGet(this, _metadataMap));
          }

          has(name) {
            return _classPrivateFieldGet(this, _metadataMap).has(name);
          }

        }

        exports.Metadata = Metadata;
        /***/
      },
      /* 16 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.OptionalContentConfig = void 0;

        var _util = __w_pdfjs_require__(1);

        class OptionalContentGroup {
          constructor(name, intent) {
            this.visible = true;
            this.name = name;
            this.intent = intent;
          }

        }

        class OptionalContentConfig {
          constructor(data) {
            this.name = null;
            this.creator = null;
            this._order = null;
            this._groups = new Map();

            if (data === null) {
              return;
            }

            this.name = data.name;
            this.creator = data.creator;
            this._order = data.order;

            for (var group of data.groups) {
              this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));
            }

            if (data.baseState === "OFF") {
              for (var _group2 of this._groups) {
                _group2.visible = false;
              }
            }

            for (var on of data.on) {
              this._groups.get(on).visible = true;
            }

            for (var off of data.off) {
              this._groups.get(off).visible = false;
            }
          }

          _evaluateVisibilityExpression(array) {
            var length = array.length;

            if (length < 2) {
              return true;
            }

            var operator = array[0];

            for (var i = 1; i < length; i++) {
              var element = array[i];
              var state = void 0;

              if (Array.isArray(element)) {
                state = this._evaluateVisibilityExpression(element);
              } else if (this._groups.has(element)) {
                state = this._groups.get(element).visible;
              } else {
                (0, _util.warn)("Optional content group not found: ".concat(element));
                return true;
              }

              switch (operator) {
                case "And":
                  if (!state) {
                    return false;
                  }

                  break;

                case "Or":
                  if (state) {
                    return true;
                  }

                  break;

                case "Not":
                  return !state;

                default:
                  return true;
              }
            }

            return operator === "And";
          }

          isVisible(group) {
            if (this._groups.size === 0) {
              return true;
            }

            if (!group) {
              (0, _util.warn)("Optional content group not defined.");
              return true;
            }

            if (group.type === "OCG") {
              if (!this._groups.has(group.id)) {
                (0, _util.warn)("Optional content group not found: ".concat(group.id));
                return true;
              }

              return this._groups.get(group.id).visible;
            } else if (group.type === "OCMD") {
              if (group.expression) {
                return this._evaluateVisibilityExpression(group.expression);
              }

              if (!group.policy || group.policy === "AnyOn") {
                for (var id of group.ids) {
                  if (!this._groups.has(id)) {
                    (0, _util.warn)("Optional content group not found: ".concat(id));
                    return true;
                  }

                  if (this._groups.get(id).visible) {
                    return true;
                  }
                }

                return false;
              } else if (group.policy === "AllOn") {
                for (var _id2 of group.ids) {
                  if (!this._groups.has(_id2)) {
                    (0, _util.warn)("Optional content group not found: ".concat(_id2));
                    return true;
                  }

                  if (!this._groups.get(_id2).visible) {
                    return false;
                  }
                }

                return true;
              } else if (group.policy === "AnyOff") {
                for (var _id4 of group.ids) {
                  if (!this._groups.has(_id4)) {
                    (0, _util.warn)("Optional content group not found: ".concat(_id4));
                    return true;
                  }

                  if (!this._groups.get(_id4).visible) {
                    return true;
                  }
                }

                return false;
              } else if (group.policy === "AllOff") {
                for (var _id6 of group.ids) {
                  if (!this._groups.has(_id6)) {
                    (0, _util.warn)("Optional content group not found: ".concat(_id6));
                    return true;
                  }

                  if (this._groups.get(_id6).visible) {
                    return false;
                  }
                }

                return true;
              }

              (0, _util.warn)("Unknown optional content policy ".concat(group.policy, "."));
              return true;
            }

            (0, _util.warn)("Unknown group type ".concat(group.type, "."));
            return true;
          }

          setVisibility(id) {
            var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            if (!this._groups.has(id)) {
              (0, _util.warn)("Optional content group not found: ".concat(id));
              return;
            }

            this._groups.get(id).visible = !!visible;
          }

          getOrder() {
            if (!this._groups.size) {
              return null;
            }

            if (this._order) {
              return this._order.slice();
            }

            return Array.from(this._groups.keys());
          }

          getGroups() {
            return this._groups.size > 0 ? (0, _util.objectFromMap)(this._groups) : null;
          }

          getGroup(id) {
            return this._groups.get(id) || null;
          }

        }

        exports.OptionalContentConfig = OptionalContentConfig;
        /***/
      },
      /* 17 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFDataTransportStream = void 0;

        var _util = __w_pdfjs_require__(1);

        var _display_utils = __w_pdfjs_require__(5);

        class PDFDataTransportStream {
          constructor(params, pdfDataRangeTransport) {
            (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
            this._queuedChunks = [];
            this._progressiveDone = params.progressiveDone || false;
            this._contentDispositionFilename = params.contentDispositionFilename || null;
            var initialData = params.initialData;

            if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {
              var buffer = new Uint8Array(initialData).buffer;

              this._queuedChunks.push(buffer);
            }

            this._pdfDataRangeTransport = pdfDataRangeTransport;
            this._isStreamingSupported = !params.disableStream;
            this._isRangeSupported = !params.disableRange;
            this._contentLength = params.length;
            this._fullRequestReader = null;
            this._rangeReaders = [];

            this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
              this._onReceiveData({
                begin,
                chunk
              });
            });

            this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
              this._onProgress({
                loaded,
                total
              });
            });

            this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {
              this._onReceiveData({
                chunk
              });
            });

            this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
              this._onProgressiveDone();
            });

            this._pdfDataRangeTransport.transportReady();
          }

          _onReceiveData(args) {
            var buffer = new Uint8Array(args.chunk).buffer;

            if (args.begin === undefined) {
              if (this._fullRequestReader) {
                this._fullRequestReader._enqueue(buffer);
              } else {
                this._queuedChunks.push(buffer);
              }
            } else {
              var found = this._rangeReaders.some(function (rangeReader) {
                if (rangeReader._begin !== args.begin) {
                  return false;
                }

                rangeReader._enqueue(buffer);

                return true;
              });

              (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
            }
          }

          get _progressiveDataLength() {
            var _this$_fullRequestRea, _this$_fullRequestRea2;

            return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
          }

          _onProgress(evt) {
            if (evt.total === undefined) {
              var firstReader = this._rangeReaders[0];

              if (firstReader !== null && firstReader !== void 0 && firstReader.onProgress) {
                firstReader.onProgress({
                  loaded: evt.loaded
                });
              }
            } else {
              var fullReader = this._fullRequestReader;

              if (fullReader !== null && fullReader !== void 0 && fullReader.onProgress) {
                fullReader.onProgress({
                  loaded: evt.loaded,
                  total: evt.total
                });
              }
            }
          }

          _onProgressiveDone() {
            if (this._fullRequestReader) {
              this._fullRequestReader.progressiveDone();
            }

            this._progressiveDone = true;
          }

          _removeRangeReader(reader) {
            var i = this._rangeReaders.indexOf(reader);

            if (i >= 0) {
              this._rangeReaders.splice(i, 1);
            }
          }

          getFullReader() {
            (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
            var queuedChunks = this._queuedChunks;
            this._queuedChunks = null;
            return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
          }

          getRangeReader(begin, end) {
            if (end <= this._progressiveDataLength) {
              return null;
            }

            var reader = new PDFDataTransportStreamRangeReader(this, begin, end);

            this._pdfDataRangeTransport.requestDataRange(begin, end);

            this._rangeReaders.push(reader);

            return reader;
          }

          cancelAllRequests(reason) {
            if (this._fullRequestReader) {
              this._fullRequestReader.cancel(reason);
            }

            for (var reader of this._rangeReaders.slice(0)) {
              reader.cancel(reason);
            }

            this._pdfDataRangeTransport.abort();
          }

        }

        exports.PDFDataTransportStream = PDFDataTransportStream;

        class PDFDataTransportStreamReader {
          constructor(stream, queuedChunks) {
            var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
            this._stream = stream;
            this._done = progressiveDone || false;
            this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
            this._queuedChunks = queuedChunks || [];
            this._loaded = 0;

            for (var chunk of this._queuedChunks) {
              this._loaded += chunk.byteLength;
            }

            this._requests = [];
            this._headersReady = Promise.resolve();
            stream._fullRequestReader = this;
            this.onProgress = null;
          }

          _enqueue(chunk) {
            if (this._done) {
              return;
            }

            if (this._requests.length > 0) {
              var requestCapability = this._requests.shift();

              requestCapability.resolve({
                value: chunk,
                done: false
              });
            } else {
              this._queuedChunks.push(chunk);
            }

            this._loaded += chunk.byteLength;
          }

          get headersReady() {
            return this._headersReady;
          }

          get filename() {
            return this._filename;
          }

          get isRangeSupported() {
            return this._stream._isRangeSupported;
          }

          get isStreamingSupported() {
            return this._stream._isStreamingSupported;
          }

          get contentLength() {
            return this._stream._contentLength;
          }

          read() {
            var _this11 = this;

            return _asyncToGenerator(function* () {
              if (_this11._queuedChunks.length > 0) {
                var chunk = _this11._queuedChunks.shift();

                return {
                  value: chunk,
                  done: false
                };
              }

              if (_this11._done) {
                return {
                  value: undefined,
                  done: true
                };
              }

              var requestCapability = (0, _util.createPromiseCapability)();

              _this11._requests.push(requestCapability);

              return requestCapability.promise;
            })();
          }

          cancel(reason) {
            this._done = true;

            for (var requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }

            this._requests.length = 0;
          }

          progressiveDone() {
            if (this._done) {
              return;
            }

            this._done = true;
          }

        }

        class PDFDataTransportStreamRangeReader {
          constructor(stream, begin, end) {
            this._stream = stream;
            this._begin = begin;
            this._end = end;
            this._queuedChunk = null;
            this._requests = [];
            this._done = false;
            this.onProgress = null;
          }

          _enqueue(chunk) {
            if (this._done) {
              return;
            }

            if (this._requests.length === 0) {
              this._queuedChunk = chunk;
            } else {
              var requestsCapability = this._requests.shift();

              requestsCapability.resolve({
                value: chunk,
                done: false
              });

              for (var requestCapability of this._requests) {
                requestCapability.resolve({
                  value: undefined,
                  done: true
                });
              }

              this._requests.length = 0;
            }

            this._done = true;

            this._stream._removeRangeReader(this);
          }

          get isStreamingSupported() {
            return false;
          }

          read() {
            var _this12 = this;

            return _asyncToGenerator(function* () {
              if (_this12._queuedChunk) {
                var chunk = _this12._queuedChunk;
                _this12._queuedChunk = null;
                return {
                  value: chunk,
                  done: false
                };
              }

              if (_this12._done) {
                return {
                  value: undefined,
                  done: true
                };
              }

              var requestCapability = (0, _util.createPromiseCapability)();

              _this12._requests.push(requestCapability);

              return requestCapability.promise;
            })();
          }

          cancel(reason) {
            this._done = true;

            for (var requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }

            this._requests.length = 0;

            this._stream._removeRangeReader(this);
          }

        }
        /***/

      },
      /* 18 */

      /***/
      (__unused_webpack_module, exports) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.XfaText = void 0;

        class XfaText {
          static textContent(xfa) {
            var items = [];
            var output = {
              items,
              styles: Object.create(null)
            };

            function walk(node) {
              var _node$attributes;

              if (!node) {
                return;
              }

              var str = null;
              var name = node.name;

              if (name === "#text") {
                str = node.value;
              } else if (!XfaText.shouldBuildText(name)) {
                return;
              } else if (node !== null && node !== void 0 && (_node$attributes = node.attributes) !== null && _node$attributes !== void 0 && _node$attributes.textContent) {
                str = node.attributes.textContent;
              } else if (node.value) {
                str = node.value;
              }

              if (str !== null) {
                items.push({
                  str
                });
              }

              if (!node.children) {
                return;
              }

              for (var child of node.children) {
                walk(child);
              }
            }

            walk(xfa);
            return output;
          }

          static shouldBuildText(name) {
            return !(name === "textarea" || name === "input" || name === "option" || name === "select");
          }

        }

        exports.XfaText = XfaText;
        /***/
      },
      /* 19 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;

        var _base_factory = __w_pdfjs_require__(6);

        ;

        var fetchData = function fetchData(url) {
          return new Promise((resolve, reject) => {
            var fs = __webpack_require__(/*! fs */ "?47a5");

            fs.readFile(url, (error, data) => {
              if (error || !data) {
                reject(new Error(error));
                return;
              }

              resolve(new Uint8Array(data));
            });
          });
        };

        class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
          _createCanvas(width, height) {
            var Canvas = __webpack_require__(/*! canvas */ "./node_modules/canvas/browser.js");

            return Canvas.createCanvas(width, height);
          }

        }

        exports.NodeCanvasFactory = NodeCanvasFactory;

        class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
          _fetchData(url, compressionType) {
            return fetchData(url).then(data => {
              return {
                cMapData: data,
                compressionType
              };
            });
          }

        }

        exports.NodeCMapReaderFactory = NodeCMapReaderFactory;

        class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
          _fetchData(url) {
            return fetchData(url);
          }

        }

        exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;
        /***/
      },
      /* 20 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.AnnotationLayer = void 0;

        var _util = __w_pdfjs_require__(1);

        var _display_utils = __w_pdfjs_require__(5);

        var _annotation_storage = __w_pdfjs_require__(8);

        var _scripting_utils = __w_pdfjs_require__(21);

        var _xfa_layer = __w_pdfjs_require__(22);

        var DEFAULT_TAB_INDEX = 1000;
        var GetElementsByNameSet = new WeakSet();

        function getRectDims(rect) {
          return {
            width: rect[2] - rect[0],
            height: rect[3] - rect[1]
          };
        }

        class AnnotationElementFactory {
          static create(parameters) {
            var subtype = parameters.data.annotationType;

            switch (subtype) {
              case _util.AnnotationType.LINK:
                return new LinkAnnotationElement(parameters);

              case _util.AnnotationType.TEXT:
                return new TextAnnotationElement(parameters);

              case _util.AnnotationType.WIDGET:
                var fieldType = parameters.data.fieldType;

                switch (fieldType) {
                  case "Tx":
                    return new TextWidgetAnnotationElement(parameters);

                  case "Btn":
                    if (parameters.data.radioButton) {
                      return new RadioButtonWidgetAnnotationElement(parameters);
                    } else if (parameters.data.checkBox) {
                      return new CheckboxWidgetAnnotationElement(parameters);
                    }

                    return new PushButtonWidgetAnnotationElement(parameters);

                  case "Ch":
                    return new ChoiceWidgetAnnotationElement(parameters);
                }

                return new WidgetAnnotationElement(parameters);

              case _util.AnnotationType.POPUP:
                return new PopupAnnotationElement(parameters);

              case _util.AnnotationType.FREETEXT:
                return new FreeTextAnnotationElement(parameters);

              case _util.AnnotationType.LINE:
                return new LineAnnotationElement(parameters);

              case _util.AnnotationType.SQUARE:
                return new SquareAnnotationElement(parameters);

              case _util.AnnotationType.CIRCLE:
                return new CircleAnnotationElement(parameters);

              case _util.AnnotationType.POLYLINE:
                return new PolylineAnnotationElement(parameters);

              case _util.AnnotationType.CARET:
                return new CaretAnnotationElement(parameters);

              case _util.AnnotationType.INK:
                return new InkAnnotationElement(parameters);

              case _util.AnnotationType.POLYGON:
                return new PolygonAnnotationElement(parameters);

              case _util.AnnotationType.HIGHLIGHT:
                return new HighlightAnnotationElement(parameters);

              case _util.AnnotationType.UNDERLINE:
                return new UnderlineAnnotationElement(parameters);

              case _util.AnnotationType.SQUIGGLY:
                return new SquigglyAnnotationElement(parameters);

              case _util.AnnotationType.STRIKEOUT:
                return new StrikeOutAnnotationElement(parameters);

              case _util.AnnotationType.STAMP:
                return new StampAnnotationElement(parameters);

              case _util.AnnotationType.FILEATTACHMENT:
                return new FileAttachmentAnnotationElement(parameters);

              default:
                return new AnnotationElement(parameters);
            }
          }

        }

        class AnnotationElement {
          constructor(parameters) {
            var {
              isRenderable = false,
              ignoreBorder = false,
              createQuadrilaterals = false
            } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            this.isRenderable = isRenderable;
            this.data = parameters.data;
            this.layer = parameters.layer;
            this.page = parameters.page;
            this.viewport = parameters.viewport;
            this.linkService = parameters.linkService;
            this.downloadManager = parameters.downloadManager;
            this.imageResourcesPath = parameters.imageResourcesPath;
            this.renderForms = parameters.renderForms;
            this.svgFactory = parameters.svgFactory;
            this.annotationStorage = parameters.annotationStorage;
            this.enableScripting = parameters.enableScripting;
            this.hasJSActions = parameters.hasJSActions;
            this._fieldObjects = parameters.fieldObjects;
            this._mouseState = parameters.mouseState;

            if (isRenderable) {
              this.container = this._createContainer(ignoreBorder);
            }

            if (createQuadrilaterals) {
              this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
            }
          }

          _createContainer() {
            var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var data = this.data,
                page = this.page,
                viewport = this.viewport;
            var container = document.createElement("section");
            var {
              width,
              height
            } = getRectDims(data.rect);
            container.setAttribute("data-annotation-id", data.id);

            var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

            if (data.hasOwnCanvas) {
              var transform = viewport.transform.slice();

              var [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(transform);

              width = Math.ceil(width * scaleX);
              height = Math.ceil(height * scaleY);
              rect[0] *= scaleX;
              rect[1] *= scaleY;

              for (var i = 0; i < 4; i++) {
                transform[i] = Math.sign(transform[i]);
              }

              container.style.transform = "matrix(".concat(transform.join(","), ")");
            } else {
              container.style.transform = "matrix(".concat(viewport.transform.join(","), ")");
            }

            container.style.transformOrigin = "".concat(-rect[0], "px ").concat(-rect[1], "px");

            if (!ignoreBorder && data.borderStyle.width > 0) {
              container.style.borderWidth = "".concat(data.borderStyle.width, "px");

              if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
                width -= 2 * data.borderStyle.width;
                height -= 2 * data.borderStyle.width;
              }

              var horizontalRadius = data.borderStyle.horizontalCornerRadius;
              var verticalRadius = data.borderStyle.verticalCornerRadius;

              if (horizontalRadius > 0 || verticalRadius > 0) {
                var radius = "".concat(horizontalRadius, "px / ").concat(verticalRadius, "px");
                container.style.borderRadius = radius;
              }

              switch (data.borderStyle.style) {
                case _util.AnnotationBorderStyleType.SOLID:
                  container.style.borderStyle = "solid";
                  break;

                case _util.AnnotationBorderStyleType.DASHED:
                  container.style.borderStyle = "dashed";
                  break;

                case _util.AnnotationBorderStyleType.BEVELED:
                  (0, _util.warn)("Unimplemented border style: beveled");
                  break;

                case _util.AnnotationBorderStyleType.INSET:
                  (0, _util.warn)("Unimplemented border style: inset");
                  break;

                case _util.AnnotationBorderStyleType.UNDERLINE:
                  container.style.borderBottomStyle = "solid";
                  break;

                default:
                  break;
              }

              var borderColor = data.borderColor || data.color || null;

              if (borderColor) {
                container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
              } else {
                container.style.borderWidth = 0;
              }
            }

            container.style.left = "".concat(rect[0], "px");
            container.style.top = "".concat(rect[1], "px");

            if (data.hasOwnCanvas) {
              container.style.width = container.style.height = "auto";
            } else {
              container.style.width = "".concat(width, "px");
              container.style.height = "".concat(height, "px");
            }

            return container;
          }

          get _commonActions() {
            var setColor = (jsName, styleName, event) => {
              var color = event.detail[jsName];
              event.target.style[styleName] = _scripting_utils.ColorConverters["".concat(color[0], "_HTML")](color.slice(1));
            };

            return (0, _util.shadow)(this, "_commonActions", {
              display: event => {
                var hidden = event.detail.display % 2 === 1;
                event.target.style.visibility = hidden ? "hidden" : "visible";
                this.annotationStorage.setValue(this.data.id, {
                  hidden,
                  print: event.detail.display === 0 || event.detail.display === 3
                });
              },
              print: event => {
                this.annotationStorage.setValue(this.data.id, {
                  print: event.detail.print
                });
              },
              hidden: event => {
                event.target.style.visibility = event.detail.hidden ? "hidden" : "visible";
                this.annotationStorage.setValue(this.data.id, {
                  hidden: event.detail.hidden
                });
              },
              focus: event => {
                setTimeout(() => event.target.focus({
                  preventScroll: false
                }), 0);
              },
              userName: event => {
                event.target.title = event.detail.userName;
              },
              readonly: event => {
                if (event.detail.readonly) {
                  event.target.setAttribute("readonly", "");
                } else {
                  event.target.removeAttribute("readonly");
                }
              },
              required: event => {
                if (event.detail.required) {
                  event.target.setAttribute("required", "");
                } else {
                  event.target.removeAttribute("required");
                }
              },
              bgColor: event => {
                setColor("bgColor", "backgroundColor", event);
              },
              fillColor: event => {
                setColor("fillColor", "backgroundColor", event);
              },
              fgColor: event => {
                setColor("fgColor", "color", event);
              },
              textColor: event => {
                setColor("textColor", "color", event);
              },
              borderColor: event => {
                setColor("borderColor", "borderColor", event);
              },
              strokeColor: event => {
                setColor("strokeColor", "borderColor", event);
              }
            });
          }

          _dispatchEventFromSandbox(actions, jsEvent) {
            var commonActions = this._commonActions;

            for (var name of Object.keys(jsEvent.detail)) {
              var action = actions[name] || commonActions[name];

              if (action) {
                action(jsEvent);
              }
            }
          }

          _setDefaultPropertiesFromJS(element) {
            if (!this.enableScripting) {
              return;
            }

            var storedData = this.annotationStorage.getRawValue(this.data.id);

            if (!storedData) {
              return;
            }

            var commonActions = this._commonActions;

            for (var [actionName, detail] of Object.entries(storedData)) {
              var action = commonActions[actionName];

              if (action) {
                action({
                  detail,
                  target: element
                });
                delete storedData[actionName];
              }
            }
          }

          _createQuadrilaterals() {
            var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            if (!this.data.quadPoints) {
              return null;
            }

            var quadrilaterals = [];
            var savedRect = this.data.rect;

            for (var quadPoint of this.data.quadPoints) {
              this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
              quadrilaterals.push(this._createContainer(ignoreBorder));
            }

            this.data.rect = savedRect;
            return quadrilaterals;
          }

          _createPopup(trigger, data) {
            var container = this.container;

            if (this.quadrilaterals) {
              trigger = trigger || this.quadrilaterals;
              container = this.quadrilaterals[0];
            }

            if (!trigger) {
              trigger = document.createElement("div");
              trigger.style.height = container.style.height;
              trigger.style.width = container.style.width;
              container.appendChild(trigger);
            }

            var popupElement = new PopupElement({
              container,
              trigger,
              color: data.color,
              titleObj: data.titleObj,
              modificationDate: data.modificationDate,
              contentsObj: data.contentsObj,
              richText: data.richText,
              hideWrapper: true
            });
            var popup = popupElement.render();
            popup.style.left = container.style.width;
            container.appendChild(popup);
          }

          _renderQuadrilaterals(className) {
            for (var quadrilateral of this.quadrilaterals) {
              quadrilateral.className = className;
            }

            return this.quadrilaterals;
          }

          render() {
            (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
          }

          _getElementsByName(name) {
            var skipId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var fields = [];

            if (this._fieldObjects) {
              var fieldObj = this._fieldObjects[name];

              if (fieldObj) {
                for (var {
                  page,
                  id,
                  exportValues
                } of fieldObj) {
                  if (page === -1) {
                    continue;
                  }

                  if (id === skipId) {
                    continue;
                  }

                  var exportValue = typeof exportValues === "string" ? exportValues : null;
                  var domElement = document.getElementById(id);

                  if (domElement && !GetElementsByNameSet.has(domElement)) {
                    (0, _util.warn)("_getElementsByName - element not allowed: ".concat(id));
                    continue;
                  }

                  fields.push({
                    id,
                    exportValue,
                    domElement
                  });
                }
              }

              return fields;
            }

            for (var _domElement2 of document.getElementsByName(name)) {
              var {
                id: _id7,
                exportValue: _exportValue
              } = _domElement2;

              if (_id7 === skipId) {
                continue;
              }

              if (!GetElementsByNameSet.has(_domElement2)) {
                continue;
              }

              fields.push({
                id: _id7,
                exportValue: _exportValue,
                domElement: _domElement2
              });
            }

            return fields;
          }

          static get platform() {
            var platform = typeof navigator !== "undefined" ? navigator.platform : "";
            return (0, _util.shadow)(this, "platform", {
              isWin: platform.includes("Win"),
              isMac: platform.includes("Mac")
            });
          }

        }

        class LinkAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.resetForm || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
            super(parameters, {
              isRenderable,
              ignoreBorder: !!(options !== null && options !== void 0 && options.ignoreBorder),
              createQuadrilaterals: true
            });
          }

          render() {
            var {
              data,
              linkService
            } = this;
            var link = document.createElement("a");

            if (data.url) {
              linkService.addLinkAttributes(link, data.url, data.newWindow);
            } else if (data.action) {
              this._bindNamedAction(link, data.action);
            } else if (data.dest) {
              this._bindLink(link, data.dest);
            } else {
              var hasClickAction = false;

              if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                hasClickAction = true;

                this._bindJSAction(link, data);
              }

              if (data.resetForm) {
                this._bindResetFormAction(link, data.resetForm);
              } else if (!hasClickAction) {
                this._bindLink(link, "");
              }
            }

            if (this.quadrilaterals) {
              return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
                var linkElement = index === 0 ? link : link.cloneNode();
                quadrilateral.appendChild(linkElement);
                return quadrilateral;
              });
            }

            this.container.className = "linkAnnotation";
            this.container.appendChild(link);
            return this.container;
          }

          _bindLink(link, destination) {
            link.href = this.linkService.getDestinationHash(destination);

            link.onclick = () => {
              if (destination) {
                this.linkService.goToDestination(destination);
              }

              return false;
            };

            if (destination || destination === "") {
              link.className = "internalLink";
            }
          }

          _bindNamedAction(link, action) {
            link.href = this.linkService.getAnchorUrl("");

            link.onclick = () => {
              this.linkService.executeNamedAction(action);
              return false;
            };

            link.className = "internalLink";
          }

          _bindJSAction(link, data) {
            var _this13 = this;

            link.href = this.linkService.getAnchorUrl("");
            var map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);

            var _loop2 = function _loop2(name) {
              var jsName = map.get(name);

              if (!jsName) {
                return "continue";
              }

              link[jsName] = () => {
                var _this13$linkService$e;

                (_this13$linkService$e = _this13.linkService.eventBus) === null || _this13$linkService$e === void 0 ? void 0 : _this13$linkService$e.dispatch("dispatcheventinsandbox", {
                  source: _this13,
                  detail: {
                    id: data.id,
                    name
                  }
                });
                return false;
              };
            };

            for (var name of Object.keys(data.actions)) {
              var _ret = _loop2(name);

              if (_ret === "continue") continue;
            }

            if (!link.onclick) {
              link.onclick = () => false;
            }

            link.className = "internalLink";
          }

          _bindResetFormAction(link, resetForm) {
            var otherClickAction = link.onclick;

            if (!otherClickAction) {
              link.href = this.linkService.getAnchorUrl("");
            }

            link.className = "internalLink";

            if (!this._fieldObjects) {
              (0, _util.warn)("_bindResetFormAction - \"resetForm\" action not supported, " + "ensure that the `fieldObjects` parameter is provided.");

              if (!otherClickAction) {
                link.onclick = () => false;
              }

              return;
            }

            link.onclick = () => {
              if (otherClickAction) {
                otherClickAction();
              }

              var {
                fields: resetFormFields,
                refs: resetFormRefs,
                include
              } = resetForm;
              var allFields = [];

              if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                var fieldIds = new Set(resetFormRefs);

                for (var fieldName of resetFormFields) {
                  var fields = this._fieldObjects[fieldName] || [];

                  for (var {
                    id
                  } of fields) {
                    fieldIds.add(id);
                  }
                }

                for (var _fields2 of Object.values(this._fieldObjects)) {
                  for (var field of _fields2) {
                    if (fieldIds.has(field.id) === include) {
                      allFields.push(field);
                    }
                  }
                }
              } else {
                for (var _fields4 of Object.values(this._fieldObjects)) {
                  allFields.push(..._fields4);
                }
              }

              var storage = this.annotationStorage;
              var allIds = [];

              for (var _field2 of allFields) {
                var {
                  id: _id8
                } = _field2;
                allIds.push(_id8);

                switch (_field2.type) {
                  case "text":
                    {
                      var value = _field2.defaultValue || "";
                      storage.setValue(_id8, {
                        value
                      });
                      break;
                    }

                  case "checkbox":
                  case "radiobutton":
                    {
                      var _value2 = _field2.defaultValue === _field2.exportValues;

                      storage.setValue(_id8, {
                        value: _value2
                      });
                      break;
                    }

                  case "combobox":
                  case "listbox":
                    {
                      var _value3 = _field2.defaultValue || "";

                      storage.setValue(_id8, {
                        value: _value3
                      });
                      break;
                    }

                  default:
                    continue;
                }

                var domElement = document.getElementById(_id8);

                if (!domElement || !GetElementsByNameSet.has(domElement)) {
                  continue;
                }

                domElement.dispatchEvent(new Event("resetform"));
              }

              if (this.enableScripting) {
                var _this$linkService$eve;

                (_this$linkService$eve = this.linkService.eventBus) === null || _this$linkService$eve === void 0 ? void 0 : _this$linkService$eve.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: "app",
                    ids: allIds,
                    name: "ResetForm"
                  }
                });
              }

              return false;
            };
          }

        }

        class TextAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl, _parameters$data$cont, _parameters$data$rich;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl = parameters.data.titleObj) !== null && _parameters$data$titl !== void 0 && _parameters$data$titl.str || (_parameters$data$cont = parameters.data.contentsObj) !== null && _parameters$data$cont !== void 0 && _parameters$data$cont.str || (_parameters$data$rich = parameters.data.richText) !== null && _parameters$data$rich !== void 0 && _parameters$data$rich.str);
            super(parameters, {
              isRenderable
            });
          }

          render() {
            this.container.className = "textAnnotation";
            var image = document.createElement("img");
            image.style.height = this.container.style.height;
            image.style.width = this.container.style.width;
            image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
            image.alt = "[{{type}} Annotation]";
            image.dataset.l10nId = "text_annotation_type";
            image.dataset.l10nArgs = JSON.stringify({
              type: this.data.name
            });

            if (!this.data.hasPopup) {
              this._createPopup(image, this.data);
            }

            this.container.appendChild(image);
            return this.container;
          }

        }

        class WidgetAnnotationElement extends AnnotationElement {
          render() {
            if (this.data.alternativeText) {
              this.container.title = this.data.alternativeText;
            }

            return this.container;
          }

          _getKeyModifier(event) {
            var {
              isWin,
              isMac
            } = AnnotationElement.platform;
            return isWin && event.ctrlKey || isMac && event.metaKey;
          }

          _setEventListener(element, baseName, eventName, valueGetter) {
            if (baseName.includes("mouse")) {
              element.addEventListener(baseName, event => {
                var _this$linkService$eve2;

                (_this$linkService$eve2 = this.linkService.eventBus) === null || _this$linkService$eve2 === void 0 ? void 0 : _this$linkService$eve2.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: eventName,
                    value: valueGetter(event),
                    shift: event.shiftKey,
                    modifier: this._getKeyModifier(event)
                  }
                });
              });
            } else {
              element.addEventListener(baseName, event => {
                var _this$linkService$eve3;

                (_this$linkService$eve3 = this.linkService.eventBus) === null || _this$linkService$eve3 === void 0 ? void 0 : _this$linkService$eve3.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: eventName,
                    value: valueGetter(event)
                  }
                });
              });
            }
          }

          _setEventListeners(element, names, getter) {
            for (var [baseName, eventName] of names) {
              var _this$data$actions;

              if (eventName === "Action" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {
                this._setEventListener(element, baseName, eventName, getter);
              }
            }
          }

          _setBackgroundColor(element) {
            var color = this.data.backgroundColor || null;
            element.style.backgroundColor = color === null ? "transparent" : _util.Util.makeHexColor(color[0], color[1], color[2]);
          }

        }

        class TextWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(parameters) {
            var isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
            super(parameters, {
              isRenderable
            });
          }

          setPropertyOnSiblings(base, key, value, keyInStorage) {
            var storage = this.annotationStorage;

            for (var element of this._getElementsByName(base.name, base.id)) {
              if (element.domElement) {
                element.domElement[key] = value;
              }

              storage.setValue(element.id, {
                [keyInStorage]: value
              });
            }
          }

          render() {
            var storage = this.annotationStorage;
            var id = this.data.id;
            this.container.className = "textWidgetAnnotation";
            var element = null;

            if (this.renderForms) {
              var storedData = storage.getValue(id, {
                value: this.data.fieldValue
              });
              var textContent = storedData.formattedValue || storedData.value || "";
              var elementData = {
                userValue: null,
                formattedValue: null,
                valueOnFocus: ""
              };

              if (this.data.multiLine) {
                element = document.createElement("textarea");
                element.textContent = textContent;
              } else {
                element = document.createElement("input");
                element.type = "text";
                element.setAttribute("value", textContent);
              }

              GetElementsByNameSet.add(element);
              element.disabled = this.data.readOnly;
              element.name = this.data.fieldName;
              element.tabIndex = DEFAULT_TAB_INDEX;
              elementData.userValue = textContent;
              element.setAttribute("id", id);
              element.addEventListener("input", event => {
                storage.setValue(id, {
                  value: event.target.value
                });
                this.setPropertyOnSiblings(element, "value", event.target.value, "value");
              });
              element.addEventListener("resetform", event => {
                var _this$data$defaultFie;

                var defaultValue = (_this$data$defaultFie = this.data.defaultFieldValue) !== null && _this$data$defaultFie !== void 0 ? _this$data$defaultFie : "";
                element.value = elementData.userValue = defaultValue;
                elementData.formattedValue = null;
              });

              var blurListener = event => {
                var {
                  formattedValue
                } = elementData;

                if (formattedValue !== null && formattedValue !== undefined) {
                  event.target.value = formattedValue;
                }

                event.target.scrollLeft = 0;
              };

              if (this.enableScripting && this.hasJSActions) {
                var _this$data$actions2;

                element.addEventListener("focus", event => {
                  if (elementData.userValue) {
                    event.target.value = elementData.userValue;
                  }

                  elementData.valueOnFocus = event.target.value;
                });
                element.addEventListener("updatefromsandbox", jsEvent => {
                  var actions = {
                    value(event) {
                      var _event$detail$value;

                      elementData.userValue = (_event$detail$value = event.detail.value) !== null && _event$detail$value !== void 0 ? _event$detail$value : "";
                      storage.setValue(id, {
                        value: elementData.userValue.toString()
                      });
                      event.target.value = elementData.userValue;
                    },

                    formattedValue(event) {
                      var {
                        formattedValue
                      } = event.detail;
                      elementData.formattedValue = formattedValue;

                      if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {
                        event.target.value = formattedValue;
                      }

                      storage.setValue(id, {
                        formattedValue
                      });
                    },

                    selRange(event) {
                      event.target.setSelectionRange(...event.detail.selRange);
                    }

                  };

                  this._dispatchEventFromSandbox(actions, jsEvent);
                });
                element.addEventListener("keydown", event => {
                  var _this$linkService$eve4;

                  var commitKey = -1;

                  if (event.key === "Escape") {
                    commitKey = 0;
                  } else if (event.key === "Enter") {
                    commitKey = 2;
                  } else if (event.key === "Tab") {
                    commitKey = 3;
                  }

                  if (commitKey === -1) {
                    return;
                  }

                  var {
                    value
                  } = event.target;

                  if (elementData.valueOnFocus === value) {
                    return;
                  }

                  elementData.userValue = value;
                  (_this$linkService$eve4 = this.linkService.eventBus) === null || _this$linkService$eve4 === void 0 ? void 0 : _this$linkService$eve4.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id,
                      name: "Keystroke",
                      value,
                      willCommit: true,
                      commitKey,
                      selStart: event.target.selectionStart,
                      selEnd: event.target.selectionEnd
                    }
                  });
                });
                var _blurListener = blurListener;
                blurListener = null;
                element.addEventListener("blur", event => {
                  var {
                    value
                  } = event.target;
                  elementData.userValue = value;

                  if (this._mouseState.isDown && elementData.valueOnFocus !== value) {
                    var _this$linkService$eve5;

                    (_this$linkService$eve5 = this.linkService.eventBus) === null || _this$linkService$eve5 === void 0 ? void 0 : _this$linkService$eve5.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id,
                        name: "Keystroke",
                        value,
                        willCommit: true,
                        commitKey: 1,
                        selStart: event.target.selectionStart,
                        selEnd: event.target.selectionEnd
                      }
                    });
                  }

                  _blurListener(event);
                });

                if ((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Keystroke) {
                  element.addEventListener("beforeinput", event => {
                    var _this$linkService$eve6;

                    var {
                      data,
                      target
                    } = event;
                    var {
                      value,
                      selectionStart,
                      selectionEnd
                    } = target;
                    var selStart = selectionStart,
                        selEnd = selectionEnd;

                    switch (event.inputType) {
                      case "deleteWordBackward":
                        {
                          var match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);

                          if (match) {
                            selStart -= match[0].length;
                          }

                          break;
                        }

                      case "deleteWordForward":
                        {
                          var _match = value.substring(selectionStart).match(/^[^\w]*\w*/);

                          if (_match) {
                            selEnd += _match[0].length;
                          }

                          break;
                        }

                      case "deleteContentBackward":
                        if (selectionStart === selectionEnd) {
                          selStart -= 1;
                        }

                        break;

                      case "deleteContentForward":
                        if (selectionStart === selectionEnd) {
                          selEnd += 1;
                        }

                        break;
                    }

                    event.preventDefault();
                    (_this$linkService$eve6 = this.linkService.eventBus) === null || _this$linkService$eve6 === void 0 ? void 0 : _this$linkService$eve6.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id,
                        name: "Keystroke",
                        value,
                        change: data || "",
                        willCommit: false,
                        selStart,
                        selEnd
                      }
                    });
                  });
                }

                this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
              }

              if (blurListener) {
                element.addEventListener("blur", blurListener);
              }

              if (this.data.maxLen !== null) {
                element.maxLength = this.data.maxLen;
              }

              if (this.data.comb) {
                var fieldWidth = this.data.rect[2] - this.data.rect[0];
                var combWidth = fieldWidth / this.data.maxLen;
                element.classList.add("comb");
                element.style.letterSpacing = "calc(".concat(combWidth, "px - 1ch)");
              }
            } else {
              element = document.createElement("div");
              element.textContent = this.data.fieldValue;
              element.style.verticalAlign = "middle";
              element.style.display = "table-cell";
            }

            this._setTextStyle(element);

            this._setBackgroundColor(element);

            this._setDefaultPropertiesFromJS(element);

            this.container.appendChild(element);
            return this.container;
          }

          _setTextStyle(element) {
            var TEXT_ALIGNMENT = ["left", "center", "right"];
            var {
              fontSize,
              fontColor
            } = this.data.defaultAppearanceData;
            var style = element.style;

            if (fontSize) {
              style.fontSize = "".concat(fontSize, "px");
            }

            style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);

            if (this.data.textAlignment !== null) {
              style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
            }
          }

        }

        class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: parameters.renderForms
            });
          }

          render() {
            var storage = this.annotationStorage;
            var data = this.data;
            var id = data.id;
            var value = storage.getValue(id, {
              value: data.exportValue === data.fieldValue
            }).value;

            if (typeof value === "string") {
              value = value !== "Off";
              storage.setValue(id, {
                value
              });
            }

            this.container.className = "buttonWidgetAnnotation checkBox";
            var element = document.createElement("input");
            GetElementsByNameSet.add(element);
            element.disabled = data.readOnly;
            element.type = "checkbox";
            element.name = data.fieldName;

            if (value) {
              element.setAttribute("checked", true);
            }

            element.setAttribute("id", id);
            element.setAttribute("exportValue", data.exportValue);
            element.tabIndex = DEFAULT_TAB_INDEX;
            element.addEventListener("change", event => {
              var {
                name,
                checked
              } = event.target;

              for (var checkbox of this._getElementsByName(name, id)) {
                var curChecked = checked && checkbox.exportValue === data.exportValue;

                if (checkbox.domElement) {
                  checkbox.domElement.checked = curChecked;
                }

                storage.setValue(checkbox.id, {
                  value: curChecked
                });
              }

              storage.setValue(id, {
                value: checked
              });
            });
            element.addEventListener("resetform", event => {
              var defaultValue = data.defaultFieldValue || "Off";
              event.target.checked = defaultValue === data.exportValue;
            });

            if (this.enableScripting && this.hasJSActions) {
              element.addEventListener("updatefromsandbox", jsEvent => {
                var actions = {
                  value(event) {
                    event.target.checked = event.detail.value !== "Off";
                    storage.setValue(id, {
                      value: event.target.checked
                    });
                  }

                };

                this._dispatchEventFromSandbox(actions, jsEvent);
              });

              this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
            }

            this._setBackgroundColor(element);

            this._setDefaultPropertiesFromJS(element);

            this.container.appendChild(element);
            return this.container;
          }

        }

        class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: parameters.renderForms
            });
          }

          render() {
            this.container.className = "buttonWidgetAnnotation radioButton";
            var storage = this.annotationStorage;
            var data = this.data;
            var id = data.id;
            var value = storage.getValue(id, {
              value: data.fieldValue === data.buttonValue
            }).value;

            if (typeof value === "string") {
              value = value !== data.buttonValue;
              storage.setValue(id, {
                value
              });
            }

            var element = document.createElement("input");
            GetElementsByNameSet.add(element);
            element.disabled = data.readOnly;
            element.type = "radio";
            element.name = data.fieldName;

            if (value) {
              element.setAttribute("checked", true);
            }

            element.setAttribute("id", id);
            element.tabIndex = DEFAULT_TAB_INDEX;
            element.addEventListener("change", event => {
              var {
                name,
                checked
              } = event.target;

              for (var radio of this._getElementsByName(name, id)) {
                storage.setValue(radio.id, {
                  value: false
                });
              }

              storage.setValue(id, {
                value: checked
              });
            });
            element.addEventListener("resetform", event => {
              var defaultValue = data.defaultFieldValue;
              event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
            });

            if (this.enableScripting && this.hasJSActions) {
              var pdfButtonValue = data.buttonValue;
              element.addEventListener("updatefromsandbox", jsEvent => {
                var actions = {
                  value: event => {
                    var checked = pdfButtonValue === event.detail.value;

                    for (var radio of this._getElementsByName(event.target.name)) {
                      var curChecked = checked && radio.id === id;

                      if (radio.domElement) {
                        radio.domElement.checked = curChecked;
                      }

                      storage.setValue(radio.id, {
                        value: curChecked
                      });
                    }
                  }
                };

                this._dispatchEventFromSandbox(actions, jsEvent);
              });

              this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
            }

            this._setBackgroundColor(element);

            this._setDefaultPropertiesFromJS(element);

            this.container.appendChild(element);
            return this.container;
          }

        }

        class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
          constructor(parameters) {
            super(parameters, {
              ignoreBorder: parameters.data.hasAppearance
            });
          }

          render() {
            var container = super.render();
            container.className = "buttonWidgetAnnotation pushButton";

            if (this.data.alternativeText) {
              container.title = this.data.alternativeText;
            }

            this._setDefaultPropertiesFromJS(container);

            return container;
          }

        }

        class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: parameters.renderForms
            });
          }

          render() {
            this.container.className = "choiceWidgetAnnotation";
            var storage = this.annotationStorage;
            var id = this.data.id;
            var storedData = storage.getValue(id, {
              value: this.data.fieldValue
            });
            var {
              fontSize
            } = this.data.defaultAppearanceData;

            if (!fontSize) {
              fontSize = 9;
            }

            var fontSizeStyle = "calc(".concat(fontSize, "px * var(--zoom-factor))");
            var selectElement = document.createElement("select");
            GetElementsByNameSet.add(selectElement);
            selectElement.disabled = this.data.readOnly;
            selectElement.name = this.data.fieldName;
            selectElement.setAttribute("id", id);
            selectElement.tabIndex = DEFAULT_TAB_INDEX;
            selectElement.style.fontSize = "".concat(fontSize, "px");

            if (!this.data.combo) {
              selectElement.size = this.data.options.length;

              if (this.data.multiSelect) {
                selectElement.multiple = true;
              }
            }

            selectElement.addEventListener("resetform", event => {
              var defaultValue = this.data.defaultFieldValue;

              for (var option of selectElement.options) {
                option.selected = option.value === defaultValue;
              }
            });

            for (var option of this.data.options) {
              var optionElement = document.createElement("option");
              optionElement.textContent = option.displayValue;
              optionElement.value = option.exportValue;

              if (this.data.combo) {
                optionElement.style.fontSize = fontSizeStyle;
              }

              if (storedData.value.includes(option.exportValue)) {
                optionElement.setAttribute("selected", true);
              }

              selectElement.appendChild(optionElement);
            }

            var getValue = (event, isExport) => {
              var name = isExport ? "value" : "textContent";
              var options = event.target.options;

              if (!event.target.multiple) {
                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
              }

              return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);
            };

            var getItems = event => {
              var options = event.target.options;
              return Array.prototype.map.call(options, option => {
                return {
                  displayValue: option.textContent,
                  exportValue: option.value
                };
              });
            };

            if (this.enableScripting && this.hasJSActions) {
              selectElement.addEventListener("updatefromsandbox", jsEvent => {
                var actions = {
                  value(event) {
                    var value = event.detail.value;
                    var values = new Set(Array.isArray(value) ? value : [value]);

                    for (var _option2 of selectElement.options) {
                      _option2.selected = values.has(_option2.value);
                    }

                    storage.setValue(id, {
                      value: getValue(event, true)
                    });
                  },

                  multipleSelection(event) {
                    selectElement.multiple = true;
                  },

                  remove(event) {
                    var options = selectElement.options;
                    var index = event.detail.remove;
                    options[index].selected = false;
                    selectElement.remove(index);

                    if (options.length > 0) {
                      var i = Array.prototype.findIndex.call(options, option => option.selected);

                      if (i === -1) {
                        options[0].selected = true;
                      }
                    }

                    storage.setValue(id, {
                      value: getValue(event, true),
                      items: getItems(event)
                    });
                  },

                  clear(event) {
                    while (selectElement.length !== 0) {
                      selectElement.remove(0);
                    }

                    storage.setValue(id, {
                      value: null,
                      items: []
                    });
                  },

                  insert(event) {
                    var {
                      index,
                      displayValue,
                      exportValue
                    } = event.detail.insert;
                    var optionElement = document.createElement("option");
                    optionElement.textContent = displayValue;
                    optionElement.value = exportValue;
                    selectElement.insertBefore(optionElement, selectElement.children[index]);
                    storage.setValue(id, {
                      value: getValue(event, true),
                      items: getItems(event)
                    });
                  },

                  items(event) {
                    var {
                      items
                    } = event.detail;

                    while (selectElement.length !== 0) {
                      selectElement.remove(0);
                    }

                    for (var item of items) {
                      var {
                        displayValue,
                        exportValue
                      } = item;

                      var _optionElement = document.createElement("option");

                      _optionElement.textContent = displayValue;
                      _optionElement.value = exportValue;
                      selectElement.appendChild(_optionElement);
                    }

                    if (selectElement.options.length > 0) {
                      selectElement.options[0].selected = true;
                    }

                    storage.setValue(id, {
                      value: getValue(event, true),
                      items: getItems(event)
                    });
                  },

                  indices(event) {
                    var indices = new Set(event.detail.indices);

                    for (var _option4 of event.target.options) {
                      _option4.selected = indices.has(_option4.index);
                    }

                    storage.setValue(id, {
                      value: getValue(event, true)
                    });
                  },

                  editable(event) {
                    event.target.disabled = !event.detail.editable;
                  }

                };

                this._dispatchEventFromSandbox(actions, jsEvent);
              });
              selectElement.addEventListener("input", event => {
                var _this$linkService$eve7;

                var exportValue = getValue(event, true);
                var value = getValue(event, false);
                storage.setValue(id, {
                  value: exportValue
                });
                (_this$linkService$eve7 = this.linkService.eventBus) === null || _this$linkService$eve7 === void 0 ? void 0 : _this$linkService$eve7.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id,
                    name: "Keystroke",
                    value,
                    changeEx: exportValue,
                    willCommit: true,
                    commitKey: 1,
                    keyDown: false
                  }
                });
              });

              this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], event => event.target.checked);
            } else {
              selectElement.addEventListener("input", function (event) {
                storage.setValue(id, {
                  value: getValue(event, true)
                });
              });
            }

            this._setBackgroundColor(selectElement);

            this._setDefaultPropertiesFromJS(selectElement);

            this.container.appendChild(selectElement);
            return this.container;
          }

        }

        class PopupAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl2, _parameters$data$cont2, _parameters$data$rich2;

            var isRenderable = !!((_parameters$data$titl2 = parameters.data.titleObj) !== null && _parameters$data$titl2 !== void 0 && _parameters$data$titl2.str || (_parameters$data$cont2 = parameters.data.contentsObj) !== null && _parameters$data$cont2 !== void 0 && _parameters$data$cont2.str || (_parameters$data$rich2 = parameters.data.richText) !== null && _parameters$data$rich2 !== void 0 && _parameters$data$rich2.str);
            super(parameters, {
              isRenderable
            });
          }

          render() {
            var IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
            this.container.className = "popupAnnotation";

            if (IGNORE_TYPES.includes(this.data.parentType)) {
              return this.container;
            }

            var selector = "[data-annotation-id=\"".concat(this.data.parentId, "\"]");
            var parentElements = this.layer.querySelectorAll(selector);

            if (parentElements.length === 0) {
              return this.container;
            }

            var popup = new PopupElement({
              container: this.container,
              trigger: Array.from(parentElements),
              color: this.data.color,
              titleObj: this.data.titleObj,
              modificationDate: this.data.modificationDate,
              contentsObj: this.data.contentsObj,
              richText: this.data.richText
            });
            var page = this.page;

            var rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);

            var popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
            var popupTop = rect[1];
            this.container.style.transformOrigin = "".concat(-popupLeft, "px ").concat(-popupTop, "px");
            this.container.style.left = "".concat(popupLeft, "px");
            this.container.style.top = "".concat(popupTop, "px");
            this.container.appendChild(popup.render());
            return this.container;
          }

        }

        class PopupElement {
          constructor(parameters) {
            this.container = parameters.container;
            this.trigger = parameters.trigger;
            this.color = parameters.color;
            this.titleObj = parameters.titleObj;
            this.modificationDate = parameters.modificationDate;
            this.contentsObj = parameters.contentsObj;
            this.richText = parameters.richText;
            this.hideWrapper = parameters.hideWrapper || false;
            this.pinned = false;
          }

          render() {
            var _this$richText, _this$contentsObj;

            var BACKGROUND_ENLIGHT = 0.7;
            var wrapper = document.createElement("div");
            wrapper.className = "popupWrapper";
            this.hideElement = this.hideWrapper ? wrapper : this.container;
            this.hideElement.hidden = true;
            var popup = document.createElement("div");
            popup.className = "popup";
            var color = this.color;

            if (color) {
              var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
              var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
              var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
              popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);
            }

            var title = document.createElement("h1");
            title.dir = this.titleObj.dir;
            title.textContent = this.titleObj.str;
            popup.appendChild(title);

            var dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);

            if (dateObject) {
              var modificationDate = document.createElement("span");
              modificationDate.className = "popupDate";
              modificationDate.textContent = "{{date}}, {{time}}";
              modificationDate.dataset.l10nId = "annotation_date_string";
              modificationDate.dataset.l10nArgs = JSON.stringify({
                date: dateObject.toLocaleDateString(),
                time: dateObject.toLocaleTimeString()
              });
              popup.appendChild(modificationDate);
            }

            if ((_this$richText = this.richText) !== null && _this$richText !== void 0 && _this$richText.str && (!((_this$contentsObj = this.contentsObj) !== null && _this$contentsObj !== void 0 && _this$contentsObj.str) || this.contentsObj.str === this.richText.str)) {
              _xfa_layer.XfaLayer.render({
                xfaHtml: this.richText.html,
                intent: "richText",
                div: popup
              });

              popup.lastChild.className = "richText popupContent";
            } else {
              var contents = this._formatContents(this.contentsObj);

              popup.appendChild(contents);
            }

            if (!Array.isArray(this.trigger)) {
              this.trigger = [this.trigger];
            }

            for (var element of this.trigger) {
              element.addEventListener("click", this._toggle.bind(this));
              element.addEventListener("mouseover", this._show.bind(this, false));
              element.addEventListener("mouseout", this._hide.bind(this, false));
            }

            popup.addEventListener("click", this._hide.bind(this, true));
            wrapper.appendChild(popup);
            return wrapper;
          }

          _formatContents(_ref28) {
            var {
              str,
              dir
            } = _ref28;
            var p = document.createElement("p");
            p.className = "popupContent";
            p.dir = dir;
            var lines = str.split(/(?:\r\n?|\n)/);

            for (var i = 0, ii = lines.length; i < ii; ++i) {
              var line = lines[i];
              p.appendChild(document.createTextNode(line));

              if (i < ii - 1) {
                p.appendChild(document.createElement("br"));
              }
            }

            return p;
          }

          _toggle() {
            if (this.pinned) {
              this._hide(true);
            } else {
              this._show(true);
            }
          }

          _show() {
            var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            if (pin) {
              this.pinned = true;
            }

            if (this.hideElement.hidden) {
              this.hideElement.hidden = false;
              this.container.style.zIndex += 1;
            }
          }

          _hide() {
            var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

            if (unpin) {
              this.pinned = false;
            }

            if (!this.hideElement.hidden && !this.pinned) {
              this.hideElement.hidden = true;
              this.container.style.zIndex -= 1;
            }
          }

        }

        class FreeTextAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl3, _parameters$data$cont3, _parameters$data$rich3;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl3 = parameters.data.titleObj) !== null && _parameters$data$titl3 !== void 0 && _parameters$data$titl3.str || (_parameters$data$cont3 = parameters.data.contentsObj) !== null && _parameters$data$cont3 !== void 0 && _parameters$data$cont3.str || (_parameters$data$rich3 = parameters.data.richText) !== null && _parameters$data$rich3 !== void 0 && _parameters$data$rich3.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true
            });
          }

          render() {
            this.container.className = "freeTextAnnotation";

            if (!this.data.hasPopup) {
              this._createPopup(null, this.data);
            }

            return this.container;
          }

        }

        class LineAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl4, _parameters$data$cont4, _parameters$data$rich4;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl4 = parameters.data.titleObj) !== null && _parameters$data$titl4 !== void 0 && _parameters$data$titl4.str || (_parameters$data$cont4 = parameters.data.contentsObj) !== null && _parameters$data$cont4 !== void 0 && _parameters$data$cont4.str || (_parameters$data$rich4 = parameters.data.richText) !== null && _parameters$data$rich4 !== void 0 && _parameters$data$rich4.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true
            });
          }

          render() {
            this.container.className = "lineAnnotation";
            var data = this.data;
            var {
              width,
              height
            } = getRectDims(data.rect);
            var svg = this.svgFactory.create(width, height);
            var line = this.svgFactory.createElement("svg:line");
            line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
            line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
            line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
            line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
            line.setAttribute("stroke-width", data.borderStyle.width || 1);
            line.setAttribute("stroke", "transparent");
            line.setAttribute("fill", "transparent");
            svg.appendChild(line);
            this.container.append(svg);

            this._createPopup(line, data);

            return this.container;
          }

        }

        class SquareAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl5, _parameters$data$cont5, _parameters$data$rich5;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl5 = parameters.data.titleObj) !== null && _parameters$data$titl5 !== void 0 && _parameters$data$titl5.str || (_parameters$data$cont5 = parameters.data.contentsObj) !== null && _parameters$data$cont5 !== void 0 && _parameters$data$cont5.str || (_parameters$data$rich5 = parameters.data.richText) !== null && _parameters$data$rich5 !== void 0 && _parameters$data$rich5.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true
            });
          }

          render() {
            this.container.className = "squareAnnotation";
            var data = this.data;
            var {
              width,
              height
            } = getRectDims(data.rect);
            var svg = this.svgFactory.create(width, height);
            var borderWidth = data.borderStyle.width;
            var square = this.svgFactory.createElement("svg:rect");
            square.setAttribute("x", borderWidth / 2);
            square.setAttribute("y", borderWidth / 2);
            square.setAttribute("width", width - borderWidth);
            square.setAttribute("height", height - borderWidth);
            square.setAttribute("stroke-width", borderWidth || 1);
            square.setAttribute("stroke", "transparent");
            square.setAttribute("fill", "transparent");
            svg.appendChild(square);
            this.container.append(svg);

            this._createPopup(square, data);

            return this.container;
          }

        }

        class CircleAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl6, _parameters$data$cont6, _parameters$data$rich6;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl6 = parameters.data.titleObj) !== null && _parameters$data$titl6 !== void 0 && _parameters$data$titl6.str || (_parameters$data$cont6 = parameters.data.contentsObj) !== null && _parameters$data$cont6 !== void 0 && _parameters$data$cont6.str || (_parameters$data$rich6 = parameters.data.richText) !== null && _parameters$data$rich6 !== void 0 && _parameters$data$rich6.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true
            });
          }

          render() {
            this.container.className = "circleAnnotation";
            var data = this.data;
            var {
              width,
              height
            } = getRectDims(data.rect);
            var svg = this.svgFactory.create(width, height);
            var borderWidth = data.borderStyle.width;
            var circle = this.svgFactory.createElement("svg:ellipse");
            circle.setAttribute("cx", width / 2);
            circle.setAttribute("cy", height / 2);
            circle.setAttribute("rx", width / 2 - borderWidth / 2);
            circle.setAttribute("ry", height / 2 - borderWidth / 2);
            circle.setAttribute("stroke-width", borderWidth || 1);
            circle.setAttribute("stroke", "transparent");
            circle.setAttribute("fill", "transparent");
            svg.appendChild(circle);
            this.container.append(svg);

            this._createPopup(circle, data);

            return this.container;
          }

        }

        class PolylineAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl7, _parameters$data$cont7, _parameters$data$rich7;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl7 = parameters.data.titleObj) !== null && _parameters$data$titl7 !== void 0 && _parameters$data$titl7.str || (_parameters$data$cont7 = parameters.data.contentsObj) !== null && _parameters$data$cont7 !== void 0 && _parameters$data$cont7.str || (_parameters$data$rich7 = parameters.data.richText) !== null && _parameters$data$rich7 !== void 0 && _parameters$data$rich7.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true
            });
            this.containerClassName = "polylineAnnotation";
            this.svgElementName = "svg:polyline";
          }

          render() {
            this.container.className = this.containerClassName;
            var data = this.data;
            var {
              width,
              height
            } = getRectDims(data.rect);
            var svg = this.svgFactory.create(width, height);
            var points = [];

            for (var coordinate of data.vertices) {
              var x = coordinate.x - data.rect[0];
              var y = data.rect[3] - coordinate.y;
              points.push(x + "," + y);
            }

            points = points.join(" ");
            var polyline = this.svgFactory.createElement(this.svgElementName);
            polyline.setAttribute("points", points);
            polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
            polyline.setAttribute("stroke", "transparent");
            polyline.setAttribute("fill", "transparent");
            svg.appendChild(polyline);
            this.container.append(svg);

            this._createPopup(polyline, data);

            return this.container;
          }

        }

        class PolygonAnnotationElement extends PolylineAnnotationElement {
          constructor(parameters) {
            super(parameters);
            this.containerClassName = "polygonAnnotation";
            this.svgElementName = "svg:polygon";
          }

        }

        class CaretAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl8, _parameters$data$cont8, _parameters$data$rich8;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl8 = parameters.data.titleObj) !== null && _parameters$data$titl8 !== void 0 && _parameters$data$titl8.str || (_parameters$data$cont8 = parameters.data.contentsObj) !== null && _parameters$data$cont8 !== void 0 && _parameters$data$cont8.str || (_parameters$data$rich8 = parameters.data.richText) !== null && _parameters$data$rich8 !== void 0 && _parameters$data$rich8.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true
            });
          }

          render() {
            this.container.className = "caretAnnotation";

            if (!this.data.hasPopup) {
              this._createPopup(null, this.data);
            }

            return this.container;
          }

        }

        class InkAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl9, _parameters$data$cont9, _parameters$data$rich9;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl9 = parameters.data.titleObj) !== null && _parameters$data$titl9 !== void 0 && _parameters$data$titl9.str || (_parameters$data$cont9 = parameters.data.contentsObj) !== null && _parameters$data$cont9 !== void 0 && _parameters$data$cont9.str || (_parameters$data$rich9 = parameters.data.richText) !== null && _parameters$data$rich9 !== void 0 && _parameters$data$rich9.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true
            });
            this.containerClassName = "inkAnnotation";
            this.svgElementName = "svg:polyline";
          }

          render() {
            this.container.className = this.containerClassName;
            var data = this.data;
            var {
              width,
              height
            } = getRectDims(data.rect);
            var svg = this.svgFactory.create(width, height);

            for (var inkList of data.inkLists) {
              var points = [];

              for (var coordinate of inkList) {
                var x = coordinate.x - data.rect[0];
                var y = data.rect[3] - coordinate.y;
                points.push("".concat(x, ",").concat(y));
              }

              points = points.join(" ");
              var polyline = this.svgFactory.createElement(this.svgElementName);
              polyline.setAttribute("points", points);
              polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
              polyline.setAttribute("stroke", "transparent");
              polyline.setAttribute("fill", "transparent");

              this._createPopup(polyline, data);

              svg.appendChild(polyline);
            }

            this.container.append(svg);
            return this.container;
          }

        }

        class HighlightAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl10, _parameters$data$cont10, _parameters$data$rich10;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl10 = parameters.data.titleObj) !== null && _parameters$data$titl10 !== void 0 && _parameters$data$titl10.str || (_parameters$data$cont10 = parameters.data.contentsObj) !== null && _parameters$data$cont10 !== void 0 && _parameters$data$cont10.str || (_parameters$data$rich10 = parameters.data.richText) !== null && _parameters$data$rich10 !== void 0 && _parameters$data$rich10.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }

          render() {
            if (!this.data.hasPopup) {
              this._createPopup(null, this.data);
            }

            if (this.quadrilaterals) {
              return this._renderQuadrilaterals("highlightAnnotation");
            }

            this.container.className = "highlightAnnotation";
            return this.container;
          }

        }

        class UnderlineAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl11, _parameters$data$cont11, _parameters$data$rich11;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl11 = parameters.data.titleObj) !== null && _parameters$data$titl11 !== void 0 && _parameters$data$titl11.str || (_parameters$data$cont11 = parameters.data.contentsObj) !== null && _parameters$data$cont11 !== void 0 && _parameters$data$cont11.str || (_parameters$data$rich11 = parameters.data.richText) !== null && _parameters$data$rich11 !== void 0 && _parameters$data$rich11.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }

          render() {
            if (!this.data.hasPopup) {
              this._createPopup(null, this.data);
            }

            if (this.quadrilaterals) {
              return this._renderQuadrilaterals("underlineAnnotation");
            }

            this.container.className = "underlineAnnotation";
            return this.container;
          }

        }

        class SquigglyAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl12, _parameters$data$cont12, _parameters$data$rich12;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl12 = parameters.data.titleObj) !== null && _parameters$data$titl12 !== void 0 && _parameters$data$titl12.str || (_parameters$data$cont12 = parameters.data.contentsObj) !== null && _parameters$data$cont12 !== void 0 && _parameters$data$cont12.str || (_parameters$data$rich12 = parameters.data.richText) !== null && _parameters$data$rich12 !== void 0 && _parameters$data$rich12.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }

          render() {
            if (!this.data.hasPopup) {
              this._createPopup(null, this.data);
            }

            if (this.quadrilaterals) {
              return this._renderQuadrilaterals("squigglyAnnotation");
            }

            this.container.className = "squigglyAnnotation";
            return this.container;
          }

        }

        class StrikeOutAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl13, _parameters$data$cont13, _parameters$data$rich13;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl13 = parameters.data.titleObj) !== null && _parameters$data$titl13 !== void 0 && _parameters$data$titl13.str || (_parameters$data$cont13 = parameters.data.contentsObj) !== null && _parameters$data$cont13 !== void 0 && _parameters$data$cont13.str || (_parameters$data$rich13 = parameters.data.richText) !== null && _parameters$data$rich13 !== void 0 && _parameters$data$rich13.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }

          render() {
            if (!this.data.hasPopup) {
              this._createPopup(null, this.data);
            }

            if (this.quadrilaterals) {
              return this._renderQuadrilaterals("strikeoutAnnotation");
            }

            this.container.className = "strikeoutAnnotation";
            return this.container;
          }

        }

        class StampAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _parameters$data$titl14, _parameters$data$cont14, _parameters$data$rich14;

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl14 = parameters.data.titleObj) !== null && _parameters$data$titl14 !== void 0 && _parameters$data$titl14.str || (_parameters$data$cont14 = parameters.data.contentsObj) !== null && _parameters$data$cont14 !== void 0 && _parameters$data$cont14.str || (_parameters$data$rich14 = parameters.data.richText) !== null && _parameters$data$rich14 !== void 0 && _parameters$data$rich14.str);
            super(parameters, {
              isRenderable,
              ignoreBorder: true
            });
          }

          render() {
            this.container.className = "stampAnnotation";

            if (!this.data.hasPopup) {
              this._createPopup(null, this.data);
            }

            return this.container;
          }

        }

        class FileAttachmentAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            var _this$linkService$eve8;

            super(parameters, {
              isRenderable: true
            });
            var {
              filename,
              content
            } = this.data.file;
            this.filename = (0, _display_utils.getFilenameFromUrl)(filename);
            this.content = content;
            (_this$linkService$eve8 = this.linkService.eventBus) === null || _this$linkService$eve8 === void 0 ? void 0 : _this$linkService$eve8.dispatch("fileattachmentannotation", {
              source: this,
              filename,
              content
            });
          }

          render() {
            var _this$data$titleObj, _this$data$contentsOb;

            this.container.className = "fileAttachmentAnnotation";
            var trigger = document.createElement("div");
            trigger.style.height = this.container.style.height;
            trigger.style.width = this.container.style.width;
            trigger.addEventListener("dblclick", this._download.bind(this));

            if (!this.data.hasPopup && ((_this$data$titleObj = this.data.titleObj) !== null && _this$data$titleObj !== void 0 && _this$data$titleObj.str || (_this$data$contentsOb = this.data.contentsObj) !== null && _this$data$contentsOb !== void 0 && _this$data$contentsOb.str || this.data.richText)) {
              this._createPopup(trigger, this.data);
            }

            this.container.appendChild(trigger);
            return this.container;
          }

          _download() {
            var _this$downloadManager;

            (_this$downloadManager = this.downloadManager) === null || _this$downloadManager === void 0 ? void 0 : _this$downloadManager.openOrDownloadData(this.container, this.content, this.filename);
          }

        }

        class AnnotationLayer {
          static render(parameters) {
            var sortedAnnotations = [],
                popupAnnotations = [];

            for (var data of parameters.annotations) {
              if (!data) {
                continue;
              }

              var {
                width,
                height
              } = getRectDims(data.rect);

              if (width <= 0 || height <= 0) {
                continue;
              }

              if (data.annotationType === _util.AnnotationType.POPUP) {
                popupAnnotations.push(data);
                continue;
              }

              sortedAnnotations.push(data);
            }

            if (popupAnnotations.length) {
              sortedAnnotations.push(...popupAnnotations);
            }

            var div = parameters.div;

            for (var _data3 of sortedAnnotations) {
              var element = AnnotationElementFactory.create({
                data: _data3,
                layer: div,
                page: parameters.page,
                viewport: parameters.viewport,
                linkService: parameters.linkService,
                downloadManager: parameters.downloadManager,
                imageResourcesPath: parameters.imageResourcesPath || "",
                renderForms: parameters.renderForms !== false,
                svgFactory: new _display_utils.DOMSVGFactory(),
                annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),
                enableScripting: parameters.enableScripting,
                hasJSActions: parameters.hasJSActions,
                fieldObjects: parameters.fieldObjects,
                mouseState: parameters.mouseState || {
                  isDown: false
                }
              });

              if (element.isRenderable) {
                var rendered = element.render();

                if (_data3.hidden) {
                  rendered.style.visibility = "hidden";
                }

                if (Array.isArray(rendered)) {
                  for (var renderedElement of rendered) {
                    div.appendChild(renderedElement);
                  }
                } else {
                  if (element instanceof PopupAnnotationElement) {
                    div.prepend(rendered);
                  } else {
                    div.appendChild(rendered);
                  }
                }
              }
            }

            _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(this, div, parameters.annotationCanvasMap);
          }

          static update(parameters) {
            var {
              page,
              viewport,
              annotations,
              annotationCanvasMap,
              div
            } = parameters;
            var transform = viewport.transform;
            var matrix = "matrix(".concat(transform.join(","), ")");
            var scale, ownMatrix;

            for (var data of annotations) {
              var elements = div.querySelectorAll("[data-annotation-id=\"".concat(data.id, "\"]"));

              if (elements) {
                for (var element of elements) {
                  if (data.hasOwnCanvas) {
                    var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

                    if (!ownMatrix) {
                      scale = Math.abs(transform[0] || transform[1]);
                      var ownTransform = transform.slice();

                      for (var i = 0; i < 4; i++) {
                        ownTransform[i] = Math.sign(ownTransform[i]);
                      }

                      ownMatrix = "matrix(".concat(ownTransform.join(","), ")");
                    }

                    var left = rect[0] * scale;
                    var top = rect[1] * scale;
                    element.style.left = "".concat(left, "px");
                    element.style.top = "".concat(top, "px");
                    element.style.transformOrigin = "".concat(-left, "px ").concat(-top, "px");
                    element.style.transform = ownMatrix;
                  } else {
                    element.style.transform = matrix;
                  }
                }
              }
            }

            _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(this, div, annotationCanvasMap);

            div.hidden = false;
          }

        }

        function _setAnnotationCanvasMap(div, annotationCanvasMap) {
          if (!annotationCanvasMap) {
            return;
          }

          for (var [id, canvas] of annotationCanvasMap) {
            var element = div.querySelector("[data-annotation-id=\"".concat(id, "\"]"));

            if (!element) {
              continue;
            }

            var {
              firstChild
            } = element;

            if (firstChild.nodeName === "CANVAS") {
              element.replaceChild(canvas, firstChild);
            } else {
              element.insertBefore(canvas, firstChild);
            }
          }

          annotationCanvasMap.clear();
        }

        exports.AnnotationLayer = AnnotationLayer;
        /***/
      },
      /* 21 */

      /***/
      (__unused_webpack_module, exports) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.ColorConverters = void 0;

        function makeColorComp(n) {
          return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
        }

        class ColorConverters {
          static CMYK_G(_ref29) {
            var [c, y, m, k] = _ref29;
            return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
          }

          static G_CMYK(_ref30) {
            var [g] = _ref30;
            return ["CMYK", 0, 0, 0, 1 - g];
          }

          static G_RGB(_ref31) {
            var [g] = _ref31;
            return ["RGB", g, g, g];
          }

          static G_HTML(_ref32) {
            var [g] = _ref32;
            var G = makeColorComp(g);
            return "#".concat(G).concat(G).concat(G);
          }

          static RGB_G(_ref33) {
            var [r, g, b] = _ref33;
            return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
          }

          static RGB_HTML(_ref34) {
            var [r, g, b] = _ref34;
            var R = makeColorComp(r);
            var G = makeColorComp(g);
            var B = makeColorComp(b);
            return "#".concat(R).concat(G).concat(B);
          }

          static T_HTML() {
            return "#00000000";
          }

          static CMYK_RGB(_ref35) {
            var [c, y, m, k] = _ref35;
            return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
          }

          static CMYK_HTML(components) {
            return this.RGB_HTML(this.CMYK_RGB(components));
          }

          static RGB_CMYK(_ref36) {
            var [r, g, b] = _ref36;
            var c = 1 - r;
            var m = 1 - g;
            var y = 1 - b;
            var k = Math.min(c, m, y);
            return ["CMYK", c, m, y, k];
          }

        }

        exports.ColorConverters = ColorConverters;
        /***/
      },
      /* 22 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.XfaLayer = void 0;

        var _xfa_text = __w_pdfjs_require__(18);

        class XfaLayer {
          static setupStorage(html, id, element, storage, intent) {
            var storedData = storage.getValue(id, {
              value: null
            });

            switch (element.name) {
              case "textarea":
                if (storedData.value !== null) {
                  html.textContent = storedData.value;
                }

                if (intent === "print") {
                  break;
                }

                html.addEventListener("input", event => {
                  storage.setValue(id, {
                    value: event.target.value
                  });
                });
                break;

              case "input":
                if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                  if (storedData.value === element.attributes.xfaOn) {
                    html.setAttribute("checked", true);
                  } else if (storedData.value === element.attributes.xfaOff) {
                    html.removeAttribute("checked");
                  }

                  if (intent === "print") {
                    break;
                  }

                  html.addEventListener("change", event => {
                    storage.setValue(id, {
                      value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                    });
                  });
                } else {
                  if (storedData.value !== null) {
                    html.setAttribute("value", storedData.value);
                  }

                  if (intent === "print") {
                    break;
                  }

                  html.addEventListener("input", event => {
                    storage.setValue(id, {
                      value: event.target.value
                    });
                  });
                }

                break;

              case "select":
                if (storedData.value !== null) {
                  for (var option of element.children) {
                    if (option.attributes.value === storedData.value) {
                      option.attributes.selected = true;
                    }
                  }
                }

                html.addEventListener("input", event => {
                  var options = event.target.options;
                  var value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                  storage.setValue(id, {
                    value
                  });
                });
                break;
            }
          }

          static setAttributes(_ref37) {
            var {
              html,
              element,
              storage = null,
              intent,
              linkService
            } = _ref37;
            var {
              attributes
            } = element;
            var isHTMLAnchorElement = html instanceof HTMLAnchorElement;

            if (attributes.type === "radio") {
              attributes.name = "".concat(attributes.name, "-").concat(intent);
            }

            for (var [key, value] of Object.entries(attributes)) {
              if (value === null || value === undefined || key === "dataId") {
                continue;
              }

              if (key !== "style") {
                if (key === "textContent") {
                  html.textContent = value;
                } else if (key === "class") {
                  if (value.length) {
                    html.setAttribute(key, value.join(" "));
                  }
                } else {
                  if (isHTMLAnchorElement && (key === "href" || key === "newWindow")) {
                    continue;
                  }

                  html.setAttribute(key, value);
                }
              } else {
                Object.assign(html.style, value);
              }
            }

            if (isHTMLAnchorElement) {
              linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
            }

            if (storage && attributes.dataId) {
              this.setupStorage(html, attributes.dataId, element, storage);
            }
          }

          static render(parameters) {
            var storage = parameters.annotationStorage;
            var linkService = parameters.linkService;
            var root = parameters.xfaHtml;
            var intent = parameters.intent || "display";
            var rootHtml = document.createElement(root.name);

            if (root.attributes) {
              this.setAttributes({
                html: rootHtml,
                element: root,
                intent,
                linkService
              });
            }

            var stack = [[root, -1, rootHtml]];
            var rootDiv = parameters.div;
            rootDiv.appendChild(rootHtml);

            if (parameters.viewport) {
              var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
              rootDiv.style.transform = transform;
            }

            if (intent !== "richText") {
              rootDiv.setAttribute("class", "xfaLayer xfaFont");
            }

            var textDivs = [];

            while (stack.length > 0) {
              var _child$attributes;

              var [parent, i, html] = stack[stack.length - 1];

              if (i + 1 === parent.children.length) {
                stack.pop();
                continue;
              }

              var child = parent.children[++stack[stack.length - 1][1]];

              if (child === null) {
                continue;
              }

              var {
                name
              } = child;

              if (name === "#text") {
                var node = document.createTextNode(child.value);
                textDivs.push(node);
                html.appendChild(node);
                continue;
              }

              var childHtml = void 0;

              if (child !== null && child !== void 0 && (_child$attributes = child.attributes) !== null && _child$attributes !== void 0 && _child$attributes.xmlns) {
                childHtml = document.createElementNS(child.attributes.xmlns, name);
              } else {
                childHtml = document.createElement(name);
              }

              html.appendChild(childHtml);

              if (child.attributes) {
                this.setAttributes({
                  html: childHtml,
                  element: child,
                  storage,
                  intent,
                  linkService
                });
              }

              if (child.children && child.children.length > 0) {
                stack.push([child, -1, childHtml]);
              } else if (child.value) {
                var _node = document.createTextNode(child.value);

                if (_xfa_text.XfaText.shouldBuildText(name)) {
                  textDivs.push(_node);
                }

                childHtml.appendChild(_node);
              }
            }

            for (var el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
              el.setAttribute("readOnly", true);
            }

            return {
              textDivs
            };
          }

          static update(parameters) {
            var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
            parameters.div.style.transform = transform;
            parameters.div.hidden = false;
          }

        }

        exports.XfaLayer = XfaLayer;
        /***/
      },
      /* 23 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.renderTextLayer = renderTextLayer;

        var _util = __w_pdfjs_require__(1);

        var MAX_TEXT_DIVS_TO_RENDER = 100000;
        var DEFAULT_FONT_SIZE = 30;
        var DEFAULT_FONT_ASCENT = 0.8;
        var ascentCache = new Map();
        var AllWhitespaceRegexp = /^\s+$/g;

        function getAscent(fontFamily, ctx) {
          var cachedAscent = ascentCache.get(fontFamily);

          if (cachedAscent) {
            return cachedAscent;
          }

          ctx.save();
          ctx.font = "".concat(DEFAULT_FONT_SIZE, "px ").concat(fontFamily);
          var metrics = ctx.measureText("");
          var ascent = metrics.fontBoundingBoxAscent;
          var descent = Math.abs(metrics.fontBoundingBoxDescent);

          if (ascent) {
            ctx.restore();
            var ratio = ascent / (ascent + descent);
            ascentCache.set(fontFamily, ratio);
            return ratio;
          }

          ctx.strokeStyle = "red";
          ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
          ctx.strokeText("g", 0, 0);
          var pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
          descent = 0;

          for (var i = pixels.length - 1 - 3; i >= 0; i -= 4) {
            if (pixels[i] > 0) {
              descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
              break;
            }
          }

          ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
          ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
          pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
          ascent = 0;

          for (var _i6 = 0, ii = pixels.length; _i6 < ii; _i6 += 4) {
            if (pixels[_i6] > 0) {
              ascent = DEFAULT_FONT_SIZE - Math.floor(_i6 / 4 / DEFAULT_FONT_SIZE);
              break;
            }
          }

          ctx.restore();

          if (ascent) {
            var _ratio = ascent / (ascent + descent);

            ascentCache.set(fontFamily, _ratio);
            return _ratio;
          }

          ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
          return DEFAULT_FONT_ASCENT;
        }

        function appendText(task, geom, styles, ctx) {
          var textDiv = document.createElement("div");
          var textDivProperties = task._enhanceTextSelection ? {
            angle: 0,
            canvasWidth: 0,
            hasText: geom.str !== "",
            hasEOL: geom.hasEOL,
            originalTransform: null,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            scale: 1
          } : {
            angle: 0,
            canvasWidth: 0,
            hasText: geom.str !== "",
            hasEOL: geom.hasEOL
          };

          task._textDivs.push(textDiv);

          var tx = _util.Util.transform(task._viewport.transform, geom.transform);

          var angle = Math.atan2(tx[1], tx[0]);
          var style = styles[geom.fontName];

          if (style.vertical) {
            angle += Math.PI / 2;
          }

          var fontHeight = Math.hypot(tx[2], tx[3]);
          var fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
          var left, top;

          if (angle === 0) {
            left = tx[4];
            top = tx[5] - fontAscent;
          } else {
            left = tx[4] + fontAscent * Math.sin(angle);
            top = tx[5] - fontAscent * Math.cos(angle);
          }

          textDiv.style.left = "".concat(left, "px");
          textDiv.style.top = "".concat(top, "px");
          textDiv.style.fontSize = "".concat(fontHeight, "px");
          textDiv.style.fontFamily = style.fontFamily;
          textDiv.setAttribute("role", "presentation");
          textDiv.textContent = geom.str;
          textDiv.dir = geom.dir;

          if (task._fontInspectorEnabled) {
            textDiv.dataset.fontName = geom.fontName;
          }

          if (angle !== 0) {
            textDivProperties.angle = angle * (180 / Math.PI);
          }

          var shouldScaleText = false;

          if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
            shouldScaleText = true;
          } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
            var absScaleX = Math.abs(geom.transform[0]),
                absScaleY = Math.abs(geom.transform[3]);

            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
              shouldScaleText = true;
            }
          }

          if (shouldScaleText) {
            if (style.vertical) {
              textDivProperties.canvasWidth = geom.height * task._viewport.scale;
            } else {
              textDivProperties.canvasWidth = geom.width * task._viewport.scale;
            }
          }

          task._textDivProperties.set(textDiv, textDivProperties);

          if (task._textContentStream) {
            task._layoutText(textDiv);
          }

          if (task._enhanceTextSelection && textDivProperties.hasText) {
            var angleCos = 1,
                angleSin = 0;

            if (angle !== 0) {
              angleCos = Math.cos(angle);
              angleSin = Math.sin(angle);
            }

            var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
            var divHeight = fontHeight;
            var m, b;

            if (angle !== 0) {
              m = [angleCos, angleSin, -angleSin, angleCos, left, top];
              b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
            } else {
              b = [left, top, left + divWidth, top + divHeight];
            }

            task._bounds.push({
              left: b[0],
              top: b[1],
              right: b[2],
              bottom: b[3],
              div: textDiv,
              size: [divWidth, divHeight],
              m
            });
          }
        }

        function render(task) {
          if (task._canceled) {
            return;
          }

          var textDivs = task._textDivs;
          var capability = task._capability;
          var textDivsLength = textDivs.length;

          if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
            task._renderingDone = true;
            capability.resolve();
            return;
          }

          if (!task._textContentStream) {
            for (var i = 0; i < textDivsLength; i++) {
              task._layoutText(textDivs[i]);
            }
          }

          task._renderingDone = true;
          capability.resolve();
        }

        function findPositiveMin(ts, offset, count) {
          var result = 0;

          for (var i = 0; i < count; i++) {
            var t = ts[offset++];

            if (t > 0) {
              result = result ? Math.min(t, result) : t;
            }
          }

          return result;
        }

        function expand(task) {
          var bounds = task._bounds;
          var viewport = task._viewport;
          var expanded = expandBounds(viewport.width, viewport.height, bounds);

          for (var i = 0; i < expanded.length; i++) {
            var div = bounds[i].div;

            var divProperties = task._textDivProperties.get(div);

            if (divProperties.angle === 0) {
              divProperties.paddingLeft = bounds[i].left - expanded[i].left;
              divProperties.paddingTop = bounds[i].top - expanded[i].top;
              divProperties.paddingRight = expanded[i].right - bounds[i].right;
              divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

              task._textDivProperties.set(div, divProperties);

              continue;
            }

            var e = expanded[i],
                b = bounds[i];
            var m = b.m,
                c = m[0],
                s = m[1];
            var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
            var ts = new Float64Array(64);

            for (var j = 0, jj = points.length; j < jj; j++) {
              var t = _util.Util.applyTransform(points[j], m);

              ts[j + 0] = c && (e.left - t[0]) / c;
              ts[j + 4] = s && (e.top - t[1]) / s;
              ts[j + 8] = c && (e.right - t[0]) / c;
              ts[j + 12] = s && (e.bottom - t[1]) / s;
              ts[j + 16] = s && (e.left - t[0]) / -s;
              ts[j + 20] = c && (e.top - t[1]) / c;
              ts[j + 24] = s && (e.right - t[0]) / -s;
              ts[j + 28] = c && (e.bottom - t[1]) / c;
              ts[j + 32] = c && (e.left - t[0]) / -c;
              ts[j + 36] = s && (e.top - t[1]) / -s;
              ts[j + 40] = c && (e.right - t[0]) / -c;
              ts[j + 44] = s && (e.bottom - t[1]) / -s;
              ts[j + 48] = s && (e.left - t[0]) / s;
              ts[j + 52] = c && (e.top - t[1]) / -c;
              ts[j + 56] = s && (e.right - t[0]) / s;
              ts[j + 60] = c && (e.bottom - t[1]) / -c;
            }

            var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
            divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
            divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
            divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
            divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

            task._textDivProperties.set(div, divProperties);
          }
        }

        function expandBounds(width, height, boxes) {
          var bounds = boxes.map(function (box, i) {
            return {
              x1: box.left,
              y1: box.top,
              x2: box.right,
              y2: box.bottom,
              index: i,
              x1New: undefined,
              x2New: undefined
            };
          });
          expandBoundsLTR(width, bounds);
          var expanded = new Array(boxes.length);

          for (var b of bounds) {
            var i = b.index;
            expanded[i] = {
              left: b.x1New,
              top: 0,
              right: b.x2New,
              bottom: 0
            };
          }

          boxes.map(function (box, i) {
            var e = expanded[i],
                b = bounds[i];
            b.x1 = box.top;
            b.y1 = width - e.right;
            b.x2 = box.bottom;
            b.y2 = width - e.left;
            b.index = i;
            b.x1New = undefined;
            b.x2New = undefined;
          });
          expandBoundsLTR(height, bounds);

          for (var _b2 of bounds) {
            var _i7 = _b2.index;
            expanded[_i7].top = _b2.x1New;
            expanded[_i7].bottom = _b2.x2New;
          }

          return expanded;
        }

        function expandBoundsLTR(width, bounds) {
          bounds.sort(function (a, b) {
            return a.x1 - b.x1 || a.index - b.index;
          });
          var fakeBoundary = {
            x1: -Infinity,
            y1: -Infinity,
            x2: 0,
            y2: Infinity,
            index: -1,
            x1New: 0,
            x2New: 0
          };
          var horizon = [{
            start: -Infinity,
            end: Infinity,
            boundary: fakeBoundary
          }];

          for (var boundary of bounds) {
            var i = 0;

            while (i < horizon.length && horizon[i].end <= boundary.y1) {
              i++;
            }

            var j = horizon.length - 1;

            while (j >= 0 && horizon[j].start >= boundary.y2) {
              j--;
            }

            var horizonPart = void 0,
                affectedBoundary = void 0;
            var q = void 0,
                k = void 0,
                maxXNew = -Infinity;

            for (q = i; q <= j; q++) {
              horizonPart = horizon[q];
              affectedBoundary = horizonPart.boundary;
              var xNew = void 0;

              if (affectedBoundary.x2 > boundary.x1) {
                xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
              } else if (affectedBoundary.x2New === undefined) {
                xNew = (affectedBoundary.x2 + boundary.x1) / 2;
              } else {
                xNew = affectedBoundary.x2New;
              }

              if (xNew > maxXNew) {
                maxXNew = xNew;
              }
            }

            boundary.x1New = maxXNew;

            for (q = i; q <= j; q++) {
              horizonPart = horizon[q];
              affectedBoundary = horizonPart.boundary;

              if (affectedBoundary.x2New === undefined) {
                if (affectedBoundary.x2 > boundary.x1) {
                  if (affectedBoundary.index > boundary.index) {
                    affectedBoundary.x2New = affectedBoundary.x2;
                  }
                } else {
                  affectedBoundary.x2New = maxXNew;
                }
              } else if (affectedBoundary.x2New > maxXNew) {
                affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
              }
            }

            var changedHorizon = [];
            var lastBoundary = null;

            for (q = i; q <= j; q++) {
              horizonPart = horizon[q];
              affectedBoundary = horizonPart.boundary;
              var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;

              if (lastBoundary === useBoundary) {
                changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
              } else {
                changedHorizon.push({
                  start: horizonPart.start,
                  end: horizonPart.end,
                  boundary: useBoundary
                });
                lastBoundary = useBoundary;
              }
            }

            if (horizon[i].start < boundary.y1) {
              changedHorizon[0].start = boundary.y1;
              changedHorizon.unshift({
                start: horizon[i].start,
                end: boundary.y1,
                boundary: horizon[i].boundary
              });
            }

            if (boundary.y2 < horizon[j].end) {
              changedHorizon[changedHorizon.length - 1].end = boundary.y2;
              changedHorizon.push({
                start: boundary.y2,
                end: horizon[j].end,
                boundary: horizon[j].boundary
              });
            }

            for (q = i; q <= j; q++) {
              horizonPart = horizon[q];
              affectedBoundary = horizonPart.boundary;

              if (affectedBoundary.x2New !== undefined) {
                continue;
              }

              var used = false;

              for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                used = horizon[k].boundary === affectedBoundary;
              }

              for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                used = horizon[k].boundary === affectedBoundary;
              }

              for (k = 0; !used && k < changedHorizon.length; k++) {
                used = changedHorizon[k].boundary === affectedBoundary;
              }

              if (!used) {
                affectedBoundary.x2New = maxXNew;
              }
            }

            Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
          }

          for (var _horizonPart2 of horizon) {
            var _affectedBoundary = _horizonPart2.boundary;

            if (_affectedBoundary.x2New === undefined) {
              _affectedBoundary.x2New = Math.max(width, _affectedBoundary.x2);
            }
          }
        }

        class TextLayerRenderTask {
          constructor(_ref38) {
            var _globalThis$FontInspe2;

            var {
              textContent,
              textContentStream,
              container,
              viewport,
              textDivs,
              textContentItemsStr,
              enhanceTextSelection
            } = _ref38;
            this._textContent = textContent;
            this._textContentStream = textContentStream;
            this._container = container;
            this._document = container.ownerDocument;
            this._viewport = viewport;
            this._textDivs = textDivs || [];
            this._textContentItemsStr = textContentItemsStr || [];
            this._enhanceTextSelection = !!enhanceTextSelection;
            this._fontInspectorEnabled = !!((_globalThis$FontInspe2 = globalThis.FontInspector) !== null && _globalThis$FontInspe2 !== void 0 && _globalThis$FontInspe2.enabled);
            this._reader = null;
            this._layoutTextLastFontSize = null;
            this._layoutTextLastFontFamily = null;
            this._layoutTextCtx = null;
            this._textDivProperties = new WeakMap();
            this._renderingDone = false;
            this._canceled = false;
            this._capability = (0, _util.createPromiseCapability)();
            this._renderTimer = null;
            this._bounds = [];

            this._capability.promise.finally(() => {
              if (!this._enhanceTextSelection) {
                this._textDivProperties = null;
              }

              if (this._layoutTextCtx) {
                this._layoutTextCtx.canvas.width = 0;
                this._layoutTextCtx.canvas.height = 0;
                this._layoutTextCtx = null;
              }
            }).catch(() => {});
          }

          get promise() {
            return this._capability.promise;
          }

          cancel() {
            this._canceled = true;

            if (this._reader) {
              this._reader.cancel(new _util.AbortException("TextLayer task cancelled.")).catch(() => {});

              this._reader = null;
            }

            if (this._renderTimer !== null) {
              clearTimeout(this._renderTimer);
              this._renderTimer = null;
            }

            this._capability.reject(new Error("TextLayer task cancelled."));
          }

          _processItems(items, styleCache) {
            for (var i = 0, len = items.length; i < len; i++) {
              if (items[i].str === undefined) {
                if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
                  var parent = this._container;
                  this._container = document.createElement("span");

                  this._container.classList.add("markedContent");

                  if (items[i].id !== null) {
                    this._container.setAttribute("id", "".concat(items[i].id));
                  }

                  parent.appendChild(this._container);
                } else if (items[i].type === "endMarkedContent") {
                  this._container = this._container.parentNode;
                }

                continue;
              }

              this._textContentItemsStr.push(items[i].str);

              appendText(this, items[i], styleCache, this._layoutTextCtx);
            }
          }

          _layoutText(textDiv) {
            var textDivProperties = this._textDivProperties.get(textDiv);

            var transform = "";

            if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
              var {
                fontSize,
                fontFamily
              } = textDiv.style;

              if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                this._layoutTextCtx.font = "".concat(fontSize, " ").concat(fontFamily);
                this._layoutTextLastFontSize = fontSize;
                this._layoutTextLastFontFamily = fontFamily;
              }

              var {
                width
              } = this._layoutTextCtx.measureText(textDiv.textContent);

              if (width > 0) {
                var scale = textDivProperties.canvasWidth / width;

                if (this._enhanceTextSelection) {
                  textDivProperties.scale = scale;
                }

                transform = "scaleX(".concat(scale, ")");
              }
            }

            if (textDivProperties.angle !== 0) {
              transform = "rotate(".concat(textDivProperties.angle, "deg) ").concat(transform);
            }

            if (transform.length > 0) {
              if (this._enhanceTextSelection) {
                textDivProperties.originalTransform = transform;
              }

              textDiv.style.transform = transform;
            }

            if (textDivProperties.hasText) {
              this._container.appendChild(textDiv);
            }

            if (textDivProperties.hasEOL) {
              var br = document.createElement("br");
              br.setAttribute("role", "presentation");

              this._container.appendChild(br);
            }
          }

          _render() {
            var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var capability = (0, _util.createPromiseCapability)();
            var styleCache = Object.create(null);

            var canvas = this._document.createElement("canvas");

            canvas.height = canvas.width = DEFAULT_FONT_SIZE;
            this._layoutTextCtx = canvas.getContext("2d", {
              alpha: false
            });

            if (this._textContent) {
              var textItems = this._textContent.items;
              var textStyles = this._textContent.styles;

              this._processItems(textItems, textStyles);

              capability.resolve();
            } else if (this._textContentStream) {
              var pump = () => {
                this._reader.read().then(_ref39 => {
                  var {
                    value,
                    done
                  } = _ref39;

                  if (done) {
                    capability.resolve();
                    return;
                  }

                  Object.assign(styleCache, value.styles);

                  this._processItems(value.items, styleCache);

                  pump();
                }, capability.reject);
              };

              this._reader = this._textContentStream.getReader();
              pump();
            } else {
              throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
            }

            capability.promise.then(() => {
              styleCache = null;

              if (!timeout) {
                render(this);
              } else {
                this._renderTimer = setTimeout(() => {
                  render(this);
                  this._renderTimer = null;
                }, timeout);
              }
            }, this._capability.reject);
          }

          expandTextDivs() {
            var expandDivs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            if (!this._enhanceTextSelection || !this._renderingDone) {
              return;
            }

            if (this._bounds !== null) {
              expand(this);
              this._bounds = null;
            }

            var transformBuf = [],
                paddingBuf = [];

            for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
              var div = this._textDivs[i];

              var divProps = this._textDivProperties.get(div);

              if (!divProps.hasText) {
                continue;
              }

              if (expandDivs) {
                transformBuf.length = 0;
                paddingBuf.length = 0;

                if (divProps.originalTransform) {
                  transformBuf.push(divProps.originalTransform);
                }

                if (divProps.paddingTop > 0) {
                  paddingBuf.push("".concat(divProps.paddingTop, "px"));
                  transformBuf.push("translateY(".concat(-divProps.paddingTop, "px)"));
                } else {
                  paddingBuf.push(0);
                }

                if (divProps.paddingRight > 0) {
                  paddingBuf.push("".concat(divProps.paddingRight / divProps.scale, "px"));
                } else {
                  paddingBuf.push(0);
                }

                if (divProps.paddingBottom > 0) {
                  paddingBuf.push("".concat(divProps.paddingBottom, "px"));
                } else {
                  paddingBuf.push(0);
                }

                if (divProps.paddingLeft > 0) {
                  paddingBuf.push("".concat(divProps.paddingLeft / divProps.scale, "px"));
                  transformBuf.push("translateX(".concat(-divProps.paddingLeft / divProps.scale, "px)"));
                } else {
                  paddingBuf.push(0);
                }

                div.style.padding = paddingBuf.join(" ");

                if (transformBuf.length) {
                  div.style.transform = transformBuf.join(" ");
                }
              } else {
                div.style.padding = null;
                div.style.transform = divProps.originalTransform;
              }
            }
          }

        }

        function renderTextLayer(renderParameters) {
          var task = new TextLayerRenderTask({
            textContent: renderParameters.textContent,
            textContentStream: renderParameters.textContentStream,
            container: renderParameters.container,
            viewport: renderParameters.viewport,
            textDivs: renderParameters.textDivs,
            textContentItemsStr: renderParameters.textContentItemsStr,
            enhanceTextSelection: renderParameters.enhanceTextSelection
          });

          task._render(renderParameters.timeout);

          return task;
        }
        /***/

      },
      /* 24 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.SVGGraphics = void 0;

        var _util = __w_pdfjs_require__(1);

        var _display_utils = __w_pdfjs_require__(5);

        var _is_node = __w_pdfjs_require__(3);

        var SVGGraphics = class {
          constructor() {
            (0, _util.unreachable)("Not implemented: SVGGraphics");
          }

        };
        exports.SVGGraphics = SVGGraphics;
        {
          var SVG_DEFAULTS = {
            fontStyle: "normal",
            fontWeight: "normal",
            fillColor: "#000000"
          };
          var XML_NS = "http://www.w3.org/XML/1998/namespace";
          var XLINK_NS = "http://www.w3.org/1999/xlink";
          var LINE_CAP_STYLES = ["butt", "round", "square"];
          var LINE_JOIN_STYLES = ["miter", "round", "bevel"];

          var createObjectURL = function createObjectURL(data) {
            var contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
              return URL.createObjectURL(new Blob([data], {
                type: contentType
              }));
            }

            var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var buffer = "data:".concat(contentType, ";base64,");

            for (var i = 0, ii = data.length; i < ii; i += 3) {
              var b1 = data[i] & 0xff;
              var b2 = data[i + 1] & 0xff;
              var b3 = data[i + 2] & 0xff;
              var d1 = b1 >> 2,
                  d2 = (b1 & 3) << 4 | b2 >> 4;
              var d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
              var d4 = i + 2 < ii ? b3 & 0x3f : 64;
              buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
            }

            return buffer;
          };

          var convertImgDataToPng = function () {
            var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
            var CHUNK_WRAPPER_SIZE = 12;
            var crcTable = new Int32Array(256);

            for (var i = 0; i < 256; i++) {
              var c = i;

              for (var h = 0; h < 8; h++) {
                if (c & 1) {
                  c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
                } else {
                  c = c >> 1 & 0x7fffffff;
                }
              }

              crcTable[i] = c;
            }

            function crc32(data, start, end) {
              var crc = -1;

              for (var _i9 = start; _i9 < end; _i9++) {
                var a = (crc ^ data[_i9]) & 0xff;
                var b = crcTable[a];
                crc = crc >>> 8 ^ b;
              }

              return crc ^ -1;
            }

            function writePngChunk(type, body, data, offset) {
              var p = offset;
              var len = body.length;
              data[p] = len >> 24 & 0xff;
              data[p + 1] = len >> 16 & 0xff;
              data[p + 2] = len >> 8 & 0xff;
              data[p + 3] = len & 0xff;
              p += 4;
              data[p] = type.charCodeAt(0) & 0xff;
              data[p + 1] = type.charCodeAt(1) & 0xff;
              data[p + 2] = type.charCodeAt(2) & 0xff;
              data[p + 3] = type.charCodeAt(3) & 0xff;
              p += 4;
              data.set(body, p);
              p += body.length;
              var crc = crc32(data, offset + 4, p);
              data[p] = crc >> 24 & 0xff;
              data[p + 1] = crc >> 16 & 0xff;
              data[p + 2] = crc >> 8 & 0xff;
              data[p + 3] = crc & 0xff;
            }

            function adler32(data, start, end) {
              var a = 1;
              var b = 0;

              for (var _i11 = start; _i11 < end; ++_i11) {
                a = (a + (data[_i11] & 0xff)) % 65521;
                b = (b + a) % 65521;
              }

              return b << 16 | a;
            }

            function deflateSync(literals) {
              if (!_is_node.isNodeJS) {
                return deflateSyncUncompressed(literals);
              }

              try {
                var input;

                if (parseInt(process.versions.node) >= 8) {
                  input = literals;
                } else {
                  input = Buffer.from(literals);
                }

                var output = (__webpack_require__(/*! zlib */ "?c6f9").deflateSync)(input, {
                  level: 9
                });

                return output instanceof Uint8Array ? output : new Uint8Array(output);
              } catch (e) {
                (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
              }

              return deflateSyncUncompressed(literals);
            }

            function deflateSyncUncompressed(literals) {
              var len = literals.length;
              var maxBlockLength = 0xffff;
              var deflateBlocks = Math.ceil(len / maxBlockLength);
              var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
              var pi = 0;
              idat[pi++] = 0x78;
              idat[pi++] = 0x9c;
              var pos = 0;

              while (len > maxBlockLength) {
                idat[pi++] = 0x00;
                idat[pi++] = 0xff;
                idat[pi++] = 0xff;
                idat[pi++] = 0x00;
                idat[pi++] = 0x00;
                idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                pi += maxBlockLength;
                pos += maxBlockLength;
                len -= maxBlockLength;
              }

              idat[pi++] = 0x01;
              idat[pi++] = len & 0xff;
              idat[pi++] = len >> 8 & 0xff;
              idat[pi++] = ~len & 0xffff & 0xff;
              idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
              idat.set(literals.subarray(pos), pi);
              pi += literals.length - pos;
              var adler = adler32(literals, 0, literals.length);
              idat[pi++] = adler >> 24 & 0xff;
              idat[pi++] = adler >> 16 & 0xff;
              idat[pi++] = adler >> 8 & 0xff;
              idat[pi++] = adler & 0xff;
              return idat;
            }

            function encode(imgData, kind, forceDataSchema, isMask) {
              var width = imgData.width;
              var height = imgData.height;
              var bitDepth, colorType, lineSize;
              var bytes = imgData.data;

              switch (kind) {
                case _util.ImageKind.GRAYSCALE_1BPP:
                  colorType = 0;
                  bitDepth = 1;
                  lineSize = width + 7 >> 3;
                  break;

                case _util.ImageKind.RGB_24BPP:
                  colorType = 2;
                  bitDepth = 8;
                  lineSize = width * 3;
                  break;

                case _util.ImageKind.RGBA_32BPP:
                  colorType = 6;
                  bitDepth = 8;
                  lineSize = width * 4;
                  break;

                default:
                  throw new Error("invalid format");
              }

              var literals = new Uint8Array((1 + lineSize) * height);
              var offsetLiterals = 0,
                  offsetBytes = 0;

              for (var y = 0; y < height; ++y) {
                literals[offsetLiterals++] = 0;
                literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                offsetBytes += lineSize;
                offsetLiterals += lineSize;
              }

              if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
                offsetLiterals = 0;

                for (var _y2 = 0; _y2 < height; _y2++) {
                  offsetLiterals++;

                  for (var _i13 = 0; _i13 < lineSize; _i13++) {
                    literals[offsetLiterals++] ^= 0xff;
                  }
                }
              }

              var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
              var idat = deflateSync(literals);
              var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
              var data = new Uint8Array(pngLength);
              var offset = 0;
              data.set(PNG_HEADER, offset);
              offset += PNG_HEADER.length;
              writePngChunk("IHDR", ihdr, data, offset);
              offset += CHUNK_WRAPPER_SIZE + ihdr.length;
              writePngChunk("IDATA", idat, data, offset);
              offset += CHUNK_WRAPPER_SIZE + idat.length;
              writePngChunk("IEND", new Uint8Array(0), data, offset);
              return createObjectURL(data, "image/png", forceDataSchema);
            }

            return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
              var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
              return encode(imgData, kind, forceDataSchema, isMask);
            };
          }();

          class SVGExtraState {
            constructor() {
              this.fontSizeScale = 1;
              this.fontWeight = SVG_DEFAULTS.fontWeight;
              this.fontSize = 0;
              this.textMatrix = _util.IDENTITY_MATRIX;
              this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
              this.leading = 0;
              this.textRenderingMode = _util.TextRenderingMode.FILL;
              this.textMatrixScale = 1;
              this.x = 0;
              this.y = 0;
              this.lineX = 0;
              this.lineY = 0;
              this.charSpacing = 0;
              this.wordSpacing = 0;
              this.textHScale = 1;
              this.textRise = 0;
              this.fillColor = SVG_DEFAULTS.fillColor;
              this.strokeColor = "#000000";
              this.fillAlpha = 1;
              this.strokeAlpha = 1;
              this.lineWidth = 1;
              this.lineJoin = "";
              this.lineCap = "";
              this.miterLimit = 0;
              this.dashArray = [];
              this.dashPhase = 0;
              this.dependencies = [];
              this.activeClipUrl = null;
              this.clipGroup = null;
              this.maskId = "";
            }

            clone() {
              return Object.create(this);
            }

            setCurrentPoint(x, y) {
              this.x = x;
              this.y = y;
            }

          }

          function opListToTree(opList) {
            var opTree = [];
            var tmp = [];

            for (var opListElement of opList) {
              if (opListElement.fn === "save") {
                opTree.push({
                  fnId: 92,
                  fn: "group",
                  items: []
                });
                tmp.push(opTree);
                opTree = opTree[opTree.length - 1].items;
                continue;
              }

              if (opListElement.fn === "restore") {
                opTree = tmp.pop();
              } else {
                opTree.push(opListElement);
              }
            }

            return opTree;
          }

          function pf(value) {
            if (Number.isInteger(value)) {
              return value.toString();
            }

            var s = value.toFixed(10);
            var i = s.length - 1;

            if (s[i] !== "0") {
              return s;
            }

            do {
              i--;
            } while (s[i] === "0");

            return s.substring(0, s[i] === "." ? i : i + 1);
          }

          function pm(m) {
            if (m[4] === 0 && m[5] === 0) {
              if (m[1] === 0 && m[2] === 0) {
                if (m[0] === 1 && m[3] === 1) {
                  return "";
                }

                return "scale(".concat(pf(m[0]), " ").concat(pf(m[3]), ")");
              }

              if (m[0] === m[3] && m[1] === -m[2]) {
                var a = Math.acos(m[0]) * 180 / Math.PI;
                return "rotate(".concat(pf(a), ")");
              }
            } else {
              if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                return "translate(".concat(pf(m[4]), " ").concat(pf(m[5]), ")");
              }
            }

            return "matrix(".concat(pf(m[0]), " ").concat(pf(m[1]), " ").concat(pf(m[2]), " ").concat(pf(m[3]), " ").concat(pf(m[4]), " ") + "".concat(pf(m[5]), ")");
          }

          var clipCount = 0;
          var maskCount = 0;
          var shadingCount = 0;
          exports.SVGGraphics = SVGGraphics = class {
            constructor(commonObjs, objs) {
              var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
              this.svgFactory = new _display_utils.DOMSVGFactory();
              this.current = new SVGExtraState();
              this.transformMatrix = _util.IDENTITY_MATRIX;
              this.transformStack = [];
              this.extraStack = [];
              this.commonObjs = commonObjs;
              this.objs = objs;
              this.pendingClip = null;
              this.pendingEOFill = false;
              this.embedFonts = false;
              this.embeddedFonts = Object.create(null);
              this.cssStyle = null;
              this.forceDataSchema = !!forceDataSchema;
              this._operatorIdMapping = [];

              for (var op in _util.OPS) {
                this._operatorIdMapping[_util.OPS[op]] = op;
              }
            }

            save() {
              this.transformStack.push(this.transformMatrix);
              var old = this.current;
              this.extraStack.push(old);
              this.current = old.clone();
            }

            restore() {
              this.transformMatrix = this.transformStack.pop();
              this.current = this.extraStack.pop();
              this.pendingClip = null;
              this.tgrp = null;
            }

            group(items) {
              this.save();
              this.executeOpTree(items);
              this.restore();
            }

            loadDependencies(operatorList) {
              var _this14 = this;

              var fnArray = operatorList.fnArray;
              var argsArray = operatorList.argsArray;

              for (var i = 0, ii = fnArray.length; i < ii; i++) {
                if (fnArray[i] !== _util.OPS.dependency) {
                  continue;
                }

                var _loop3 = function _loop3(obj) {
                  var objsPool = obj.startsWith("g_") ? _this14.commonObjs : _this14.objs;
                  var promise = new Promise(resolve => {
                    objsPool.get(obj, resolve);
                  });

                  _this14.current.dependencies.push(promise);
                };

                for (var obj of argsArray[i]) {
                  _loop3(obj);
                }
              }

              return Promise.all(this.current.dependencies);
            }

            transform(a, b, c, d, e, f) {
              var transformMatrix = [a, b, c, d, e, f];
              this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
              this.tgrp = null;
            }

            getSVG(operatorList, viewport) {
              this.viewport = viewport;

              var svgElement = this._initialize(viewport);

              return this.loadDependencies(operatorList).then(() => {
                this.transformMatrix = _util.IDENTITY_MATRIX;
                this.executeOpTree(this.convertOpList(operatorList));
                return svgElement;
              });
            }

            convertOpList(operatorList) {
              var operatorIdMapping = this._operatorIdMapping;
              var argsArray = operatorList.argsArray;
              var fnArray = operatorList.fnArray;
              var opList = [];

              for (var i = 0, ii = fnArray.length; i < ii; i++) {
                var fnId = fnArray[i];
                opList.push({
                  fnId,
                  fn: operatorIdMapping[fnId],
                  args: argsArray[i]
                });
              }

              return opListToTree(opList);
            }

            executeOpTree(opTree) {
              for (var opTreeElement of opTree) {
                var fn = opTreeElement.fn;
                var fnId = opTreeElement.fnId;
                var args = opTreeElement.args;

                switch (fnId | 0) {
                  case _util.OPS.beginText:
                    this.beginText();
                    break;

                  case _util.OPS.dependency:
                    break;

                  case _util.OPS.setLeading:
                    this.setLeading(args);
                    break;

                  case _util.OPS.setLeadingMoveText:
                    this.setLeadingMoveText(args[0], args[1]);
                    break;

                  case _util.OPS.setFont:
                    this.setFont(args);
                    break;

                  case _util.OPS.showText:
                    this.showText(args[0]);
                    break;

                  case _util.OPS.showSpacedText:
                    this.showText(args[0]);
                    break;

                  case _util.OPS.endText:
                    this.endText();
                    break;

                  case _util.OPS.moveText:
                    this.moveText(args[0], args[1]);
                    break;

                  case _util.OPS.setCharSpacing:
                    this.setCharSpacing(args[0]);
                    break;

                  case _util.OPS.setWordSpacing:
                    this.setWordSpacing(args[0]);
                    break;

                  case _util.OPS.setHScale:
                    this.setHScale(args[0]);
                    break;

                  case _util.OPS.setTextMatrix:
                    this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                    break;

                  case _util.OPS.setTextRise:
                    this.setTextRise(args[0]);
                    break;

                  case _util.OPS.setTextRenderingMode:
                    this.setTextRenderingMode(args[0]);
                    break;

                  case _util.OPS.setLineWidth:
                    this.setLineWidth(args[0]);
                    break;

                  case _util.OPS.setLineJoin:
                    this.setLineJoin(args[0]);
                    break;

                  case _util.OPS.setLineCap:
                    this.setLineCap(args[0]);
                    break;

                  case _util.OPS.setMiterLimit:
                    this.setMiterLimit(args[0]);
                    break;

                  case _util.OPS.setFillRGBColor:
                    this.setFillRGBColor(args[0], args[1], args[2]);
                    break;

                  case _util.OPS.setStrokeRGBColor:
                    this.setStrokeRGBColor(args[0], args[1], args[2]);
                    break;

                  case _util.OPS.setStrokeColorN:
                    this.setStrokeColorN(args);
                    break;

                  case _util.OPS.setFillColorN:
                    this.setFillColorN(args);
                    break;

                  case _util.OPS.shadingFill:
                    this.shadingFill(args[0]);
                    break;

                  case _util.OPS.setDash:
                    this.setDash(args[0], args[1]);
                    break;

                  case _util.OPS.setRenderingIntent:
                    this.setRenderingIntent(args[0]);
                    break;

                  case _util.OPS.setFlatness:
                    this.setFlatness(args[0]);
                    break;

                  case _util.OPS.setGState:
                    this.setGState(args[0]);
                    break;

                  case _util.OPS.fill:
                    this.fill();
                    break;

                  case _util.OPS.eoFill:
                    this.eoFill();
                    break;

                  case _util.OPS.stroke:
                    this.stroke();
                    break;

                  case _util.OPS.fillStroke:
                    this.fillStroke();
                    break;

                  case _util.OPS.eoFillStroke:
                    this.eoFillStroke();
                    break;

                  case _util.OPS.clip:
                    this.clip("nonzero");
                    break;

                  case _util.OPS.eoClip:
                    this.clip("evenodd");
                    break;

                  case _util.OPS.paintSolidColorImageMask:
                    this.paintSolidColorImageMask();
                    break;

                  case _util.OPS.paintImageXObject:
                    this.paintImageXObject(args[0]);
                    break;

                  case _util.OPS.paintInlineImageXObject:
                    this.paintInlineImageXObject(args[0]);
                    break;

                  case _util.OPS.paintImageMaskXObject:
                    this.paintImageMaskXObject(args[0]);
                    break;

                  case _util.OPS.paintFormXObjectBegin:
                    this.paintFormXObjectBegin(args[0], args[1]);
                    break;

                  case _util.OPS.paintFormXObjectEnd:
                    this.paintFormXObjectEnd();
                    break;

                  case _util.OPS.closePath:
                    this.closePath();
                    break;

                  case _util.OPS.closeStroke:
                    this.closeStroke();
                    break;

                  case _util.OPS.closeFillStroke:
                    this.closeFillStroke();
                    break;

                  case _util.OPS.closeEOFillStroke:
                    this.closeEOFillStroke();
                    break;

                  case _util.OPS.nextLine:
                    this.nextLine();
                    break;

                  case _util.OPS.transform:
                    this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                    break;

                  case _util.OPS.constructPath:
                    this.constructPath(args[0], args[1]);
                    break;

                  case _util.OPS.endPath:
                    this.endPath();
                    break;

                  case 92:
                    this.group(opTreeElement.items);
                    break;

                  default:
                    (0, _util.warn)("Unimplemented operator ".concat(fn));
                    break;
                }
              }
            }

            setWordSpacing(wordSpacing) {
              this.current.wordSpacing = wordSpacing;
            }

            setCharSpacing(charSpacing) {
              this.current.charSpacing = charSpacing;
            }

            nextLine() {
              this.moveText(0, this.current.leading);
            }

            setTextMatrix(a, b, c, d, e, f) {
              var current = this.current;
              current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
              current.textMatrixScale = Math.hypot(a, b);
              current.x = current.lineX = 0;
              current.y = current.lineY = 0;
              current.xcoords = [];
              current.ycoords = [];
              current.tspan = this.svgFactory.createElement("svg:tspan");
              current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
              current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
              current.tspan.setAttributeNS(null, "y", pf(-current.y));
              current.txtElement = this.svgFactory.createElement("svg:text");
              current.txtElement.appendChild(current.tspan);
            }

            beginText() {
              var current = this.current;
              current.x = current.lineX = 0;
              current.y = current.lineY = 0;
              current.textMatrix = _util.IDENTITY_MATRIX;
              current.lineMatrix = _util.IDENTITY_MATRIX;
              current.textMatrixScale = 1;
              current.tspan = this.svgFactory.createElement("svg:tspan");
              current.txtElement = this.svgFactory.createElement("svg:text");
              current.txtgrp = this.svgFactory.createElement("svg:g");
              current.xcoords = [];
              current.ycoords = [];
            }

            moveText(x, y) {
              var current = this.current;
              current.x = current.lineX += x;
              current.y = current.lineY += y;
              current.xcoords = [];
              current.ycoords = [];
              current.tspan = this.svgFactory.createElement("svg:tspan");
              current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
              current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
              current.tspan.setAttributeNS(null, "y", pf(-current.y));
            }

            showText(glyphs) {
              var current = this.current;
              var font = current.font;
              var fontSize = current.fontSize;

              if (fontSize === 0) {
                return;
              }

              var fontSizeScale = current.fontSizeScale;
              var charSpacing = current.charSpacing;
              var wordSpacing = current.wordSpacing;
              var fontDirection = current.fontDirection;
              var textHScale = current.textHScale * fontDirection;
              var vertical = font.vertical;
              var spacingDir = vertical ? 1 : -1;
              var defaultVMetrics = font.defaultVMetrics;
              var widthAdvanceScale = fontSize * current.fontMatrix[0];
              var x = 0;

              for (var glyph of glyphs) {
                if (glyph === null) {
                  x += fontDirection * wordSpacing;
                  continue;
                } else if (typeof glyph === "number") {
                  x += spacingDir * glyph * fontSize / 1000;
                  continue;
                }

                var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                var character = glyph.fontChar;
                var scaledX = void 0,
                    scaledY = void 0;
                var width = glyph.width;

                if (vertical) {
                  var vx = void 0;
                  var vmetric = glyph.vmetric || defaultVMetrics;
                  vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                  vx = -vx * widthAdvanceScale;
                  var vy = vmetric[2] * widthAdvanceScale;
                  width = vmetric ? -vmetric[0] : width;
                  scaledX = vx / fontSizeScale;
                  scaledY = (x + vy) / fontSizeScale;
                } else {
                  scaledX = x / fontSizeScale;
                  scaledY = 0;
                }

                if (glyph.isInFont || font.missingFile) {
                  current.xcoords.push(current.x + scaledX);

                  if (vertical) {
                    current.ycoords.push(-current.y + scaledY);
                  }

                  current.tspan.textContent += character;
                } else {}

                var charWidth = void 0;

                if (vertical) {
                  charWidth = width * widthAdvanceScale - spacing * fontDirection;
                } else {
                  charWidth = width * widthAdvanceScale + spacing * fontDirection;
                }

                x += charWidth;
              }

              current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));

              if (vertical) {
                current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
              } else {
                current.tspan.setAttributeNS(null, "y", pf(-current.y));
              }

              if (vertical) {
                current.y -= x;
              } else {
                current.x += x * textHScale;
              }

              current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
              current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));

              if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
              }

              if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
              }

              var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

              if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                  current.tspan.setAttributeNS(null, "fill", current.fillColor);
                }

                if (current.fillAlpha < 1) {
                  current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                }
              } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
                current.tspan.setAttributeNS(null, "fill", "transparent");
              } else {
                current.tspan.setAttributeNS(null, "fill", "none");
              }

              if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                var lineWidthScale = 1 / (current.textMatrixScale || 1);

                this._setStrokeAttributes(current.tspan, lineWidthScale);
              }

              var textMatrix = current.textMatrix;

              if (current.textRise !== 0) {
                textMatrix = textMatrix.slice();
                textMatrix[5] += current.textRise;
              }

              current.txtElement.setAttributeNS(null, "transform", "".concat(pm(textMatrix), " scale(").concat(pf(textHScale), ", -1)"));
              current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
              current.txtElement.appendChild(current.tspan);
              current.txtgrp.appendChild(current.txtElement);

              this._ensureTransformGroup().appendChild(current.txtElement);
            }

            setLeadingMoveText(x, y) {
              this.setLeading(-y);
              this.moveText(x, y);
            }

            addFontStyle(fontObj) {
              if (!fontObj.data) {
                throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
              }

              if (!this.cssStyle) {
                this.cssStyle = this.svgFactory.createElement("svg:style");
                this.cssStyle.setAttributeNS(null, "type", "text/css");
                this.defs.appendChild(this.cssStyle);
              }

              var url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
              this.cssStyle.textContent += "@font-face { font-family: \"".concat(fontObj.loadedName, "\";") + " src: url(".concat(url, "); }\n");
            }

            setFont(details) {
              var current = this.current;
              var fontObj = this.commonObjs.get(details[0]);
              var size = details[1];
              current.font = fontObj;

              if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                this.addFontStyle(fontObj);
                this.embeddedFonts[fontObj.loadedName] = fontObj;
              }

              current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
              var bold = "normal";

              if (fontObj.black) {
                bold = "900";
              } else if (fontObj.bold) {
                bold = "bold";
              }

              var italic = fontObj.italic ? "italic" : "normal";

              if (size < 0) {
                size = -size;
                current.fontDirection = -1;
              } else {
                current.fontDirection = 1;
              }

              current.fontSize = size;
              current.fontFamily = fontObj.loadedName;
              current.fontWeight = bold;
              current.fontStyle = italic;
              current.tspan = this.svgFactory.createElement("svg:tspan");
              current.tspan.setAttributeNS(null, "y", pf(-current.y));
              current.xcoords = [];
              current.ycoords = [];
            }

            endText() {
              var _current$txtElement;

              var current = this.current;

              if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {
                current.element = current.txtElement;
                this.clip("nonzero");
                this.endPath();
              }
            }

            setLineWidth(width) {
              if (width > 0) {
                this.current.lineWidth = width;
              }
            }

            setLineCap(style) {
              this.current.lineCap = LINE_CAP_STYLES[style];
            }

            setLineJoin(style) {
              this.current.lineJoin = LINE_JOIN_STYLES[style];
            }

            setMiterLimit(limit) {
              this.current.miterLimit = limit;
            }

            setStrokeAlpha(strokeAlpha) {
              this.current.strokeAlpha = strokeAlpha;
            }

            setStrokeRGBColor(r, g, b) {
              this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
            }

            setFillAlpha(fillAlpha) {
              this.current.fillAlpha = fillAlpha;
            }

            setFillRGBColor(r, g, b) {
              this.current.fillColor = _util.Util.makeHexColor(r, g, b);
              this.current.tspan = this.svgFactory.createElement("svg:tspan");
              this.current.xcoords = [];
              this.current.ycoords = [];
            }

            setStrokeColorN(args) {
              this.current.strokeColor = this._makeColorN_Pattern(args);
            }

            setFillColorN(args) {
              this.current.fillColor = this._makeColorN_Pattern(args);
            }

            shadingFill(args) {
              var width = this.viewport.width;
              var height = this.viewport.height;

              var inv = _util.Util.inverseTransform(this.transformMatrix);

              var bl = _util.Util.applyTransform([0, 0], inv);

              var br = _util.Util.applyTransform([0, height], inv);

              var ul = _util.Util.applyTransform([width, 0], inv);

              var ur = _util.Util.applyTransform([width, height], inv);

              var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
              var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
              var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
              var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
              var rect = this.svgFactory.createElement("svg:rect");
              rect.setAttributeNS(null, "x", x0);
              rect.setAttributeNS(null, "y", y0);
              rect.setAttributeNS(null, "width", x1 - x0);
              rect.setAttributeNS(null, "height", y1 - y0);
              rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));

              if (this.current.fillAlpha < 1) {
                rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
              }

              this._ensureTransformGroup().appendChild(rect);
            }

            _makeColorN_Pattern(args) {
              if (args[0] === "TilingPattern") {
                return this._makeTilingPattern(args);
              }

              return this._makeShadingPattern(args);
            }

            _makeTilingPattern(args) {
              var color = args[1];
              var operatorList = args[2];
              var matrix = args[3] || _util.IDENTITY_MATRIX;
              var [x0, y0, x1, y1] = args[4];
              var xstep = args[5];
              var ystep = args[6];
              var paintType = args[7];
              var tilingId = "shading".concat(shadingCount++);

              var [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);

              var [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);

              var txstep = xstep * xscale;
              var tystep = ystep * yscale;
              var tiling = this.svgFactory.createElement("svg:pattern");
              tiling.setAttributeNS(null, "id", tilingId);
              tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
              tiling.setAttributeNS(null, "width", txstep);
              tiling.setAttributeNS(null, "height", tystep);
              tiling.setAttributeNS(null, "x", "".concat(tx0));
              tiling.setAttributeNS(null, "y", "".concat(ty0));
              var svg = this.svg;
              var transformMatrix = this.transformMatrix;
              var fillColor = this.current.fillColor;
              var strokeColor = this.current.strokeColor;
              var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
              this.svg = bbox;
              this.transformMatrix = matrix;

              if (paintType === 2) {
                var cssColor = _util.Util.makeHexColor(...color);

                this.current.fillColor = cssColor;
                this.current.strokeColor = cssColor;
              }

              this.executeOpTree(this.convertOpList(operatorList));
              this.svg = svg;
              this.transformMatrix = transformMatrix;
              this.current.fillColor = fillColor;
              this.current.strokeColor = strokeColor;
              tiling.appendChild(bbox.childNodes[0]);
              this.defs.appendChild(tiling);
              return "url(#".concat(tilingId, ")");
            }

            _makeShadingPattern(args) {
              if (typeof args === "string") {
                args = this.objs.get(args);
              }

              switch (args[0]) {
                case "RadialAxial":
                  var shadingId = "shading".concat(shadingCount++);
                  var colorStops = args[3];
                  var gradient;

                  switch (args[1]) {
                    case "axial":
                      var point0 = args[4];
                      var point1 = args[5];
                      gradient = this.svgFactory.createElement("svg:linearGradient");
                      gradient.setAttributeNS(null, "id", shadingId);
                      gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                      gradient.setAttributeNS(null, "x1", point0[0]);
                      gradient.setAttributeNS(null, "y1", point0[1]);
                      gradient.setAttributeNS(null, "x2", point1[0]);
                      gradient.setAttributeNS(null, "y2", point1[1]);
                      break;

                    case "radial":
                      var focalPoint = args[4];
                      var circlePoint = args[5];
                      var focalRadius = args[6];
                      var circleRadius = args[7];
                      gradient = this.svgFactory.createElement("svg:radialGradient");
                      gradient.setAttributeNS(null, "id", shadingId);
                      gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                      gradient.setAttributeNS(null, "cx", circlePoint[0]);
                      gradient.setAttributeNS(null, "cy", circlePoint[1]);
                      gradient.setAttributeNS(null, "r", circleRadius);
                      gradient.setAttributeNS(null, "fx", focalPoint[0]);
                      gradient.setAttributeNS(null, "fy", focalPoint[1]);
                      gradient.setAttributeNS(null, "fr", focalRadius);
                      break;

                    default:
                      throw new Error("Unknown RadialAxial type: ".concat(args[1]));
                  }

                  for (var colorStop of colorStops) {
                    var stop = this.svgFactory.createElement("svg:stop");
                    stop.setAttributeNS(null, "offset", colorStop[0]);
                    stop.setAttributeNS(null, "stop-color", colorStop[1]);
                    gradient.appendChild(stop);
                  }

                  this.defs.appendChild(gradient);
                  return "url(#".concat(shadingId, ")");

                case "Mesh":
                  (0, _util.warn)("Unimplemented pattern Mesh");
                  return null;

                case "Dummy":
                  return "hotpink";

                default:
                  throw new Error("Unknown IR type: ".concat(args[0]));
              }
            }

            setDash(dashArray, dashPhase) {
              this.current.dashArray = dashArray;
              this.current.dashPhase = dashPhase;
            }

            constructPath(ops, args) {
              var current = this.current;
              var x = current.x,
                  y = current.y;
              var d = [];
              var j = 0;

              for (var op of ops) {
                switch (op | 0) {
                  case _util.OPS.rectangle:
                    x = args[j++];
                    y = args[j++];
                    var width = args[j++];
                    var height = args[j++];
                    var xw = x + width;
                    var yh = y + height;
                    d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                    break;

                  case _util.OPS.moveTo:
                    x = args[j++];
                    y = args[j++];
                    d.push("M", pf(x), pf(y));
                    break;

                  case _util.OPS.lineTo:
                    x = args[j++];
                    y = args[j++];
                    d.push("L", pf(x), pf(y));
                    break;

                  case _util.OPS.curveTo:
                    x = args[j + 4];
                    y = args[j + 5];
                    d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                    j += 6;
                    break;

                  case _util.OPS.curveTo2:
                    d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                    x = args[j + 2];
                    y = args[j + 3];
                    j += 4;
                    break;

                  case _util.OPS.curveTo3:
                    x = args[j + 2];
                    y = args[j + 3];
                    d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                    j += 4;
                    break;

                  case _util.OPS.closePath:
                    d.push("Z");
                    break;
                }
              }

              d = d.join(" ");

              if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
                d = current.path.getAttributeNS(null, "d") + d;
              } else {
                current.path = this.svgFactory.createElement("svg:path");

                this._ensureTransformGroup().appendChild(current.path);
              }

              current.path.setAttributeNS(null, "d", d);
              current.path.setAttributeNS(null, "fill", "none");
              current.element = current.path;
              current.setCurrentPoint(x, y);
            }

            endPath() {
              var current = this.current;
              current.path = null;

              if (!this.pendingClip) {
                return;
              }

              if (!current.element) {
                this.pendingClip = null;
                return;
              }

              var clipId = "clippath".concat(clipCount++);
              var clipPath = this.svgFactory.createElement("svg:clipPath");
              clipPath.setAttributeNS(null, "id", clipId);
              clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
              var clipElement = current.element.cloneNode(true);

              if (this.pendingClip === "evenodd") {
                clipElement.setAttributeNS(null, "clip-rule", "evenodd");
              } else {
                clipElement.setAttributeNS(null, "clip-rule", "nonzero");
              }

              this.pendingClip = null;
              clipPath.appendChild(clipElement);
              this.defs.appendChild(clipPath);

              if (current.activeClipUrl) {
                current.clipGroup = null;

                for (var prev of this.extraStack) {
                  prev.clipGroup = null;
                }

                clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
              }

              current.activeClipUrl = "url(#".concat(clipId, ")");
              this.tgrp = null;
            }

            clip(type) {
              this.pendingClip = type;
            }

            closePath() {
              var current = this.current;

              if (current.path) {
                var d = "".concat(current.path.getAttributeNS(null, "d"), "Z");
                current.path.setAttributeNS(null, "d", d);
              }
            }

            setLeading(leading) {
              this.current.leading = -leading;
            }

            setTextRise(textRise) {
              this.current.textRise = textRise;
            }

            setTextRenderingMode(textRenderingMode) {
              this.current.textRenderingMode = textRenderingMode;
            }

            setHScale(scale) {
              this.current.textHScale = scale / 100;
            }

            setRenderingIntent(intent) {}

            setFlatness(flatness) {}

            setGState(states) {
              for (var [key, value] of states) {
                switch (key) {
                  case "LW":
                    this.setLineWidth(value);
                    break;

                  case "LC":
                    this.setLineCap(value);
                    break;

                  case "LJ":
                    this.setLineJoin(value);
                    break;

                  case "ML":
                    this.setMiterLimit(value);
                    break;

                  case "D":
                    this.setDash(value[0], value[1]);
                    break;

                  case "RI":
                    this.setRenderingIntent(value);
                    break;

                  case "FL":
                    this.setFlatness(value);
                    break;

                  case "Font":
                    this.setFont(value);
                    break;

                  case "CA":
                    this.setStrokeAlpha(value);
                    break;

                  case "ca":
                    this.setFillAlpha(value);
                    break;

                  default:
                    (0, _util.warn)("Unimplemented graphic state operator ".concat(key));
                    break;
                }
              }
            }

            fill() {
              var current = this.current;

              if (current.element) {
                current.element.setAttributeNS(null, "fill", current.fillColor);
                current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                this.endPath();
              }
            }

            stroke() {
              var current = this.current;

              if (current.element) {
                this._setStrokeAttributes(current.element);

                current.element.setAttributeNS(null, "fill", "none");
                this.endPath();
              }
            }

            _setStrokeAttributes(element) {
              var lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
              var current = this.current;
              var dashArray = current.dashArray;

              if (lineWidthScale !== 1 && dashArray.length > 0) {
                dashArray = dashArray.map(function (value) {
                  return lineWidthScale * value;
                });
              }

              element.setAttributeNS(null, "stroke", current.strokeColor);
              element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
              element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
              element.setAttributeNS(null, "stroke-linecap", current.lineCap);
              element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
              element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
              element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
              element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
            }

            eoFill() {
              if (this.current.element) {
                this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
              }

              this.fill();
            }

            fillStroke() {
              this.stroke();
              this.fill();
            }

            eoFillStroke() {
              if (this.current.element) {
                this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
              }

              this.fillStroke();
            }

            closeStroke() {
              this.closePath();
              this.stroke();
            }

            closeFillStroke() {
              this.closePath();
              this.fillStroke();
            }

            closeEOFillStroke() {
              this.closePath();
              this.eoFillStroke();
            }

            paintSolidColorImageMask() {
              var rect = this.svgFactory.createElement("svg:rect");
              rect.setAttributeNS(null, "x", "0");
              rect.setAttributeNS(null, "y", "0");
              rect.setAttributeNS(null, "width", "1px");
              rect.setAttributeNS(null, "height", "1px");
              rect.setAttributeNS(null, "fill", this.current.fillColor);

              this._ensureTransformGroup().appendChild(rect);
            }

            paintImageXObject(objId) {
              var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

              if (!imgData) {
                (0, _util.warn)("Dependent image with object ID ".concat(objId, " is not ready yet"));
                return;
              }

              this.paintInlineImageXObject(imgData);
            }

            paintInlineImageXObject(imgData, mask) {
              var width = imgData.width;
              var height = imgData.height;
              var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
              var cliprect = this.svgFactory.createElement("svg:rect");
              cliprect.setAttributeNS(null, "x", "0");
              cliprect.setAttributeNS(null, "y", "0");
              cliprect.setAttributeNS(null, "width", pf(width));
              cliprect.setAttributeNS(null, "height", pf(height));
              this.current.element = cliprect;
              this.clip("nonzero");
              var imgEl = this.svgFactory.createElement("svg:image");
              imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
              imgEl.setAttributeNS(null, "x", "0");
              imgEl.setAttributeNS(null, "y", pf(-height));
              imgEl.setAttributeNS(null, "width", pf(width) + "px");
              imgEl.setAttributeNS(null, "height", pf(height) + "px");
              imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / width), " ").concat(pf(-1 / height), ")"));

              if (mask) {
                mask.appendChild(imgEl);
              } else {
                this._ensureTransformGroup().appendChild(imgEl);
              }
            }

            paintImageMaskXObject(imgData) {
              var current = this.current;
              var width = imgData.width;
              var height = imgData.height;
              var fillColor = current.fillColor;
              current.maskId = "mask".concat(maskCount++);
              var mask = this.svgFactory.createElement("svg:mask");
              mask.setAttributeNS(null, "id", current.maskId);
              var rect = this.svgFactory.createElement("svg:rect");
              rect.setAttributeNS(null, "x", "0");
              rect.setAttributeNS(null, "y", "0");
              rect.setAttributeNS(null, "width", pf(width));
              rect.setAttributeNS(null, "height", pf(height));
              rect.setAttributeNS(null, "fill", fillColor);
              rect.setAttributeNS(null, "mask", "url(#".concat(current.maskId, ")"));
              this.defs.appendChild(mask);

              this._ensureTransformGroup().appendChild(rect);

              this.paintInlineImageXObject(imgData, mask);
            }

            paintFormXObjectBegin(matrix, bbox) {
              if (Array.isArray(matrix) && matrix.length === 6) {
                this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
              }

              if (bbox) {
                var width = bbox[2] - bbox[0];
                var height = bbox[3] - bbox[1];
                var cliprect = this.svgFactory.createElement("svg:rect");
                cliprect.setAttributeNS(null, "x", bbox[0]);
                cliprect.setAttributeNS(null, "y", bbox[1]);
                cliprect.setAttributeNS(null, "width", pf(width));
                cliprect.setAttributeNS(null, "height", pf(height));
                this.current.element = cliprect;
                this.clip("nonzero");
                this.endPath();
              }
            }

            paintFormXObjectEnd() {}

            _initialize(viewport) {
              var svg = this.svgFactory.create(viewport.width, viewport.height);
              var definitions = this.svgFactory.createElement("svg:defs");
              svg.appendChild(definitions);
              this.defs = definitions;
              var rootGroup = this.svgFactory.createElement("svg:g");
              rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
              svg.appendChild(rootGroup);
              this.svg = rootGroup;
              return svg;
            }

            _ensureClipGroup() {
              if (!this.current.clipGroup) {
                var clipGroup = this.svgFactory.createElement("svg:g");
                clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                this.svg.appendChild(clipGroup);
                this.current.clipGroup = clipGroup;
              }

              return this.current.clipGroup;
            }

            _ensureTransformGroup() {
              if (!this.tgrp) {
                this.tgrp = this.svgFactory.createElement("svg:g");
                this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));

                if (this.current.activeClipUrl) {
                  this._ensureClipGroup().appendChild(this.tgrp);
                } else {
                  this.svg.appendChild(this.tgrp);
                }
              }

              return this.tgrp;
            }

          };
        }
        /***/
      },
      /* 25 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFNodeStream = void 0;

        var _util = __w_pdfjs_require__(1);

        var _network_utils = __w_pdfjs_require__(26);

        ;

        var fs = __webpack_require__(/*! fs */ "?47a5");

        var http = __webpack_require__(/*! http */ "?3676");

        var https = __webpack_require__(/*! https */ "?dac2");

        var url = __webpack_require__(/*! url */ "?f7a6");

        var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

        function parseUrl(sourceUrl) {
          var parsedUrl = url.parse(sourceUrl);

          if (parsedUrl.protocol === "file:" || parsedUrl.host) {
            return parsedUrl;
          }

          if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
            return url.parse("file:///".concat(sourceUrl));
          }

          if (!parsedUrl.host) {
            parsedUrl.protocol = "file:";
          }

          return parsedUrl;
        }

        class PDFNodeStream {
          constructor(source) {
            this.source = source;
            this.url = parseUrl(source.url);
            this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
            this.isFsUrl = this.url.protocol === "file:";
            this.httpHeaders = this.isHttp && source.httpHeaders || {};
            this._fullRequestReader = null;
            this._rangeRequestReaders = [];
          }

          get _progressiveDataLength() {
            var _this$_fullRequestRea3, _this$_fullRequestRea4;

            return (_this$_fullRequestRea3 = (_this$_fullRequestRea4 = this._fullRequestReader) === null || _this$_fullRequestRea4 === void 0 ? void 0 : _this$_fullRequestRea4._loaded) !== null && _this$_fullRequestRea3 !== void 0 ? _this$_fullRequestRea3 : 0;
          }

          getFullReader() {
            (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
            this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
            return this._fullRequestReader;
          }

          getRangeReader(start, end) {
            if (end <= this._progressiveDataLength) {
              return null;
            }

            var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

            this._rangeRequestReaders.push(rangeReader);

            return rangeReader;
          }

          cancelAllRequests(reason) {
            if (this._fullRequestReader) {
              this._fullRequestReader.cancel(reason);
            }

            for (var reader of this._rangeRequestReaders.slice(0)) {
              reader.cancel(reason);
            }
          }

        }

        exports.PDFNodeStream = PDFNodeStream;

        class BaseFullReader {
          constructor(stream) {
            this._url = stream.url;
            this._done = false;
            this._storedError = null;
            this.onProgress = null;
            var source = stream.source;
            this._contentLength = source.length;
            this._loaded = 0;
            this._filename = null;
            this._disableRange = source.disableRange || false;
            this._rangeChunkSize = source.rangeChunkSize;

            if (!this._rangeChunkSize && !this._disableRange) {
              this._disableRange = true;
            }

            this._isStreamingSupported = !source.disableStream;
            this._isRangeSupported = !source.disableRange;
            this._readableStream = null;
            this._readCapability = (0, _util.createPromiseCapability)();
            this._headersCapability = (0, _util.createPromiseCapability)();
          }

          get headersReady() {
            return this._headersCapability.promise;
          }

          get filename() {
            return this._filename;
          }

          get contentLength() {
            return this._contentLength;
          }

          get isRangeSupported() {
            return this._isRangeSupported;
          }

          get isStreamingSupported() {
            return this._isStreamingSupported;
          }

          read() {
            var _this15 = this;

            return _asyncToGenerator(function* () {
              yield _this15._readCapability.promise;

              if (_this15._done) {
                return {
                  value: undefined,
                  done: true
                };
              }

              if (_this15._storedError) {
                throw _this15._storedError;
              }

              var chunk = _this15._readableStream.read();

              if (chunk === null) {
                _this15._readCapability = (0, _util.createPromiseCapability)();
                return _this15.read();
              }

              _this15._loaded += chunk.length;

              if (_this15.onProgress) {
                _this15.onProgress({
                  loaded: _this15._loaded,
                  total: _this15._contentLength
                });
              }

              var buffer = new Uint8Array(chunk).buffer;
              return {
                value: buffer,
                done: false
              };
            })();
          }

          cancel(reason) {
            if (!this._readableStream) {
              this._error(reason);

              return;
            }

            this._readableStream.destroy(reason);
          }

          _error(reason) {
            this._storedError = reason;

            this._readCapability.resolve();
          }

          _setReadableStream(readableStream) {
            this._readableStream = readableStream;
            readableStream.on("readable", () => {
              this._readCapability.resolve();
            });
            readableStream.on("end", () => {
              readableStream.destroy();
              this._done = true;

              this._readCapability.resolve();
            });
            readableStream.on("error", reason => {
              this._error(reason);
            });

            if (!this._isStreamingSupported && this._isRangeSupported) {
              this._error(new _util.AbortException("streaming is disabled"));
            }

            if (this._storedError) {
              this._readableStream.destroy(this._storedError);
            }
          }

        }

        class BaseRangeReader {
          constructor(stream) {
            this._url = stream.url;
            this._done = false;
            this._storedError = null;
            this.onProgress = null;
            this._loaded = 0;
            this._readableStream = null;
            this._readCapability = (0, _util.createPromiseCapability)();
            var source = stream.source;
            this._isStreamingSupported = !source.disableStream;
          }

          get isStreamingSupported() {
            return this._isStreamingSupported;
          }

          read() {
            var _this16 = this;

            return _asyncToGenerator(function* () {
              yield _this16._readCapability.promise;

              if (_this16._done) {
                return {
                  value: undefined,
                  done: true
                };
              }

              if (_this16._storedError) {
                throw _this16._storedError;
              }

              var chunk = _this16._readableStream.read();

              if (chunk === null) {
                _this16._readCapability = (0, _util.createPromiseCapability)();
                return _this16.read();
              }

              _this16._loaded += chunk.length;

              if (_this16.onProgress) {
                _this16.onProgress({
                  loaded: _this16._loaded
                });
              }

              var buffer = new Uint8Array(chunk).buffer;
              return {
                value: buffer,
                done: false
              };
            })();
          }

          cancel(reason) {
            if (!this._readableStream) {
              this._error(reason);

              return;
            }

            this._readableStream.destroy(reason);
          }

          _error(reason) {
            this._storedError = reason;

            this._readCapability.resolve();
          }

          _setReadableStream(readableStream) {
            this._readableStream = readableStream;
            readableStream.on("readable", () => {
              this._readCapability.resolve();
            });
            readableStream.on("end", () => {
              readableStream.destroy();
              this._done = true;

              this._readCapability.resolve();
            });
            readableStream.on("error", reason => {
              this._error(reason);
            });

            if (this._storedError) {
              this._readableStream.destroy(this._storedError);
            }
          }

        }

        function createRequestOptions(parsedUrl, headers) {
          return {
            protocol: parsedUrl.protocol,
            auth: parsedUrl.auth,
            host: parsedUrl.hostname,
            port: parsedUrl.port,
            path: parsedUrl.path,
            method: "GET",
            headers
          };
        }

        class PDFNodeStreamFullReader extends BaseFullReader {
          constructor(stream) {
            super(stream);

            var handleResponse = response => {
              if (response.statusCode === 404) {
                var error = new _util.MissingPDFException("Missing PDF \"".concat(this._url, "\"."));
                this._storedError = error;

                this._headersCapability.reject(error);

                return;
              }

              this._headersCapability.resolve();

              this._setReadableStream(response);

              var getResponseHeader = name => {
                return this._readableStream.headers[name.toLowerCase()];
              };

              var {
                allowRangeRequests,
                suggestedLength
              } = (0, _network_utils.validateRangeRequestCapabilities)({
                getResponseHeader,
                isHttp: stream.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              this._isRangeSupported = allowRangeRequests;
              this._contentLength = suggestedLength || this._contentLength;
              this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
            };

            this._request = null;

            if (this._url.protocol === "http:") {
              this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
            } else {
              this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
            }

            this._request.on("error", reason => {
              this._storedError = reason;

              this._headersCapability.reject(reason);
            });

            this._request.end();
          }

        }

        class PDFNodeStreamRangeReader extends BaseRangeReader {
          constructor(stream, start, end) {
            super(stream);
            this._httpHeaders = {};

            for (var property in stream.httpHeaders) {
              var value = stream.httpHeaders[property];

              if (typeof value === "undefined") {
                continue;
              }

              this._httpHeaders[property] = value;
            }

            this._httpHeaders.Range = "bytes=".concat(start, "-").concat(end - 1);

            var handleResponse = response => {
              if (response.statusCode === 404) {
                var error = new _util.MissingPDFException("Missing PDF \"".concat(this._url, "\"."));
                this._storedError = error;
                return;
              }

              this._setReadableStream(response);
            };

            this._request = null;

            if (this._url.protocol === "http:") {
              this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
            } else {
              this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
            }

            this._request.on("error", reason => {
              this._storedError = reason;
            });

            this._request.end();
          }

        }

        class PDFNodeStreamFsFullReader extends BaseFullReader {
          constructor(stream) {
            super(stream);
            var path = decodeURIComponent(this._url.path);

            if (fileUriRegex.test(this._url.href)) {
              path = path.replace(/^\//, "");
            }

            fs.lstat(path, (error, stat) => {
              if (error) {
                if (error.code === "ENOENT") {
                  error = new _util.MissingPDFException("Missing PDF \"".concat(path, "\"."));
                }

                this._storedError = error;

                this._headersCapability.reject(error);

                return;
              }

              this._contentLength = stat.size;

              this._setReadableStream(fs.createReadStream(path));

              this._headersCapability.resolve();
            });
          }

        }

        class PDFNodeStreamFsRangeReader extends BaseRangeReader {
          constructor(stream, start, end) {
            super(stream);
            var path = decodeURIComponent(this._url.path);

            if (fileUriRegex.test(this._url.href)) {
              path = path.replace(/^\//, "");
            }

            this._setReadableStream(fs.createReadStream(path, {
              start,
              end: end - 1
            }));
          }

        }
        /***/

      },
      /* 26 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.createResponseStatusError = createResponseStatusError;
        exports.extractFilenameFromHeader = extractFilenameFromHeader;
        exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
        exports.validateResponseStatus = validateResponseStatus;

        var _util = __w_pdfjs_require__(1);

        var _content_disposition = __w_pdfjs_require__(27);

        var _display_utils = __w_pdfjs_require__(5);

        function validateRangeRequestCapabilities(_ref40) {
          var {
            getResponseHeader,
            isHttp,
            rangeChunkSize,
            disableRange
          } = _ref40;
          var returnValues = {
            allowRangeRequests: false,
            suggestedLength: undefined
          };
          var length = parseInt(getResponseHeader("Content-Length"), 10);

          if (!Number.isInteger(length)) {
            return returnValues;
          }

          returnValues.suggestedLength = length;

          if (length <= 2 * rangeChunkSize) {
            return returnValues;
          }

          if (disableRange || !isHttp) {
            return returnValues;
          }

          if (getResponseHeader("Accept-Ranges") !== "bytes") {
            return returnValues;
          }

          var contentEncoding = getResponseHeader("Content-Encoding") || "identity";

          if (contentEncoding !== "identity") {
            return returnValues;
          }

          returnValues.allowRangeRequests = true;
          return returnValues;
        }

        function extractFilenameFromHeader(getResponseHeader) {
          var contentDisposition = getResponseHeader("Content-Disposition");

          if (contentDisposition) {
            var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

            if (filename.includes("%")) {
              try {
                filename = decodeURIComponent(filename);
              } catch (ex) {}
            }

            if ((0, _display_utils.isPdfFile)(filename)) {
              return filename;
            }
          }

          return null;
        }

        function createResponseStatusError(status, url) {
          if (status === 404 || status === 0 && url.startsWith("file:")) {
            return new _util.MissingPDFException('Missing PDF "' + url + '".');
          }

          return new _util.UnexpectedResponseException("Unexpected server response (".concat(status, ") while retrieving PDF \"").concat(url, "\"."), status);
        }

        function validateResponseStatus(status) {
          return status === 200 || status === 206;
        }
        /***/

      },
      /* 27 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

        var _util = __w_pdfjs_require__(1);

        function getFilenameFromContentDispositionHeader(contentDisposition) {
          var needsEncodingFixup = true;
          var tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);

          if (tmp) {
            tmp = tmp[1];
            var filename = rfc2616unquote(tmp);
            filename = unescape(filename);
            filename = rfc5987decode(filename);
            filename = rfc2047decode(filename);
            return fixupEncoding(filename);
          }

          tmp = rfc2231getparam(contentDisposition);

          if (tmp) {
            var _filename = rfc2047decode(tmp);

            return fixupEncoding(_filename);
          }

          tmp = toParamRegExp("filename", "i").exec(contentDisposition);

          if (tmp) {
            tmp = tmp[1];

            var _filename2 = rfc2616unquote(tmp);

            _filename2 = rfc2047decode(_filename2);
            return fixupEncoding(_filename2);
          }

          function toParamRegExp(attributePattern, flags) {
            return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
          }

          function textdecode(encoding, value) {
            if (encoding) {
              if (!/^[\x00-\xFF]+$/.test(value)) {
                return value;
              }

              try {
                var decoder = new TextDecoder(encoding, {
                  fatal: true
                });
                var buffer = (0, _util.stringToBytes)(value);
                value = decoder.decode(buffer);
                needsEncodingFixup = false;
              } catch (e) {}
            }

            return value;
          }

          function fixupEncoding(value) {
            if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
              value = textdecode("utf-8", value);

              if (needsEncodingFixup) {
                value = textdecode("iso-8859-1", value);
              }
            }

            return value;
          }

          function rfc2231getparam(contentDispositionStr) {
            var matches = [];
            var match;
            var iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");

            while ((match = iter.exec(contentDispositionStr)) !== null) {
              var [, n, quot, part] = match;
              n = parseInt(n, 10);

              if (n in matches) {
                if (n === 0) {
                  break;
                }

                continue;
              }

              matches[n] = [quot, part];
            }

            var parts = [];

            for (var _n2 = 0; _n2 < matches.length; ++_n2) {
              if (!(_n2 in matches)) {
                break;
              }

              var [_quot, _part] = matches[_n2];
              _part = rfc2616unquote(_part);

              if (_quot) {
                _part = unescape(_part);

                if (_n2 === 0) {
                  _part = rfc5987decode(_part);
                }
              }

              parts.push(_part);
            }

            return parts.join("");
          }

          function rfc2616unquote(value) {
            if (value.startsWith('"')) {
              var parts = value.slice(1).split('\\"');

              for (var i = 0; i < parts.length; ++i) {
                var quotindex = parts[i].indexOf('"');

                if (quotindex !== -1) {
                  parts[i] = parts[i].slice(0, quotindex);
                  parts.length = i + 1;
                }

                parts[i] = parts[i].replace(/\\(.)/g, "$1");
              }

              value = parts.join('"');
            }

            return value;
          }

          function rfc5987decode(extvalue) {
            var encodingend = extvalue.indexOf("'");

            if (encodingend === -1) {
              return extvalue;
            }

            var encoding = extvalue.slice(0, encodingend);
            var langvalue = extvalue.slice(encodingend + 1);
            var value = langvalue.replace(/^[^']*'/, "");
            return textdecode(encoding, value);
          }

          function rfc2047decode(value) {
            if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
              return value;
            }

            return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
              if (encoding === "q" || encoding === "Q") {
                text = text.replace(/_/g, " ");
                text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {
                  return String.fromCharCode(parseInt(hex, 16));
                });
                return textdecode(charset, text);
              }

              try {
                text = atob(text);
              } catch (e) {}

              return textdecode(charset, text);
            });
          }

          return "";
        }
        /***/

      },
      /* 28 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFNetworkStream = void 0;

        var _util = __w_pdfjs_require__(1);

        var _network_utils = __w_pdfjs_require__(26);

        ;
        var OK_RESPONSE = 200;
        var PARTIAL_CONTENT_RESPONSE = 206;

        function getArrayBuffer(xhr) {
          var data = xhr.response;

          if (typeof data !== "string") {
            return data;
          }

          var array = (0, _util.stringToBytes)(data);
          return array.buffer;
        }

        class NetworkManager {
          constructor(url) {
            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            this.url = url;
            this.isHttp = /^https?:/i.test(url);
            this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);
            this.withCredentials = args.withCredentials || false;

            this.getXhr = args.getXhr || function NetworkManager_getXhr() {
              return new XMLHttpRequest();
            };

            this.currXhrId = 0;
            this.pendingRequests = Object.create(null);
          }

          requestRange(begin, end, listeners) {
            var args = {
              begin,
              end
            };

            for (var prop in listeners) {
              args[prop] = listeners[prop];
            }

            return this.request(args);
          }

          requestFull(listeners) {
            return this.request(listeners);
          }

          request(args) {
            var xhr = this.getXhr();
            var xhrId = this.currXhrId++;
            var pendingRequest = this.pendingRequests[xhrId] = {
              xhr
            };
            xhr.open("GET", this.url);
            xhr.withCredentials = this.withCredentials;

            for (var property in this.httpHeaders) {
              var value = this.httpHeaders[property];

              if (typeof value === "undefined") {
                continue;
              }

              xhr.setRequestHeader(property, value);
            }

            if (this.isHttp && "begin" in args && "end" in args) {
              xhr.setRequestHeader("Range", "bytes=".concat(args.begin, "-").concat(args.end - 1));
              pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
            } else {
              pendingRequest.expectedStatus = OK_RESPONSE;
            }

            xhr.responseType = "arraybuffer";

            if (args.onError) {
              xhr.onerror = function (evt) {
                args.onError(xhr.status);
              };
            }

            xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
            xhr.onprogress = this.onProgress.bind(this, xhrId);
            pendingRequest.onHeadersReceived = args.onHeadersReceived;
            pendingRequest.onDone = args.onDone;
            pendingRequest.onError = args.onError;
            pendingRequest.onProgress = args.onProgress;
            xhr.send(null);
            return xhrId;
          }

          onProgress(xhrId, evt) {
            var _pendingRequest$onPro;

            var pendingRequest = this.pendingRequests[xhrId];

            if (!pendingRequest) {
              return;
            }

            (_pendingRequest$onPro = pendingRequest.onProgress) === null || _pendingRequest$onPro === void 0 ? void 0 : _pendingRequest$onPro.call(pendingRequest, evt);
          }

          onStateChange(xhrId, evt) {
            var pendingRequest = this.pendingRequests[xhrId];

            if (!pendingRequest) {
              return;
            }

            var xhr = pendingRequest.xhr;

            if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
              pendingRequest.onHeadersReceived();
              delete pendingRequest.onHeadersReceived;
            }

            if (xhr.readyState !== 4) {
              return;
            }

            if (!(xhrId in this.pendingRequests)) {
              return;
            }

            delete this.pendingRequests[xhrId];

            if (xhr.status === 0 && this.isHttp) {
              var _pendingRequest$onErr;

              (_pendingRequest$onErr = pendingRequest.onError) === null || _pendingRequest$onErr === void 0 ? void 0 : _pendingRequest$onErr.call(pendingRequest, xhr.status);
              return;
            }

            var xhrStatus = xhr.status || OK_RESPONSE;
            var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

            if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
              var _pendingRequest$onErr2;

              (_pendingRequest$onErr2 = pendingRequest.onError) === null || _pendingRequest$onErr2 === void 0 ? void 0 : _pendingRequest$onErr2.call(pendingRequest, xhr.status);
              return;
            }

            var chunk = getArrayBuffer(xhr);

            if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
              var rangeHeader = xhr.getResponseHeader("Content-Range");
              var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
              pendingRequest.onDone({
                begin: parseInt(matches[1], 10),
                chunk
              });
            } else if (chunk) {
              pendingRequest.onDone({
                begin: 0,
                chunk
              });
            } else {
              var _pendingRequest$onErr3;

              (_pendingRequest$onErr3 = pendingRequest.onError) === null || _pendingRequest$onErr3 === void 0 ? void 0 : _pendingRequest$onErr3.call(pendingRequest, xhr.status);
            }
          }

          getRequestXhr(xhrId) {
            return this.pendingRequests[xhrId].xhr;
          }

          isPendingRequest(xhrId) {
            return xhrId in this.pendingRequests;
          }

          abortRequest(xhrId) {
            var xhr = this.pendingRequests[xhrId].xhr;
            delete this.pendingRequests[xhrId];
            xhr.abort();
          }

        }

        class PDFNetworkStream {
          constructor(source) {
            this._source = source;
            this._manager = new NetworkManager(source.url, {
              httpHeaders: source.httpHeaders,
              withCredentials: source.withCredentials
            });
            this._rangeChunkSize = source.rangeChunkSize;
            this._fullRequestReader = null;
            this._rangeRequestReaders = [];
          }

          _onRangeRequestReaderClosed(reader) {
            var i = this._rangeRequestReaders.indexOf(reader);

            if (i >= 0) {
              this._rangeRequestReaders.splice(i, 1);
            }
          }

          getFullReader() {
            (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
            this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
            return this._fullRequestReader;
          }

          getRangeReader(begin, end) {
            var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
            reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

            this._rangeRequestReaders.push(reader);

            return reader;
          }

          cancelAllRequests(reason) {
            var _this$_fullRequestRea5;

            (_this$_fullRequestRea5 = this._fullRequestReader) === null || _this$_fullRequestRea5 === void 0 ? void 0 : _this$_fullRequestRea5.cancel(reason);

            for (var reader of this._rangeRequestReaders.slice(0)) {
              reader.cancel(reason);
            }
          }

        }

        exports.PDFNetworkStream = PDFNetworkStream;

        class PDFNetworkStreamFullRequestReader {
          constructor(manager, source) {
            this._manager = manager;
            var args = {
              onHeadersReceived: this._onHeadersReceived.bind(this),
              onDone: this._onDone.bind(this),
              onError: this._onError.bind(this),
              onProgress: this._onProgress.bind(this)
            };
            this._url = source.url;
            this._fullRequestId = manager.requestFull(args);
            this._headersReceivedCapability = (0, _util.createPromiseCapability)();
            this._disableRange = source.disableRange || false;
            this._contentLength = source.length;
            this._rangeChunkSize = source.rangeChunkSize;

            if (!this._rangeChunkSize && !this._disableRange) {
              this._disableRange = true;
            }

            this._isStreamingSupported = false;
            this._isRangeSupported = false;
            this._cachedChunks = [];
            this._requests = [];
            this._done = false;
            this._storedError = undefined;
            this._filename = null;
            this.onProgress = null;
          }

          _onHeadersReceived() {
            var fullRequestXhrId = this._fullRequestId;

            var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

            var getResponseHeader = name => {
              return fullRequestXhr.getResponseHeader(name);
            };

            var {
              allowRangeRequests,
              suggestedLength
            } = (0, _network_utils.validateRangeRequestCapabilities)({
              getResponseHeader,
              isHttp: this._manager.isHttp,
              rangeChunkSize: this._rangeChunkSize,
              disableRange: this._disableRange
            });

            if (allowRangeRequests) {
              this._isRangeSupported = true;
            }

            this._contentLength = suggestedLength || this._contentLength;
            this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

            if (this._isRangeSupported) {
              this._manager.abortRequest(fullRequestXhrId);
            }

            this._headersReceivedCapability.resolve();
          }

          _onDone(data) {
            if (data) {
              if (this._requests.length > 0) {
                var requestCapability = this._requests.shift();

                requestCapability.resolve({
                  value: data.chunk,
                  done: false
                });
              } else {
                this._cachedChunks.push(data.chunk);
              }
            }

            this._done = true;

            if (this._cachedChunks.length > 0) {
              return;
            }

            for (var _requestCapability2 of this._requests) {
              _requestCapability2.resolve({
                value: undefined,
                done: true
              });
            }

            this._requests.length = 0;
          }

          _onError(status) {
            this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

            this._headersReceivedCapability.reject(this._storedError);

            for (var requestCapability of this._requests) {
              requestCapability.reject(this._storedError);
            }

            this._requests.length = 0;
            this._cachedChunks.length = 0;
          }

          _onProgress(evt) {
            var _this$onProgress;

            (_this$onProgress = this.onProgress) === null || _this$onProgress === void 0 ? void 0 : _this$onProgress.call(this, {
              loaded: evt.loaded,
              total: evt.lengthComputable ? evt.total : this._contentLength
            });
          }

          get filename() {
            return this._filename;
          }

          get isRangeSupported() {
            return this._isRangeSupported;
          }

          get isStreamingSupported() {
            return this._isStreamingSupported;
          }

          get contentLength() {
            return this._contentLength;
          }

          get headersReady() {
            return this._headersReceivedCapability.promise;
          }

          read() {
            var _this17 = this;

            return _asyncToGenerator(function* () {
              if (_this17._storedError) {
                throw _this17._storedError;
              }

              if (_this17._cachedChunks.length > 0) {
                var chunk = _this17._cachedChunks.shift();

                return {
                  value: chunk,
                  done: false
                };
              }

              if (_this17._done) {
                return {
                  value: undefined,
                  done: true
                };
              }

              var requestCapability = (0, _util.createPromiseCapability)();

              _this17._requests.push(requestCapability);

              return requestCapability.promise;
            })();
          }

          cancel(reason) {
            this._done = true;

            this._headersReceivedCapability.reject(reason);

            for (var requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }

            this._requests.length = 0;

            if (this._manager.isPendingRequest(this._fullRequestId)) {
              this._manager.abortRequest(this._fullRequestId);
            }

            this._fullRequestReader = null;
          }

        }

        class PDFNetworkStreamRangeRequestReader {
          constructor(manager, begin, end) {
            this._manager = manager;
            var args = {
              onDone: this._onDone.bind(this),
              onError: this._onError.bind(this),
              onProgress: this._onProgress.bind(this)
            };
            this._url = manager.url;
            this._requestId = manager.requestRange(begin, end, args);
            this._requests = [];
            this._queuedChunk = null;
            this._done = false;
            this._storedError = undefined;
            this.onProgress = null;
            this.onClosed = null;
          }

          _close() {
            var _this$onClosed;

            (_this$onClosed = this.onClosed) === null || _this$onClosed === void 0 ? void 0 : _this$onClosed.call(this, this);
          }

          _onDone(data) {
            var chunk = data.chunk;

            if (this._requests.length > 0) {
              var requestCapability = this._requests.shift();

              requestCapability.resolve({
                value: chunk,
                done: false
              });
            } else {
              this._queuedChunk = chunk;
            }

            this._done = true;

            for (var _requestCapability4 of this._requests) {
              _requestCapability4.resolve({
                value: undefined,
                done: true
              });
            }

            this._requests.length = 0;

            this._close();
          }

          _onError(status) {
            this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

            for (var requestCapability of this._requests) {
              requestCapability.reject(this._storedError);
            }

            this._requests.length = 0;
            this._queuedChunk = null;
          }

          _onProgress(evt) {
            if (!this.isStreamingSupported) {
              var _this$onProgress2;

              (_this$onProgress2 = this.onProgress) === null || _this$onProgress2 === void 0 ? void 0 : _this$onProgress2.call(this, {
                loaded: evt.loaded
              });
            }
          }

          get isStreamingSupported() {
            return false;
          }

          read() {
            var _this18 = this;

            return _asyncToGenerator(function* () {
              if (_this18._storedError) {
                throw _this18._storedError;
              }

              if (_this18._queuedChunk !== null) {
                var chunk = _this18._queuedChunk;
                _this18._queuedChunk = null;
                return {
                  value: chunk,
                  done: false
                };
              }

              if (_this18._done) {
                return {
                  value: undefined,
                  done: true
                };
              }

              var requestCapability = (0, _util.createPromiseCapability)();

              _this18._requests.push(requestCapability);

              return requestCapability.promise;
            })();
          }

          cancel(reason) {
            this._done = true;

            for (var requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }

            this._requests.length = 0;

            if (this._manager.isPendingRequest(this._requestId)) {
              this._manager.abortRequest(this._requestId);
            }

            this._close();
          }

        }
        /***/

      },
      /* 29 */

      /***/
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFFetchStream = void 0;

        var _util = __w_pdfjs_require__(1);

        var _network_utils = __w_pdfjs_require__(26);

        ;

        function createFetchOptions(headers, withCredentials, abortController) {
          return {
            method: "GET",
            headers,
            signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
            mode: "cors",
            credentials: withCredentials ? "include" : "same-origin",
            redirect: "follow"
          };
        }

        function createHeaders(httpHeaders) {
          var headers = new Headers();

          for (var property in httpHeaders) {
            var value = httpHeaders[property];

            if (typeof value === "undefined") {
              continue;
            }

            headers.append(property, value);
          }

          return headers;
        }

        class PDFFetchStream {
          constructor(source) {
            this.source = source;
            this.isHttp = /^https?:/i.test(source.url);
            this.httpHeaders = this.isHttp && source.httpHeaders || {};
            this._fullRequestReader = null;
            this._rangeRequestReaders = [];
          }

          get _progressiveDataLength() {
            var _this$_fullRequestRea6, _this$_fullRequestRea7;

            return (_this$_fullRequestRea6 = (_this$_fullRequestRea7 = this._fullRequestReader) === null || _this$_fullRequestRea7 === void 0 ? void 0 : _this$_fullRequestRea7._loaded) !== null && _this$_fullRequestRea6 !== void 0 ? _this$_fullRequestRea6 : 0;
          }

          getFullReader() {
            (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
            this._fullRequestReader = new PDFFetchStreamReader(this);
            return this._fullRequestReader;
          }

          getRangeReader(begin, end) {
            if (end <= this._progressiveDataLength) {
              return null;
            }

            var reader = new PDFFetchStreamRangeReader(this, begin, end);

            this._rangeRequestReaders.push(reader);

            return reader;
          }

          cancelAllRequests(reason) {
            if (this._fullRequestReader) {
              this._fullRequestReader.cancel(reason);
            }

            for (var reader of this._rangeRequestReaders.slice(0)) {
              reader.cancel(reason);
            }
          }

        }

        exports.PDFFetchStream = PDFFetchStream;

        class PDFFetchStreamReader {
          constructor(stream) {
            this._stream = stream;
            this._reader = null;
            this._loaded = 0;
            this._filename = null;
            var source = stream.source;
            this._withCredentials = source.withCredentials || false;
            this._contentLength = source.length;
            this._headersCapability = (0, _util.createPromiseCapability)();
            this._disableRange = source.disableRange || false;
            this._rangeChunkSize = source.rangeChunkSize;

            if (!this._rangeChunkSize && !this._disableRange) {
              this._disableRange = true;
            }

            if (typeof AbortController !== "undefined") {
              this._abortController = new AbortController();
            }

            this._isStreamingSupported = !source.disableStream;
            this._isRangeSupported = !source.disableRange;
            this._headers = createHeaders(this._stream.httpHeaders);
            var url = source.url;
            fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
              if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                throw (0, _network_utils.createResponseStatusError)(response.status, url);
              }

              this._reader = response.body.getReader();

              this._headersCapability.resolve();

              var getResponseHeader = name => {
                return response.headers.get(name);
              };

              var {
                allowRangeRequests,
                suggestedLength
              } = (0, _network_utils.validateRangeRequestCapabilities)({
                getResponseHeader,
                isHttp: this._stream.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              this._isRangeSupported = allowRangeRequests;
              this._contentLength = suggestedLength || this._contentLength;
              this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

              if (!this._isStreamingSupported && this._isRangeSupported) {
                this.cancel(new _util.AbortException("Streaming is disabled."));
              }
            }).catch(this._headersCapability.reject);
            this.onProgress = null;
          }

          get headersReady() {
            return this._headersCapability.promise;
          }

          get filename() {
            return this._filename;
          }

          get contentLength() {
            return this._contentLength;
          }

          get isRangeSupported() {
            return this._isRangeSupported;
          }

          get isStreamingSupported() {
            return this._isStreamingSupported;
          }

          read() {
            var _this19 = this;

            return _asyncToGenerator(function* () {
              yield _this19._headersCapability.promise;
              var {
                value,
                done
              } = yield _this19._reader.read();

              if (done) {
                return {
                  value,
                  done
                };
              }

              _this19._loaded += value.byteLength;

              if (_this19.onProgress) {
                _this19.onProgress({
                  loaded: _this19._loaded,
                  total: _this19._contentLength
                });
              }

              var buffer = new Uint8Array(value).buffer;
              return {
                value: buffer,
                done: false
              };
            })();
          }

          cancel(reason) {
            if (this._reader) {
              this._reader.cancel(reason);
            }

            if (this._abortController) {
              this._abortController.abort();
            }
          }

        }

        class PDFFetchStreamRangeReader {
          constructor(stream, begin, end) {
            this._stream = stream;
            this._reader = null;
            this._loaded = 0;
            var source = stream.source;
            this._withCredentials = source.withCredentials || false;
            this._readCapability = (0, _util.createPromiseCapability)();
            this._isStreamingSupported = !source.disableStream;

            if (typeof AbortController !== "undefined") {
              this._abortController = new AbortController();
            }

            this._headers = createHeaders(this._stream.httpHeaders);

            this._headers.append("Range", "bytes=".concat(begin, "-").concat(end - 1));

            var url = source.url;
            fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
              if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                throw (0, _network_utils.createResponseStatusError)(response.status, url);
              }

              this._readCapability.resolve();

              this._reader = response.body.getReader();
            }).catch(this._readCapability.reject);
            this.onProgress = null;
          }

          get isStreamingSupported() {
            return this._isStreamingSupported;
          }

          read() {
            var _this20 = this;

            return _asyncToGenerator(function* () {
              yield _this20._readCapability.promise;
              var {
                value,
                done
              } = yield _this20._reader.read();

              if (done) {
                return {
                  value,
                  done
                };
              }

              _this20._loaded += value.byteLength;

              if (_this20.onProgress) {
                _this20.onProgress({
                  loaded: _this20._loaded
                });
              }

              var buffer = new Uint8Array(value).buffer;
              return {
                value: buffer,
                done: false
              };
            })();
          }

          cancel(reason) {
            if (this._reader) {
              this._reader.cancel(reason);
            }

            if (this._abortController) {
              this._abortController.abort();
            }
          }

        }
        /***/

      }
      /******/
      ];
      /************************************************************************/

      /******/
      // The module cache

      /******/

      var __webpack_module_cache__ = {};
      /******/

      /******/
      // The require function

      /******/

      function __w_pdfjs_require__(moduleId) {
        /******/
        // Check if module is in cache

        /******/
        var cachedModule = __webpack_module_cache__[moduleId];
        /******/

        if (cachedModule !== undefined) {
          /******/
          return cachedModule.exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed

          /******/
          // no module.loaded needed

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
        /******/

        /******/
        // Return the exports of the module

        /******/


        return module.exports;
        /******/
      }
      /******/

      /************************************************************************/


      var __nested_webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.

      (() => {
        var exports = __nested_webpack_exports__;
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        Object.defineProperty(exports, "AnnotationLayer", {
          enumerable: true,
          get: function get() {
            return _annotation_layer.AnnotationLayer;
          }
        });
        Object.defineProperty(exports, "AnnotationMode", {
          enumerable: true,
          get: function get() {
            return _util.AnnotationMode;
          }
        });
        Object.defineProperty(exports, "CMapCompressionType", {
          enumerable: true,
          get: function get() {
            return _util.CMapCompressionType;
          }
        });
        Object.defineProperty(exports, "GlobalWorkerOptions", {
          enumerable: true,
          get: function get() {
            return _worker_options.GlobalWorkerOptions;
          }
        });
        Object.defineProperty(exports, "InvalidPDFException", {
          enumerable: true,
          get: function get() {
            return _util.InvalidPDFException;
          }
        });
        Object.defineProperty(exports, "LoopbackPort", {
          enumerable: true,
          get: function get() {
            return _api.LoopbackPort;
          }
        });
        Object.defineProperty(exports, "MissingPDFException", {
          enumerable: true,
          get: function get() {
            return _util.MissingPDFException;
          }
        });
        Object.defineProperty(exports, "OPS", {
          enumerable: true,
          get: function get() {
            return _util.OPS;
          }
        });
        Object.defineProperty(exports, "PDFDataRangeTransport", {
          enumerable: true,
          get: function get() {
            return _api.PDFDataRangeTransport;
          }
        });
        Object.defineProperty(exports, "PDFDateString", {
          enumerable: true,
          get: function get() {
            return _display_utils.PDFDateString;
          }
        });
        Object.defineProperty(exports, "PDFWorker", {
          enumerable: true,
          get: function get() {
            return _api.PDFWorker;
          }
        });
        Object.defineProperty(exports, "PasswordResponses", {
          enumerable: true,
          get: function get() {
            return _util.PasswordResponses;
          }
        });
        Object.defineProperty(exports, "PermissionFlag", {
          enumerable: true,
          get: function get() {
            return _util.PermissionFlag;
          }
        });
        Object.defineProperty(exports, "PixelsPerInch", {
          enumerable: true,
          get: function get() {
            return _display_utils.PixelsPerInch;
          }
        });
        Object.defineProperty(exports, "RenderingCancelledException", {
          enumerable: true,
          get: function get() {
            return _display_utils.RenderingCancelledException;
          }
        });
        Object.defineProperty(exports, "SVGGraphics", {
          enumerable: true,
          get: function get() {
            return _svg.SVGGraphics;
          }
        });
        Object.defineProperty(exports, "UNSUPPORTED_FEATURES", {
          enumerable: true,
          get: function get() {
            return _util.UNSUPPORTED_FEATURES;
          }
        });
        Object.defineProperty(exports, "UnexpectedResponseException", {
          enumerable: true,
          get: function get() {
            return _util.UnexpectedResponseException;
          }
        });
        Object.defineProperty(exports, "Util", {
          enumerable: true,
          get: function get() {
            return _util.Util;
          }
        });
        Object.defineProperty(exports, "VerbosityLevel", {
          enumerable: true,
          get: function get() {
            return _util.VerbosityLevel;
          }
        });
        Object.defineProperty(exports, "XfaLayer", {
          enumerable: true,
          get: function get() {
            return _xfa_layer.XfaLayer;
          }
        });
        Object.defineProperty(exports, "build", {
          enumerable: true,
          get: function get() {
            return _api.build;
          }
        });
        Object.defineProperty(exports, "createPromiseCapability", {
          enumerable: true,
          get: function get() {
            return _util.createPromiseCapability;
          }
        });
        Object.defineProperty(exports, "createValidAbsoluteUrl", {
          enumerable: true,
          get: function get() {
            return _util.createValidAbsoluteUrl;
          }
        });
        Object.defineProperty(exports, "getDocument", {
          enumerable: true,
          get: function get() {
            return _api.getDocument;
          }
        });
        Object.defineProperty(exports, "getFilenameFromUrl", {
          enumerable: true,
          get: function get() {
            return _display_utils.getFilenameFromUrl;
          }
        });
        Object.defineProperty(exports, "getPdfFilenameFromUrl", {
          enumerable: true,
          get: function get() {
            return _display_utils.getPdfFilenameFromUrl;
          }
        });
        Object.defineProperty(exports, "getXfaPageViewport", {
          enumerable: true,
          get: function get() {
            return _display_utils.getXfaPageViewport;
          }
        });
        Object.defineProperty(exports, "isPdfFile", {
          enumerable: true,
          get: function get() {
            return _display_utils.isPdfFile;
          }
        });
        Object.defineProperty(exports, "loadScript", {
          enumerable: true,
          get: function get() {
            return _display_utils.loadScript;
          }
        });
        Object.defineProperty(exports, "renderTextLayer", {
          enumerable: true,
          get: function get() {
            return _text_layer.renderTextLayer;
          }
        });
        Object.defineProperty(exports, "shadow", {
          enumerable: true,
          get: function get() {
            return _util.shadow;
          }
        });
        Object.defineProperty(exports, "version", {
          enumerable: true,
          get: function get() {
            return _api.version;
          }
        });

        var _util = __w_pdfjs_require__(1);

        var _api = __w_pdfjs_require__(4);

        var _display_utils = __w_pdfjs_require__(5);

        var _annotation_layer = __w_pdfjs_require__(20);

        var _worker_options = __w_pdfjs_require__(13);

        var _is_node = __w_pdfjs_require__(3);

        var _text_layer = __w_pdfjs_require__(23);

        var _svg = __w_pdfjs_require__(24);

        var _xfa_layer = __w_pdfjs_require__(22);

        var pdfjsVersion = '2.14.0';
        var pdfjsBuild = '904344f';
        {
          if (_is_node.isNodeJS) {
            var {
              PDFNodeStream
            } = __w_pdfjs_require__(25);

            (0, _api.setPDFNetworkStreamFactory)(params => {
              return new PDFNodeStream(params);
            });
          } else {
            var {
              PDFNetworkStream
            } = __w_pdfjs_require__(28);

            var {
              PDFFetchStream
            } = __w_pdfjs_require__(29);

            (0, _api.setPDFNetworkStreamFactory)(params => {
              if ((0, _display_utils.isValidFetchUrl)(params.url)) {
                return new PDFFetchStream(params);
              }

              return new PDFNetworkStream(params);
            });
          }
        }
      })();
      /******/


      return __nested_webpack_exports__;
      /******/
    })()
  );
});

/***/ }),

/***/ "./src/pdf_js/lib/web/event_utils.js":
/*!*******************************************!*\
  !*** ./src/pdf_js/lib/web/event_utils.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WaitOnType = exports.EventBus = exports.AutomationEventBus = void 0;
exports.waitOnEventOrTimeout = waitOnEventOrTimeout;
var WaitOnType = {
  EVENT: "event",
  TIMEOUT: "timeout"
};
exports.WaitOnType = WaitOnType;

function waitOnEventOrTimeout(_ref) {
  var {
    target,
    name,
    delay = 0
  } = _ref;
  return new Promise(function (resolve, reject) {
    if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
      throw new Error("waitOnEventOrTimeout - invalid parameters.");
    }

    function handler(type) {
      if (target instanceof EventBus) {
        target._off(name, eventHandler);
      } else {
        target.removeEventListener(name, eventHandler);
      }

      if (timeout) {
        clearTimeout(timeout);
      }

      resolve(type);
    }

    var eventHandler = handler.bind(null, WaitOnType.EVENT);

    if (target instanceof EventBus) {
      target._on(name, eventHandler);
    } else {
      target.addEventListener(name, eventHandler);
    }

    var timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
    var timeout = setTimeout(timeoutHandler, delay);
  });
}

class EventBus {
  constructor() {
    this._listeners = Object.create(null);
  }

  on(eventName, listener) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    this._on(eventName, listener, {
      external: true,
      once: options === null || options === void 0 ? void 0 : options.once
    });
  }

  off(eventName, listener) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    this._off(eventName, listener, {
      external: true,
      once: options === null || options === void 0 ? void 0 : options.once
    });
  }

  dispatch(eventName, data) {
    var eventListeners = this._listeners[eventName];

    if (!eventListeners || eventListeners.length === 0) {
      return;
    }

    var externalListeners;

    for (var {
      listener,
      external,
      once
    } of eventListeners.slice(0)) {
      if (once) {
        this._off(eventName, listener);
      }

      if (external) {
        (externalListeners || (externalListeners = [])).push(listener);
        continue;
      }

      listener(data);
    }

    if (externalListeners) {
      for (var _listener2 of externalListeners) {
        _listener2(data);
      }

      externalListeners = null;
    }
  }

  _on(eventName, listener) {
    var _this$_listeners;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var eventListeners = (_this$_listeners = this._listeners)[eventName] || (_this$_listeners[eventName] = []);
    eventListeners.push({
      listener,
      external: (options === null || options === void 0 ? void 0 : options.external) === true,
      once: (options === null || options === void 0 ? void 0 : options.once) === true
    });
  }

  _off(eventName, listener) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var eventListeners = this._listeners[eventName];

    if (!eventListeners) {
      return;
    }

    for (var i = 0, ii = eventListeners.length; i < ii; i++) {
      if (eventListeners[i].listener === listener) {
        eventListeners.splice(i, 1);
        return;
      }
    }
  }

}

exports.EventBus = EventBus;

class AutomationEventBus extends EventBus {
  dispatch(eventName, data) {
    throw new Error("Not implemented: AutomationEventBus.dispatch");
  }

}

exports.AutomationEventBus = AutomationEventBus;

/***/ }),

/***/ "./src/pdf_js/lib/web/pdf_link_service.js":
/*!************************************************!*\
  !*** ./src/pdf_js/lib/web/pdf_link_service.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }

function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SimpleLinkService = exports.PDFLinkService = exports.LinkTarget = void 0;

var _ui_utils = __webpack_require__(/*! ./ui_utils.js */ "./src/pdf_js/lib/web/ui_utils.js");

var DEFAULT_LINK_REL = "noopener noreferrer nofollow";
var LinkTarget = {
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
};
exports.LinkTarget = LinkTarget;

function addLinkAttributes(link) {
  var {
    url,
    target,
    rel,
    enabled = true
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!url || typeof url !== "string") {
    throw new Error('A valid "url" parameter must provided.');
  }

  var urlNullRemoved = (0, _ui_utils.removeNullCharacters)(url);

  if (enabled) {
    link.href = link.title = urlNullRemoved;
  } else {
    link.href = "";
    link.title = "Disabled: ".concat(urlNullRemoved);

    link.onclick = () => {
      return false;
    };
  }

  var targetStr = "";

  switch (target) {
    case LinkTarget.NONE:
      break;

    case LinkTarget.SELF:
      targetStr = "_self";
      break;

    case LinkTarget.BLANK:
      targetStr = "_blank";
      break;

    case LinkTarget.PARENT:
      targetStr = "_parent";
      break;

    case LinkTarget.TOP:
      targetStr = "_top";
      break;
  }

  link.target = targetStr;
  link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
}

var _pagesRefCache = /*#__PURE__*/new WeakMap();

var _goToDestinationHelper = /*#__PURE__*/new WeakSet();

class PDFLinkService {
  constructor() {
    var {
      eventBus,
      externalLinkTarget = null,
      externalLinkRel = null,
      ignoreDestinationZoom = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classPrivateMethodInitSpec(this, _goToDestinationHelper);

    _classPrivateFieldInitSpec(this, _pagesRefCache, {
      writable: true,
      value: new Map()
    });

    this.eventBus = eventBus;
    this.externalLinkTarget = externalLinkTarget;
    this.externalLinkRel = externalLinkRel;
    this.externalLinkEnabled = true;
    this._ignoreDestinationZoom = ignoreDestinationZoom;
    this.baseUrl = null;
    this.pdfDocument = null;
    this.pdfViewer = null;
    this.pdfHistory = null;
  }

  setDocument(pdfDocument) {
    var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    this.baseUrl = baseUrl;
    this.pdfDocument = pdfDocument;

    _classPrivateFieldGet(this, _pagesRefCache).clear();
  }

  setViewer(pdfViewer) {
    this.pdfViewer = pdfViewer;
  }

  setHistory(pdfHistory) {
    this.pdfHistory = pdfHistory;
  }

  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }

  get page() {
    return this.pdfViewer.currentPageNumber;
  }

  set page(value) {
    this.pdfViewer.currentPageNumber = value;
  }

  get rotation() {
    return this.pdfViewer.pagesRotation;
  }

  set rotation(value) {
    this.pdfViewer.pagesRotation = value;
  }

  goToDestination(dest) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (!_this.pdfDocument) {
        return;
      }

      var namedDest, explicitDest;

      if (typeof dest === "string") {
        namedDest = dest;
        explicitDest = yield _this.pdfDocument.getDestination(dest);
      } else {
        namedDest = null;
        explicitDest = yield dest;
      }

      if (!Array.isArray(explicitDest)) {
        console.error("PDFLinkService.goToDestination: \"".concat(explicitDest, "\" is not ") + "a valid destination array, for dest=\"".concat(dest, "\"."));
        return;
      }

      _classPrivateMethodGet(_this, _goToDestinationHelper, _goToDestinationHelper2).call(_this, dest, namedDest, explicitDest);
    })();
  }

  goToPage(val) {
    if (!this.pdfDocument) {
      return;
    }

    var pageNumber = typeof val === "string" && this.pdfViewer.pageLabelToPageNumber(val) || val | 0;

    if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
      console.error("PDFLinkService.goToPage: \"".concat(val, "\" is not a valid page."));
      return;
    }

    if (this.pdfHistory) {
      this.pdfHistory.pushCurrentPosition();
      this.pdfHistory.pushPage(pageNumber);
    }

    this.pdfViewer.scrollPageIntoView({
      pageNumber
    });
  }

  addLinkAttributes(link, url) {
    var newWindow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    addLinkAttributes(link, {
      url,
      target: newWindow ? LinkTarget.BLANK : this.externalLinkTarget,
      rel: this.externalLinkRel,
      enabled: this.externalLinkEnabled
    });
  }

  getDestinationHash(dest) {
    if (typeof dest === "string") {
      if (dest.length > 0) {
        return this.getAnchorUrl("#" + escape(dest));
      }
    } else if (Array.isArray(dest)) {
      var str = JSON.stringify(dest);

      if (str.length > 0) {
        return this.getAnchorUrl("#" + escape(str));
      }
    }

    return this.getAnchorUrl("");
  }

  getAnchorUrl(anchor) {
    return (this.baseUrl || "") + anchor;
  }

  setHash(hash) {
    if (!this.pdfDocument) {
      return;
    }

    var pageNumber, dest;

    if (hash.includes("=")) {
      var params = (0, _ui_utils.parseQueryString)(hash);

      if (params.has("search")) {
        this.eventBus.dispatch("findfromurlhash", {
          source: this,
          query: params.get("search").replace(/"/g, ""),
          phraseSearch: params.get("phrase") === "true"
        });
      }

      if (params.has("page")) {
        pageNumber = params.get("page") | 0 || 1;
      }

      if (params.has("zoom")) {
        var zoomArgs = params.get("zoom").split(",");
        var zoomArg = zoomArgs[0];
        var zoomArgNumber = parseFloat(zoomArg);

        if (!zoomArg.includes("Fit")) {
          dest = [null, {
            name: "XYZ"
          }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
        } else {
          if (zoomArg === "Fit" || zoomArg === "FitB") {
            dest = [null, {
              name: zoomArg
            }];
          } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
            dest = [null, {
              name: zoomArg
            }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
          } else if (zoomArg === "FitR") {
            if (zoomArgs.length !== 5) {
              console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
            } else {
              dest = [null, {
                name: zoomArg
              }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
            }
          } else {
            console.error("PDFLinkService.setHash: \"".concat(zoomArg, "\" is not a valid zoom value."));
          }
        }
      }

      if (dest) {
        this.pdfViewer.scrollPageIntoView({
          pageNumber: pageNumber || this.page,
          destArray: dest,
          allowNegativeOffset: true
        });
      } else if (pageNumber) {
        this.page = pageNumber;
      }

      if (params.has("pagemode")) {
        this.eventBus.dispatch("pagemode", {
          source: this,
          mode: params.get("pagemode")
        });
      }

      if (params.has("nameddest")) {
        this.goToDestination(params.get("nameddest"));
      }
    } else {
      dest = unescape(hash);

      try {
        dest = JSON.parse(dest);

        if (!Array.isArray(dest)) {
          dest = dest.toString();
        }
      } catch (ex) {}

      if (typeof dest === "string" || _classStaticPrivateMethodGet(PDFLinkService, PDFLinkService, _isValidExplicitDestination).call(PDFLinkService, dest)) {
        this.goToDestination(dest);
        return;
      }

      console.error("PDFLinkService.setHash: \"".concat(unescape(hash), "\" is not a valid destination."));
    }
  }

  executeNamedAction(action) {
    var _this$pdfHistory, _this$pdfHistory2;

    switch (action) {
      case "GoBack":
        (_this$pdfHistory = this.pdfHistory) === null || _this$pdfHistory === void 0 ? void 0 : _this$pdfHistory.back();
        break;

      case "GoForward":
        (_this$pdfHistory2 = this.pdfHistory) === null || _this$pdfHistory2 === void 0 ? void 0 : _this$pdfHistory2.forward();
        break;

      case "NextPage":
        this.pdfViewer.nextPage();
        break;

      case "PrevPage":
        this.pdfViewer.previousPage();
        break;

      case "LastPage":
        this.page = this.pagesCount;
        break;

      case "FirstPage":
        this.page = 1;
        break;

      default:
        break;
    }

    this.eventBus.dispatch("namedaction", {
      source: this,
      action
    });
  }

  cachePageRef(pageNum, pageRef) {
    if (!pageRef) {
      return;
    }

    var refStr = pageRef.gen === 0 ? "".concat(pageRef.num, "R") : "".concat(pageRef.num, "R").concat(pageRef.gen);

    _classPrivateFieldGet(this, _pagesRefCache).set(refStr, pageNum);
  }

  _cachedPageNumber(pageRef) {
    if (!pageRef) {
      return null;
    }

    var refStr = pageRef.gen === 0 ? "".concat(pageRef.num, "R") : "".concat(pageRef.num, "R").concat(pageRef.gen);
    return _classPrivateFieldGet(this, _pagesRefCache).get(refStr) || null;
  }

  isPageVisible(pageNumber) {
    return this.pdfViewer.isPageVisible(pageNumber);
  }

  isPageCached(pageNumber) {
    return this.pdfViewer.isPageCached(pageNumber);
  }

}

function _goToDestinationHelper2(rawDest) {
  var namedDest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var explicitDest = arguments.length > 2 ? arguments[2] : undefined;
  var destRef = explicitDest[0];
  var pageNumber;

  if (typeof destRef === "object" && destRef !== null) {
    pageNumber = this._cachedPageNumber(destRef);

    if (!pageNumber) {
      this.pdfDocument.getPageIndex(destRef).then(pageIndex => {
        this.cachePageRef(pageIndex + 1, destRef);

        _classPrivateMethodGet(this, _goToDestinationHelper, _goToDestinationHelper2).call(this, rawDest, namedDest, explicitDest);
      }).catch(() => {
        console.error("PDFLinkService.#goToDestinationHelper: \"".concat(destRef, "\" is not ") + "a valid page reference, for dest=\"".concat(rawDest, "\"."));
      });
      return;
    }
  } else if (Number.isInteger(destRef)) {
    pageNumber = destRef + 1;
  } else {
    console.error("PDFLinkService.#goToDestinationHelper: \"".concat(destRef, "\" is not ") + "a valid destination reference, for dest=\"".concat(rawDest, "\"."));
    return;
  }

  if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
    console.error("PDFLinkService.#goToDestinationHelper: \"".concat(pageNumber, "\" is not ") + "a valid page number, for dest=\"".concat(rawDest, "\"."));
    return;
  }

  if (this.pdfHistory) {
    this.pdfHistory.pushCurrentPosition();
    this.pdfHistory.push({
      namedDest,
      explicitDest,
      pageNumber
    });
  }

  this.pdfViewer.scrollPageIntoView({
    pageNumber,
    destArray: explicitDest,
    ignoreDestinationZoom: this._ignoreDestinationZoom
  });
}

function _isValidExplicitDestination(dest) {
  if (!Array.isArray(dest)) {
    return false;
  }

  var destLength = dest.length;

  if (destLength < 2) {
    return false;
  }

  var page = dest[0];

  if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
    return false;
  }

  var zoom = dest[1];

  if (!(typeof zoom === "object" && typeof zoom.name === "string")) {
    return false;
  }

  var allowNull = true;

  switch (zoom.name) {
    case "XYZ":
      if (destLength !== 5) {
        return false;
      }

      break;

    case "Fit":
    case "FitB":
      return destLength === 2;

    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (destLength !== 3) {
        return false;
      }

      break;

    case "FitR":
      if (destLength !== 6) {
        return false;
      }

      allowNull = false;
      break;

    default:
      return false;
  }

  for (var i = 2; i < destLength; i++) {
    var param = dest[i];

    if (!(typeof param === "number" || allowNull && param === null)) {
      return false;
    }
  }

  return true;
}

exports.PDFLinkService = PDFLinkService;

class SimpleLinkService {
  constructor() {
    this.externalLinkEnabled = true;
  }

  get pagesCount() {
    return 0;
  }

  get page() {
    return 0;
  }

  set page(value) {}

  get rotation() {
    return 0;
  }

  set rotation(value) {}

  goToDestination(dest) {
    return _asyncToGenerator(function* () {})();
  }

  goToPage(val) {}

  addLinkAttributes(link, url) {
    var newWindow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    addLinkAttributes(link, {
      url,
      enabled: this.externalLinkEnabled
    });
  }

  getDestinationHash(dest) {
    return "#";
  }

  getAnchorUrl(hash) {
    return "#";
  }

  setHash(hash) {}

  executeNamedAction(action) {}

  cachePageRef(pageNum, pageRef) {}

  isPageVisible(pageNumber) {
    return true;
  }

  isPageCached(pageNumber) {
    return true;
  }

}

exports.SimpleLinkService = SimpleLinkService;

/***/ }),

/***/ "./src/pdf_js/lib/web/ui_utils.js":
/*!****************************************!*\
  !*** ./src/pdf_js/lib/web/ui_utils.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */


function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.animationStarted = exports.VERTICAL_PADDING = exports.UNKNOWN_SCALE = exports.TextLayerMode = exports.SpreadMode = exports.SidebarView = exports.ScrollMode = exports.SCROLLBAR_PADDING = exports.RenderingStates = exports.RendererType = exports.ProgressBar = exports.PresentationModeState = exports.OutputScale = exports.MIN_SCALE = exports.MAX_SCALE = exports.MAX_AUTO_SCALE = exports.DEFAULT_SCALE_VALUE = exports.DEFAULT_SCALE_DELTA = exports.DEFAULT_SCALE = exports.AutoPrintRegExp = void 0;
exports.apiPageLayoutToViewerModes = apiPageLayoutToViewerModes;
exports.apiPageModeToSidebarView = apiPageModeToSidebarView;
exports.approximateFraction = approximateFraction;
exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
exports.binarySearchFirstItem = binarySearchFirstItem;
exports.getActiveOrFocusedElement = getActiveOrFocusedElement;
exports.getPageSizeInches = getPageSizeInches;
exports.getVisibleElements = getVisibleElements;
exports.isPortraitOrientation = isPortraitOrientation;
exports.isValidRotation = isValidRotation;
exports.isValidScrollMode = isValidScrollMode;
exports.isValidSpreadMode = isValidSpreadMode;
exports.noContextMenuHandler = noContextMenuHandler;
exports.normalizeWheelEventDelta = normalizeWheelEventDelta;
exports.normalizeWheelEventDirection = normalizeWheelEventDirection;
exports.parseQueryString = parseQueryString;
exports.removeNullCharacters = removeNullCharacters;
exports.roundToDivide = roundToDivide;
exports.scrollIntoView = scrollIntoView;
exports.watchScroll = watchScroll;
var DEFAULT_SCALE_VALUE = "auto";
exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
var DEFAULT_SCALE = 1.0;
exports.DEFAULT_SCALE = DEFAULT_SCALE;
var DEFAULT_SCALE_DELTA = 1.1;
exports.DEFAULT_SCALE_DELTA = DEFAULT_SCALE_DELTA;
var MIN_SCALE = 0.1;
exports.MIN_SCALE = MIN_SCALE;
var MAX_SCALE = 10.0;
exports.MAX_SCALE = MAX_SCALE;
var UNKNOWN_SCALE = 0;
exports.UNKNOWN_SCALE = UNKNOWN_SCALE;
var MAX_AUTO_SCALE = 1.25;
exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
var SCROLLBAR_PADDING = 40;
exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
var VERTICAL_PADDING = 5;
exports.VERTICAL_PADDING = VERTICAL_PADDING;
var RenderingStates = {
  INITIAL: 0,
  RUNNING: 1,
  PAUSED: 2,
  FINISHED: 3
};
exports.RenderingStates = RenderingStates;
var PresentationModeState = {
  UNKNOWN: 0,
  NORMAL: 1,
  CHANGING: 2,
  FULLSCREEN: 3
};
exports.PresentationModeState = PresentationModeState;
var SidebarView = {
  UNKNOWN: -1,
  NONE: 0,
  THUMBS: 1,
  OUTLINE: 2,
  ATTACHMENTS: 3,
  LAYERS: 4
};
exports.SidebarView = SidebarView;
var RendererType = {
  CANVAS: "canvas",
  SVG: "svg"
};
exports.RendererType = RendererType;
var TextLayerMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_ENHANCE: 2
};
exports.TextLayerMode = TextLayerMode;
var ScrollMode = {
  UNKNOWN: -1,
  VERTICAL: 0,
  HORIZONTAL: 1,
  WRAPPED: 2,
  PAGE: 3
};
exports.ScrollMode = ScrollMode;
var SpreadMode = {
  UNKNOWN: -1,
  NONE: 0,
  ODD: 1,
  EVEN: 2
};
exports.SpreadMode = SpreadMode;
var AutoPrintRegExp = /\bprint\s*\(/;
exports.AutoPrintRegExp = AutoPrintRegExp;

class OutputScale {
  constructor() {
    var pixelRatio = window.devicePixelRatio || 1;
    this.sx = pixelRatio;
    this.sy = pixelRatio;
  }

  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }

}

exports.OutputScale = OutputScale;

function scrollIntoView(element, spot) {
  var scrollMatches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var parent = element.offsetParent;

  if (!parent) {
    console.error("offsetParent is not set -- cannot scroll");
    return;
  }

  var offsetY = element.offsetTop + element.clientTop;
  var offsetX = element.offsetLeft + element.clientLeft;

  while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || scrollMatches && (parent.classList.contains("markedContent") || getComputedStyle(parent).overflow === "hidden")) {
    offsetY += parent.offsetTop;
    offsetX += parent.offsetLeft;
    parent = parent.offsetParent;

    if (!parent) {
      return;
    }
  }

  if (spot) {
    if (spot.top !== undefined) {
      offsetY += spot.top;
    }

    if (spot.left !== undefined) {
      offsetX += spot.left;
      parent.scrollLeft = offsetX;
    }
  }

  parent.scrollTop = offsetY;
}

function watchScroll(viewAreaElement, callback) {
  var debounceScroll = function debounceScroll(evt) {
    if (rAF) {
      return;
    }

    rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
      rAF = null;
      var currentX = viewAreaElement.scrollLeft;
      var lastX = state.lastX;

      if (currentX !== lastX) {
        state.right = currentX > lastX;
      }

      state.lastX = currentX;
      var currentY = viewAreaElement.scrollTop;
      var lastY = state.lastY;

      if (currentY !== lastY) {
        state.down = currentY > lastY;
      }

      state.lastY = currentY;
      callback(state);
    });
  };

  var state = {
    right: true,
    down: true,
    lastX: viewAreaElement.scrollLeft,
    lastY: viewAreaElement.scrollTop,
    _eventHandler: debounceScroll
  };
  var rAF = null;
  viewAreaElement.addEventListener("scroll", debounceScroll, true);
  return state;
}

function parseQueryString(query) {
  var params = new Map();

  for (var [key, value] of new URLSearchParams(query)) {
    params.set(key.toLowerCase(), value);
  }

  return params;
}

var NullCharactersRegExp = /\x00/g;
var InvisibleCharactersRegExp = /[\x01-\x1F]/g;

function removeNullCharacters(str) {
  var replaceInvisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (typeof str !== "string") {
    console.error("The argument must be a string.");
    return str;
  }

  if (replaceInvisible) {
    str = str.replace(InvisibleCharactersRegExp, " ");
  }

  return str.replace(NullCharactersRegExp, "");
}

function binarySearchFirstItem(items, condition) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var minIndex = start;
  var maxIndex = items.length - 1;

  if (maxIndex < 0 || !condition(items[maxIndex])) {
    return items.length;
  }

  if (condition(items[minIndex])) {
    return minIndex;
  }

  while (minIndex < maxIndex) {
    var currentIndex = minIndex + maxIndex >> 1;
    var currentItem = items[currentIndex];

    if (condition(currentItem)) {
      maxIndex = currentIndex;
    } else {
      minIndex = currentIndex + 1;
    }
  }

  return minIndex;
}

function approximateFraction(x) {
  if (Math.floor(x) === x) {
    return [x, 1];
  }

  var xinv = 1 / x;
  var limit = 8;

  if (xinv > limit) {
    return [1, limit];
  } else if (Math.floor(xinv) === xinv) {
    return [1, xinv];
  }

  var x_ = x > 1 ? xinv : x;
  var a = 0,
      b = 1,
      c = 1,
      d = 1;

  while (true) {
    var p = a + c,
        q = b + d;

    if (q > limit) {
      break;
    }

    if (x_ <= p / q) {
      c = p;
      d = q;
    } else {
      a = p;
      b = q;
    }
  }

  var result;

  if (x_ - a / b < c / d - x_) {
    result = x_ === x ? [a, b] : [b, a];
  } else {
    result = x_ === x ? [c, d] : [d, c];
  }

  return result;
}

function roundToDivide(x, div) {
  var r = x % div;
  return r === 0 ? x : Math.round(x - r + div);
}

function getPageSizeInches(_ref) {
  var {
    view,
    userUnit,
    rotate
  } = _ref;
  var [x1, y1, x2, y2] = view;
  var changeOrientation = rotate % 180 !== 0;
  var width = (x2 - x1) / 72 * userUnit;
  var height = (y2 - y1) / 72 * userUnit;
  return {
    width: changeOrientation ? height : width,
    height: changeOrientation ? width : height
  };
}

function backtrackBeforeAllVisibleElements(index, views, top) {
  if (index < 2) {
    return index;
  }

  var elt = views[index].div;
  var pageTop = elt.offsetTop + elt.clientTop;

  if (pageTop >= top) {
    elt = views[index - 1].div;
    pageTop = elt.offsetTop + elt.clientTop;
  }

  for (var i = index - 2; i >= 0; --i) {
    elt = views[i].div;

    if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
      break;
    }

    index = i;
  }

  return index;
}

function getVisibleElements(_ref2) {
  var {
    scrollEl,
    views,
    sortByVisibility = false,
    horizontal = false,
    rtl = false
  } = _ref2;
  var top = scrollEl.scrollTop,
      bottom = top + scrollEl.clientHeight;
  var left = scrollEl.scrollLeft,
      right = left + scrollEl.clientWidth;

  function isElementBottomAfterViewTop(view) {
    var element = view.div;
    var elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
    return elementBottom > top;
  }

  function isElementNextAfterViewHorizontally(view) {
    var element = view.div;
    var elementLeft = element.offsetLeft + element.clientLeft;
    var elementRight = elementLeft + element.clientWidth;
    return rtl ? elementLeft < right : elementRight > left;
  }

  var visible = [],
      ids = new Set(),
      numViews = views.length;
  var firstVisibleElementInd = binarySearchFirstItem(views, horizontal ? isElementNextAfterViewHorizontally : isElementBottomAfterViewTop);

  if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
    firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
  }

  var lastEdge = horizontal ? right : -1;

  for (var i = firstVisibleElementInd; i < numViews; i++) {
    var view = views[i],
        element = view.div;
    var currentWidth = element.offsetLeft + element.clientLeft;
    var currentHeight = element.offsetTop + element.clientTop;
    var viewWidth = element.clientWidth,
        viewHeight = element.clientHeight;
    var viewRight = currentWidth + viewWidth;
    var viewBottom = currentHeight + viewHeight;

    if (lastEdge === -1) {
      if (viewBottom >= bottom) {
        lastEdge = viewBottom;
      }
    } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
      break;
    }

    if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
      continue;
    }

    var hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
    var hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
    var fractionHeight = (viewHeight - hiddenHeight) / viewHeight,
        fractionWidth = (viewWidth - hiddenWidth) / viewWidth;
    var percent = fractionHeight * fractionWidth * 100 | 0;
    visible.push({
      id: view.id,
      x: currentWidth,
      y: currentHeight,
      view,
      percent,
      widthPercent: fractionWidth * 100 | 0
    });
    ids.add(view.id);
  }

  var first = visible[0],
      last = visible[visible.length - 1];

  if (sortByVisibility) {
    visible.sort(function (a, b) {
      var pc = a.percent - b.percent;

      if (Math.abs(pc) > 0.001) {
        return -pc;
      }

      return a.id - b.id;
    });
  }

  return {
    first,
    last,
    views: visible,
    ids
  };
}

function noContextMenuHandler(evt) {
  evt.preventDefault();
}

function normalizeWheelEventDirection(evt) {
  var delta = Math.hypot(evt.deltaX, evt.deltaY);
  var angle = Math.atan2(evt.deltaY, evt.deltaX);

  if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
    delta = -delta;
  }

  return delta;
}

function normalizeWheelEventDelta(evt) {
  var delta = normalizeWheelEventDirection(evt);
  var MOUSE_DOM_DELTA_PIXEL_MODE = 0;
  var MOUSE_DOM_DELTA_LINE_MODE = 1;
  var MOUSE_PIXELS_PER_LINE = 30;
  var MOUSE_LINES_PER_PAGE = 30;

  if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
    delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
  } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
    delta /= MOUSE_LINES_PER_PAGE;
  }

  return delta;
}

function isValidRotation(angle) {
  return Number.isInteger(angle) && angle % 90 === 0;
}

function isValidScrollMode(mode) {
  return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
}

function isValidSpreadMode(mode) {
  return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
}

function isPortraitOrientation(size) {
  return size.width <= size.height;
}

var animationStarted = new Promise(function (resolve) {
  if (typeof window === "undefined") {
    setTimeout(resolve, 20);
    return;
  }

  window.requestAnimationFrame(resolve);
});
exports.animationStarted = animationStarted;

function clamp(v, min, max) {
  return Math.min(Math.max(v, min), max);
}

var _updateBar = /*#__PURE__*/new WeakSet();

class ProgressBar {
  constructor(id) {
    _classPrivateMethodInitSpec(this, _updateBar);

    if (arguments.length > 1) {
      throw new Error("ProgressBar no longer accepts any additional options, " + "please use CSS rules to modify its appearance instead.");
    }

    this.visible = true;
    this.div = document.querySelector(id + " .progress");
    this.bar = this.div.parentNode;
    this.percent = 0;
  }

  get percent() {
    return this._percent;
  }

  set percent(val) {
    this._indeterminate = isNaN(val);
    this._percent = clamp(val, 0, 100);

    _classPrivateMethodGet(this, _updateBar, _updateBar2).call(this);
  }

  setWidth(viewer) {
    if (!viewer) {
      return;
    }

    var container = viewer.parentNode;
    var scrollbarWidth = container.offsetWidth - viewer.offsetWidth;

    if (scrollbarWidth > 0) {
      var doc = document.documentElement;
      doc.style.setProperty("--progressBar-end-offset", "".concat(scrollbarWidth, "px"));
    }
  }

  hide() {
    if (!this.visible) {
      return;
    }

    this.visible = false;
    this.bar.classList.add("hidden");
  }

  show() {
    if (this.visible) {
      return;
    }

    this.visible = true;
    this.bar.classList.remove("hidden");
  }

}

function _updateBar2() {
  if (this._indeterminate) {
    this.div.classList.add("indeterminate");
    return;
  }

  this.div.classList.remove("indeterminate");
  var doc = document.documentElement;
  doc.style.setProperty("--progressBar-percent", "".concat(this._percent, "%"));
}

exports.ProgressBar = ProgressBar;

function getActiveOrFocusedElement() {
  var curRoot = document;
  var curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");

  while ((_curActiveOrFocused = curActiveOrFocused) !== null && _curActiveOrFocused !== void 0 && _curActiveOrFocused.shadowRoot) {
    var _curActiveOrFocused;

    curRoot = curActiveOrFocused.shadowRoot;
    curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
  }

  return curActiveOrFocused;
}

function apiPageLayoutToViewerModes(layout) {
  var scrollMode = ScrollMode.VERTICAL,
      spreadMode = SpreadMode.NONE;

  switch (layout) {
    case "SinglePage":
      scrollMode = ScrollMode.PAGE;
      break;

    case "OneColumn":
      break;

    case "TwoPageLeft":
      scrollMode = ScrollMode.PAGE;

    case "TwoColumnLeft":
      spreadMode = SpreadMode.ODD;
      break;

    case "TwoPageRight":
      scrollMode = ScrollMode.PAGE;

    case "TwoColumnRight":
      spreadMode = SpreadMode.EVEN;
      break;
  }

  return {
    scrollMode,
    spreadMode
  };
}

function apiPageModeToSidebarView(mode) {
  switch (mode) {
    case "UseNone":
      return SidebarView.NONE;

    case "UseThumbs":
      return SidebarView.THUMBS;

    case "UseOutlines":
      return SidebarView.OUTLINE;

    case "UseAttachments":
      return SidebarView.ATTACHMENTS;

    case "UseOC":
      return SidebarView.LAYERS;
  }

  return SidebarView.NONE;
}

/***/ }),

/***/ "./src/pdf_js/webpack.js":
/*!*******************************!*\
  !*** ./src/pdf_js/webpack.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var pdfjs = __webpack_require__(/*! ./build/pdf.js */ "./src/pdf_js/build/pdf.js");

var PdfjsWorker = __webpack_require__(/*! worker-loader?esModule=false&filename=[name].[contenthash].js!./build/pdf.worker.js */ "./node_modules/worker-loader/dist/cjs.js?esModule=false&filename=[name].[contenthash].js!./src/pdf_js/build/pdf.worker.js");

if (typeof window !== "undefined" && "Worker" in window) {
  pdfjs.GlobalWorkerOptions.workerPort = new PdfjsWorker();
}

module.exports = pdfjs;

/***/ }),

/***/ "./src/pdf_link_service.js":
/*!*********************************!*\
  !*** ./src/pdf_link_service.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2019 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SimpleLinkService = exports.PDFLinkService = void 0;

var _ui_utils = __webpack_require__(/*! ./ui_utils */ "./src/ui_utils.js");

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var PDFLinkService = /*#__PURE__*/function () {
  function PDFLinkService() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        eventBus = _ref.eventBus,
        _ref$externalLinkTarg = _ref.externalLinkTarget,
        externalLinkTarget = _ref$externalLinkTarg === void 0 ? null : _ref$externalLinkTarg,
        _ref$externalLinkRel = _ref.externalLinkRel,
        externalLinkRel = _ref$externalLinkRel === void 0 ? null : _ref$externalLinkRel;

    _classCallCheck(this, PDFLinkService);

    this.eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
    this.externalLinkTarget = externalLinkTarget;
    this.externalLinkRel = externalLinkRel;
    this.baseUrl = null;
    this.pdfDocument = null;
    this.pdfViewer = null;
    this.pdfHistory = null;
    this._pagesRefCache = null;
  }

  _createClass(PDFLinkService, [{
    key: "setDocument",
    value: function setDocument(pdfDocument) {
      var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.baseUrl = baseUrl;
      this.pdfDocument = pdfDocument;
      this._pagesRefCache = Object.create(null);
    }
  }, {
    key: "setViewer",
    value: function setViewer(pdfViewer) {
      this.pdfViewer = pdfViewer;
    }
  }, {
    key: "setHistory",
    value: function setHistory(pdfHistory) {
      this.pdfHistory = pdfHistory;
    }
  }, {
    key: "navigateTo",
    value: function navigateTo(dest) {
      var _this = this;

      var goToDestination = function goToDestination(_ref2) {
        var namedDest = _ref2.namedDest,
            explicitDest = _ref2.explicitDest;
        var destRef = explicitDest[0],
            pageNumber;

        if (destRef instanceof Object) {
          pageNumber = _this._cachedPageNumber(destRef);

          if (pageNumber === null) {
            _this.pdfDocument.getPageIndex(destRef).then(function (pageIndex) {
              _this.cachePageRef(pageIndex + 1, destRef);

              goToDestination({
                namedDest: namedDest,
                explicitDest: explicitDest
              });
            })["catch"](function () {
              console.error("PDFLinkService.navigateTo: \"".concat(destRef, "\" is not ") + "a valid page reference, for dest=\"".concat(dest, "\"."));
            });

            return;
          }
        } else if (Number.isInteger(destRef)) {
          pageNumber = destRef + 1;
        } else {
          console.error("PDFLinkService.navigateTo: \"".concat(destRef, "\" is not ") + "a valid destination reference, for dest=\"".concat(dest, "\"."));
          return;
        }

        if (!pageNumber || pageNumber < 1 || pageNumber > _this.pagesCount) {
          console.error("PDFLinkService.navigateTo: \"".concat(pageNumber, "\" is not ") + "a valid page number, for dest=\"".concat(dest, "\"."));
          return;
        }

        if (_this.pdfHistory) {
          _this.pdfHistory.pushCurrentPosition();

          _this.pdfHistory.push({
            namedDest: namedDest,
            explicitDest: explicitDest,
            pageNumber: pageNumber
          });
        }

        _this.pdfViewer.scrollPageIntoView({
          pageNumber: pageNumber,
          destArray: explicitDest
        });
      };

      new Promise(function (resolve, reject) {
        if (typeof dest === 'string') {
          _this.pdfDocument.getDestination(dest).then(function (destArray) {
            resolve({
              namedDest: dest,
              explicitDest: destArray
            });
          });

          return;
        }

        resolve({
          namedDest: '',
          explicitDest: dest
        });
      }).then(function (data) {
        if (!Array.isArray(data.explicitDest)) {
          console.error("PDFLinkService.navigateTo: \"".concat(data.explicitDest, "\" is") + " not a valid destination array, for dest=\"".concat(dest, "\"."));
          return;
        }

        goToDestination(data);
      });
    }
  }, {
    key: "getDestinationHash",
    value: function getDestinationHash(dest) {
      if (typeof dest === 'string') {
        return this.getAnchorUrl('#' + escape(dest));
      }

      if (Array.isArray(dest)) {
        var str = JSON.stringify(dest);
        return this.getAnchorUrl('#' + escape(str));
      }

      return this.getAnchorUrl('');
    }
  }, {
    key: "getAnchorUrl",
    value: function getAnchorUrl(anchor) {
      return (this.baseUrl || '') + anchor;
    }
  }, {
    key: "setHash",
    value: function setHash(hash) {
      var pageNumber, dest;

      if (hash.includes('=')) {
        var params = (0, _ui_utils.parseQueryString)(hash);

        if ('search' in params) {
          this.eventBus.dispatch('findfromurlhash', {
            source: this,
            query: params['search'].replace(/"/g, ''),
            phraseSearch: params['phrase'] === 'true'
          });
        }

        if ('nameddest' in params) {
          this.navigateTo(params.nameddest);
          return;
        }

        if ('page' in params) {
          pageNumber = params.page | 0 || 1;
        }

        if ('zoom' in params) {
          var zoomArgs = params.zoom.split(',');
          var zoomArg = zoomArgs[0];
          var zoomArgNumber = parseFloat(zoomArg);

          if (!zoomArg.includes('Fit')) {
            dest = [null, {
              name: 'XYZ'
            }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
          } else {
            if (zoomArg === 'Fit' || zoomArg === 'FitB') {
              dest = [null, {
                name: zoomArg
              }];
            } else if (zoomArg === 'FitH' || zoomArg === 'FitBH' || zoomArg === 'FitV' || zoomArg === 'FitBV') {
              dest = [null, {
                name: zoomArg
              }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
            } else if (zoomArg === 'FitR') {
              if (zoomArgs.length !== 5) {
                console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
              } else {
                dest = [null, {
                  name: zoomArg
                }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
              }
            } else {
              console.error("PDFLinkService.setHash: \"".concat(zoomArg, "\" is not ") + 'a valid zoom value.');
            }
          }
        }

        if (dest) {
          this.pdfViewer.scrollPageIntoView({
            pageNumber: pageNumber || this.page,
            destArray: dest,
            allowNegativeOffset: true
          });
        } else if (pageNumber) {
          this.page = pageNumber;
        }

        if ('pagemode' in params) {
          this.eventBus.dispatch('pagemode', {
            source: this,
            mode: params.pagemode
          });
        }
      } else {
        dest = unescape(hash);

        try {
          dest = JSON.parse(dest);

          if (!Array.isArray(dest)) {
            dest = dest.toString();
          }
        } catch (ex) {}

        if (typeof dest === 'string' || isValidExplicitDestination(dest)) {
          this.navigateTo(dest);
          return;
        }

        console.error("PDFLinkService.setHash: \"".concat(unescape(hash), "\" is not ") + 'a valid destination.');
      }
    }
  }, {
    key: "executeNamedAction",
    value: function executeNamedAction(action) {
      switch (action) {
        case 'GoBack':
          if (this.pdfHistory) {
            this.pdfHistory.back();
          }

          break;

        case 'GoForward':
          if (this.pdfHistory) {
            this.pdfHistory.forward();
          }

          break;

        case 'NextPage':
          if (this.page < this.pagesCount) {
            this.page++;
          }

          break;

        case 'PrevPage':
          if (this.page > 1) {
            this.page--;
          }

          break;

        case 'LastPage':
          this.page = this.pagesCount;
          break;

        case 'FirstPage':
          this.page = 1;
          break;

        default:
          break;
      }

      this.eventBus.dispatch('namedaction', {
        source: this,
        action: action
      });
    }
  }, {
    key: "cachePageRef",
    value: function cachePageRef(pageNum, pageRef) {
      if (!pageRef) {
        return;
      }

      var refStr = pageRef.num + ' ' + pageRef.gen + ' R';
      this._pagesRefCache[refStr] = pageNum;
    }
  }, {
    key: "_cachedPageNumber",
    value: function _cachedPageNumber(pageRef) {
      var refStr = pageRef.num + ' ' + pageRef.gen + ' R';
      return this._pagesRefCache && this._pagesRefCache[refStr] || null;
    }
  }, {
    key: "isPageVisible",
    value: function isPageVisible(pageNumber) {
      return this.pdfViewer.isPageVisible(pageNumber);
    }
  }, {
    key: "pagesCount",
    get: function get() {
      return this.pdfDocument ? this.pdfDocument.numPages : 0;
    }
  }, {
    key: "page",
    get: function get() {
      return this.pdfViewer.currentPageNumber;
    },
    set: function set(value) {
      this.pdfViewer.currentPageNumber = value;
    }
  }, {
    key: "rotation",
    get: function get() {
      return this.pdfViewer.pagesRotation;
    },
    set: function set(value) {
      this.pdfViewer.pagesRotation = value;
    }
  }]);

  return PDFLinkService;
}();

exports.PDFLinkService = PDFLinkService;

function isValidExplicitDestination(dest) {
  if (!Array.isArray(dest)) {
    return false;
  }

  var destLength = dest.length,
      allowNull = true;

  if (destLength < 2) {
    return false;
  }

  var page = dest[0];

  if (!(_typeof(page) === 'object' && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
    return false;
  }

  var zoom = dest[1];

  if (!(_typeof(zoom) === 'object' && typeof zoom.name === 'string')) {
    return false;
  }

  switch (zoom.name) {
    case 'XYZ':
      if (destLength !== 5) {
        return false;
      }

      break;

    case 'Fit':
    case 'FitB':
      return destLength === 2;

    case 'FitH':
    case 'FitBH':
    case 'FitV':
    case 'FitBV':
      if (destLength !== 3) {
        return false;
      }

      break;

    case 'FitR':
      if (destLength !== 6) {
        return false;
      }

      allowNull = false;
      break;

    default:
      return false;
  }

  for (var i = 2; i < destLength; i++) {
    var param = dest[i];

    if (!(typeof param === 'number' || allowNull && param === null)) {
      return false;
    }
  }

  return true;
}

var SimpleLinkService = /*#__PURE__*/function () {
  function SimpleLinkService() {
    _classCallCheck(this, SimpleLinkService);

    this.externalLinkTarget = null;
    this.externalLinkRel = null;
  }

  _createClass(SimpleLinkService, [{
    key: "navigateTo",
    value: function navigateTo(dest) {}
  }, {
    key: "getDestinationHash",
    value: function getDestinationHash(dest) {
      return '#';
    }
  }, {
    key: "getAnchorUrl",
    value: function getAnchorUrl(hash) {
      return '#';
    }
  }, {
    key: "setHash",
    value: function setHash(hash) {}
  }, {
    key: "executeNamedAction",
    value: function executeNamedAction(action) {}
  }, {
    key: "cachePageRef",
    value: function cachePageRef(pageNum, pageRef) {}
  }, {
    key: "isPageVisible",
    value: function isPageVisible(pageNumber) {
      return true;
    }
  }, {
    key: "pagesCount",
    get: function get() {
      return 0;
    }
  }, {
    key: "page",
    get: function get() {
      return 0;
    },
    set: function set(value) {}
  }, {
    key: "rotation",
    get: function get() {
      return 0;
    },
    set: function set(value) {}
  }]);

  return SimpleLinkService;
}();

exports.SimpleLinkService = SimpleLinkService;

/***/ }),

/***/ "./src/text_layer_builder.js":
/*!***********************************!*\
  !*** ./src/text_layer_builder.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultTextLayerFactory": () => (/* binding */ DefaultTextLayerFactory),
/* harmony export */   "TextLayerBuilder": () => (/* binding */ TextLayerBuilder)
/* harmony export */ });
/* harmony import */ var _ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui_utils */ "./src/ui_utils.js");
/* harmony import */ var _mabl_pdf_js_build_pdf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mabl/pdf.js/build/pdf */ "./src/pdf_js/build/pdf.js");
/* harmony import */ var _mabl_pdf_js_build_pdf__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mabl_pdf_js_build_pdf__WEBPACK_IMPORTED_MODULE_1__);
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var EXPAND_DIVS_TIMEOUT = 300; // ms

/**
 * @typedef {Object} TextLayerBuilderOptions
 * @property {HTMLDivElement} textLayerDiv - The text layer container.
 * @property {EventBus} eventBus - The application event bus.
 * @property {number} pageIndex - The page index.
 * @property {PageViewport} viewport - The viewport of the text layer.
 * @property {PDFFindController} findController
 * @property {boolean} enhanceTextSelection - Option to turn on improved
 *   text selection.
 */

/**
 * The text layer builder provides text selection functionality for the PDF.
 * It does this by creating overlay divs over the PDF's text. These divs
 * contain text that matches the PDF text they are overlaying. This object
 * also provides a way to highlight text that is being searched for.
 */

class TextLayerBuilder {
  constructor(_ref) {
    var {
      textLayerDiv,
      eventBus,
      pageIndex,
      viewport,
      findController = null,
      enhanceTextSelection = false
    } = _ref;
    this.textLayerDiv = textLayerDiv;
    this.eventBus = eventBus || (0,_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobalEventBus)();
    this.textContent = null;
    this.textContentItemsStr = [];
    this.textContentStream = null;
    this.renderingDone = false;
    this.pageIdx = pageIndex;
    this.pageNumber = this.pageIdx + 1;
    this.matches = [];
    this.viewport = viewport;
    this.textDivs = [];
    this.findController = findController;
    this.textLayerRenderTask = null;
    this.enhanceTextSelection = enhanceTextSelection;
    this._onUpdateTextLayerMatches = null;

    this._bindMouse();
  }
  /**
   * @private
   */


  _finishRendering() {
    this.renderingDone = true;

    if (!this.enhanceTextSelection) {
      var endOfContent = document.createElement('div');
      endOfContent.className = 'endOfContent';
      this.textLayerDiv.appendChild(endOfContent);
    }

    this.eventBus.dispatch('textlayerrendered', {
      source: this,
      pageNumber: this.pageNumber,
      numTextDivs: this.textDivs.length
    });
  }
  /**
   * Renders the text layer.
   *
   * @param {number} timeout - (optional) wait for a specified amount of
   *                           milliseconds before rendering
   */


  render() {
    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    if (!(this.textContent || this.textContentStream) || this.renderingDone) {
      return;
    }

    this.cancel();
    this.textDivs = [];
    var textLayerFrag = document.createDocumentFragment();
    this.textLayerRenderTask = (0,_mabl_pdf_js_build_pdf__WEBPACK_IMPORTED_MODULE_1__.renderTextLayer)({
      textContent: this.textContent,
      textContentStream: this.textContentStream,
      container: textLayerFrag,
      viewport: this.viewport,
      textDivs: this.textDivs,
      textContentItemsStr: this.textContentItemsStr,
      timeout,
      enhanceTextSelection: this.enhanceTextSelection
    });
    this.textLayerRenderTask.promise.then(() => {
      this.textLayerDiv.appendChild(textLayerFrag);

      this._finishRendering();

      this._updateMatches();
    }, function (reason) {// Cancelled or failed to render text layer; skipping errors.
    });

    if (!this._onUpdateTextLayerMatches) {
      this._onUpdateTextLayerMatches = evt => {
        if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {
          this._updateMatches();
        }
      };

      this.eventBus.on('updatetextlayermatches', this._onUpdateTextLayerMatches);
    }
  }
  /**
   * Cancel rendering of the text layer.
   */


  cancel() {
    if (this.textLayerRenderTask) {
      this.textLayerRenderTask.cancel();
      this.textLayerRenderTask = null;
    }

    if (this._onUpdateTextLayerMatches) {
      this.eventBus.off('updatetextlayermatches', this._onUpdateTextLayerMatches);
      this._onUpdateTextLayerMatches = null;
    }
  }

  setTextContentStream(readableStream) {
    this.cancel();
    this.textContentStream = readableStream;
  }

  setTextContent(textContent) {
    this.cancel();
    this.textContent = textContent;
  }

  _convertMatches(matches, matchesLength) {
    // Early exit if there is nothing to convert.
    if (!matches) {
      return [];
    }

    var {
      findController,
      textContentItemsStr
    } = this;
    var i = 0,
        iIndex = 0;
    var end = textContentItemsStr.length - 1;
    var queryLen = findController.state.query.length;
    var result = [];

    for (var m = 0, mm = matches.length; m < mm; m++) {
      // Calculate the start position.
      var matchIdx = matches[m]; // Loop over the divIdxs.

      while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
        iIndex += textContentItemsStr[i].length;
        i++;
      }

      if (i === textContentItemsStr.length) {
        console.error('Could not find a matching mapping');
      }

      var match = {
        begin: {
          divIdx: i,
          offset: matchIdx - iIndex
        }
      }; // Calculate the end position.

      if (matchesLength) {
        // Multiterm search.
        matchIdx += matchesLength[m];
      } else {
        // Phrase search.
        matchIdx += queryLen;
      } // Somewhat the same array as above, but use > instead of >= to get
      // the end position right.


      while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
        iIndex += textContentItemsStr[i].length;
        i++;
      }

      match.end = {
        divIdx: i,
        offset: matchIdx - iIndex
      };
      result.push(match);
    }

    return result;
  }

  _renderMatches(matches) {
    // Early exit if there is nothing to render.
    if (matches.length === 0) {
      return;
    }

    var {
      findController,
      pageIdx,
      textContentItemsStr,
      textDivs
    } = this;
    var isSelectedPage = pageIdx === findController.selected.pageIdx;
    var selectedMatchIdx = findController.selected.matchIdx;
    var highlightAll = findController.state.highlightAll;
    var prevEnd = null;
    var infinity = {
      divIdx: -1,
      offset: undefined
    };

    function beginText(begin, className) {
      var divIdx = begin.divIdx;
      textDivs[divIdx].textContent = '';
      appendTextToDiv(divIdx, 0, begin.offset, className);
    }

    function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
      var div = textDivs[divIdx];
      var content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
      var node = document.createTextNode(content);

      if (className) {
        var span = document.createElement('span');
        span.className = className;
        span.appendChild(node);
        div.appendChild(span);
        return;
      }

      div.appendChild(node);
    }

    var i0 = selectedMatchIdx,
        i1 = i0 + 1;

    if (highlightAll) {
      i0 = 0;
      i1 = matches.length;
    } else if (!isSelectedPage) {
      // Not highlighting all and this isn't the selected page, so do nothing.
      return;
    }

    for (var i = i0; i < i1; i++) {
      var match = matches[i];
      var begin = match.begin;
      var end = match.end;
      var isSelected = isSelectedPage && i === selectedMatchIdx;
      var highlightSuffix = isSelected ? ' selected' : '';

      if (isSelected) {
        // Attempt to scroll the selected match into view.
        findController.scrollMatchIntoView({
          element: textDivs[begin.divIdx],
          pageIndex: pageIdx,
          matchIndex: selectedMatchIdx
        });
      } // Match inside new div.


      if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
        // If there was a previous div, then add the text at the end.
        if (prevEnd !== null) {
          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
        } // Clear the divs and set the content until the starting point.


        beginText(begin);
      } else {
        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
      }

      if (begin.divIdx === end.divIdx) {
        appendTextToDiv(begin.divIdx, begin.offset, end.offset, 'highlight' + highlightSuffix);
      } else {
        appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, 'highlight begin' + highlightSuffix);

        for (var n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
          textDivs[n0].className = 'highlight middle' + highlightSuffix;
        }

        beginText(end, 'highlight end' + highlightSuffix);
      }

      prevEnd = end;
    }

    if (prevEnd) {
      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
    }
  }

  _updateMatches() {
    // Only show matches when all rendering is done.
    if (!this.renderingDone) {
      return;
    }

    var {
      findController,
      matches,
      pageIdx,
      textContentItemsStr,
      textDivs
    } = this;
    var clearedUntilDivIdx = -1; // Clear all current matches.

    for (var i = 0, ii = matches.length; i < ii; i++) {
      var match = matches[i];
      var begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);

      for (var n = begin, end = match.end.divIdx; n <= end; n++) {
        var div = textDivs[n];
        div.textContent = textContentItemsStr[n];
        div.className = '';
      }

      clearedUntilDivIdx = match.end.divIdx + 1;
    }

    if (!findController || !findController.highlightMatches) {
      return;
    } // Convert the matches on the `findController` into the match format
    // used for the textLayer.


    var pageMatches = findController.pageMatches[pageIdx] || null;
    var pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
    this.matches = this._convertMatches(pageMatches, pageMatchesLength);

    this._renderMatches(this.matches);
  }
  /**
   * Improves text selection by adding an additional div where the mouse was
   * clicked. This reduces flickering of the content if the mouse is slowly
   * dragged up or down.
   *
   * @private
   */


  _bindMouse() {
    var div = this.textLayerDiv;
    var expandDivsTimer = null;
    div.addEventListener('mousedown', evt => {
      if (this.enhanceTextSelection && this.textLayerRenderTask) {
        this.textLayerRenderTask.expandTextDivs(true);

        if ((typeof PDFJSDev === 'undefined' || !PDFJSDev.test('FIREFOX || MOZCENTRAL')) && expandDivsTimer) {
          clearTimeout(expandDivsTimer);
          expandDivsTimer = null;
        }

        return;
      }

      var end = div.querySelector('.endOfContent');

      if (!end) {
        return;
      }

      if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('FIREFOX || MOZCENTRAL')) {
        // On non-Firefox browsers, the selection will feel better if the height
        // of the `endOfContent` div is adjusted to start at mouse click
        // location. This avoids flickering when the selection moves up.
        // However it does not work when selection is started on empty space.
        var adjustTop = evt.target !== div;

        if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('GENERIC')) {
          adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue('-moz-user-select') !== 'none';
        }

        if (adjustTop) {
          var divBounds = div.getBoundingClientRect();
          var r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
          end.style.top = (r * 100).toFixed(2) + '%';
        }
      }

      end.classList.add('active');
    });
    div.addEventListener('mouseup', () => {
      if (this.enhanceTextSelection && this.textLayerRenderTask) {
        if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('FIREFOX || MOZCENTRAL')) {
          expandDivsTimer = setTimeout(() => {
            if (this.textLayerRenderTask) {
              this.textLayerRenderTask.expandTextDivs(false);
            }

            expandDivsTimer = null;
          }, EXPAND_DIVS_TIMEOUT);
        } else {
          this.textLayerRenderTask.expandTextDivs(false);
        }

        return;
      }

      var end = div.querySelector('.endOfContent');

      if (!end) {
        return;
      }

      if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('FIREFOX || MOZCENTRAL')) {
        end.style.top = '';
      }

      end.classList.remove('active');
    });
  }

}
/**
 * @implements IPDFTextLayerFactory
 */


class DefaultTextLayerFactory {
  /**
   * @param {HTMLDivElement} textLayerDiv
   * @param {number} pageIndex
   * @param {PageViewport} viewport
   * @param {boolean} enhanceTextSelection
   * @returns {TextLayerBuilder}
   */
  createTextLayerBuilder(textLayerDiv, pageIndex, viewport) {
    var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    return new TextLayerBuilder({
      textLayerDiv,
      pageIndex,
      viewport,
      enhanceTextSelection
    });
  }

}



/***/ }),

/***/ "./src/ui_utils.js":
/*!*************************!*\
  !*** ./src/ui_utils.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSS_UNITS": () => (/* binding */ CSS_UNITS),
/* harmony export */   "DEFAULT_SCALE": () => (/* binding */ DEFAULT_SCALE),
/* harmony export */   "DEFAULT_SCALE_VALUE": () => (/* binding */ DEFAULT_SCALE_VALUE),
/* harmony export */   "EventBus": () => (/* binding */ EventBus),
/* harmony export */   "MAX_AUTO_SCALE": () => (/* binding */ MAX_AUTO_SCALE),
/* harmony export */   "MAX_SCALE": () => (/* binding */ MAX_SCALE),
/* harmony export */   "MIN_SCALE": () => (/* binding */ MIN_SCALE),
/* harmony export */   "NullL10n": () => (/* binding */ NullL10n),
/* harmony export */   "PresentationModeState": () => (/* binding */ PresentationModeState),
/* harmony export */   "ProgressBar": () => (/* binding */ ProgressBar),
/* harmony export */   "RendererType": () => (/* binding */ RendererType),
/* harmony export */   "SCROLLBAR_PADDING": () => (/* binding */ SCROLLBAR_PADDING),
/* harmony export */   "ScrollMode": () => (/* binding */ ScrollMode),
/* harmony export */   "SpreadMode": () => (/* binding */ SpreadMode),
/* harmony export */   "TextLayerMode": () => (/* binding */ TextLayerMode),
/* harmony export */   "UNKNOWN_SCALE": () => (/* binding */ UNKNOWN_SCALE),
/* harmony export */   "VERTICAL_PADDING": () => (/* binding */ VERTICAL_PADDING),
/* harmony export */   "WaitOnType": () => (/* binding */ WaitOnType),
/* harmony export */   "animationStarted": () => (/* binding */ animationStarted),
/* harmony export */   "approximateFraction": () => (/* binding */ approximateFraction),
/* harmony export */   "backtrackBeforeAllVisibleElements": () => (/* binding */ backtrackBeforeAllVisibleElements),
/* harmony export */   "binarySearchFirstItem": () => (/* binding */ binarySearchFirstItem),
/* harmony export */   "getGlobalEventBus": () => (/* binding */ getGlobalEventBus),
/* harmony export */   "getOutputScale": () => (/* binding */ getOutputScale),
/* harmony export */   "getPDFFileNameFromURL": () => (/* binding */ getPDFFileNameFromURL),
/* harmony export */   "getPageSizeInches": () => (/* binding */ getPageSizeInches),
/* harmony export */   "getVisibleElements": () => (/* binding */ getVisibleElements),
/* harmony export */   "isPortraitOrientation": () => (/* binding */ isPortraitOrientation),
/* harmony export */   "isValidRotation": () => (/* binding */ isValidRotation),
/* harmony export */   "isValidScrollMode": () => (/* binding */ isValidScrollMode),
/* harmony export */   "isValidSpreadMode": () => (/* binding */ isValidSpreadMode),
/* harmony export */   "moveToEndOfArray": () => (/* binding */ moveToEndOfArray),
/* harmony export */   "noContextMenuHandler": () => (/* binding */ noContextMenuHandler),
/* harmony export */   "normalizeWheelEventDelta": () => (/* binding */ normalizeWheelEventDelta),
/* harmony export */   "parseQueryString": () => (/* binding */ parseQueryString),
/* harmony export */   "roundToDivide": () => (/* binding */ roundToDivide),
/* harmony export */   "scrollIntoView": () => (/* binding */ scrollIntoView),
/* harmony export */   "waitOnEventOrTimeout": () => (/* binding */ waitOnEventOrTimeout),
/* harmony export */   "watchScroll": () => (/* binding */ watchScroll)
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var CSS_UNITS = 96.0 / 72.0;
var DEFAULT_SCALE_VALUE = 'auto';
var DEFAULT_SCALE = 1.0;
var MIN_SCALE = 0.10;
var MAX_SCALE = 10.0;
var UNKNOWN_SCALE = 0;
var MAX_AUTO_SCALE = 1.25;
var SCROLLBAR_PADDING = 40;
var VERTICAL_PADDING = 5;
var PresentationModeState = {
  UNKNOWN: 0,
  NORMAL: 1,
  CHANGING: 2,
  FULLSCREEN: 3
};
var RendererType = {
  CANVAS: 'canvas',
  SVG: 'svg'
};
var TextLayerMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_ENHANCE: 2
};
var ScrollMode = {
  UNKNOWN: -1,
  VERTICAL: 0,
  // Default value.
  HORIZONTAL: 1,
  WRAPPED: 2
};
var SpreadMode = {
  UNKNOWN: -1,
  NONE: 0,
  // Default value.
  ODD: 1,
  EVEN: 2
}; // Replaces {{arguments}} with their values.

function formatL10nValue(text, args) {
  if (!args) {
    return text;
  }

  return text.replace(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
    return name in args ? args[name] : '{{' + name + '}}';
  });
}
/**
 * No-op implementation of the localization service.
 * @implements {IL10n}
 */


var NullL10n = {
  getLanguage() {
    return _asyncToGenerator(function* () {
      return 'en-us';
    })();
  },

  getDirection() {
    return _asyncToGenerator(function* () {
      return 'ltr';
    })();
  },

  get(property, args, fallback) {
    return _asyncToGenerator(function* () {
      return formatL10nValue(fallback, args);
    })();
  },

  translate(element) {
    return _asyncToGenerator(function* () {})();
  }

};
/**
 * Returns scale factor for the canvas. It makes sense for the HiDPI displays.
 * @return {Object} The object with horizontal (sx) and vertical (sy)
                    scales. The scaled property is set to false if scaling is
                    not required, true otherwise.
 */

function getOutputScale(ctx) {
  var devicePixelRatio = window.devicePixelRatio || 1;
  var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
  var pixelRatio = devicePixelRatio / backingStoreRatio;
  return {
    sx: pixelRatio,
    sy: pixelRatio,
    scaled: pixelRatio !== 1
  };
}
/**
 * Scrolls specified element into view of its parent.
 * @param {Object} element - The element to be visible.
 * @param {Object} spot - An object with optional top and left properties,
 *   specifying the offset from the top left edge.
 * @param {boolean} skipOverflowHiddenElements - Ignore elements that have
 *   the CSS rule `overflow: hidden;` set. The default is false.
 */


function scrollIntoView(element, spot) {
  var skipOverflowHiddenElements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // Assuming offsetParent is available (it's not available when viewer is in
  // hidden iframe or object). We have to scroll: if the offsetParent is not set
  // producing the error. See also animationStarted.
  var parent = element.offsetParent;

  if (!parent) {
    console.error('offsetParent is not set -- cannot scroll');
    return;
  }

  var offsetY = element.offsetTop + element.clientTop;
  var offsetX = element.offsetLeft + element.clientLeft;

  while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || skipOverflowHiddenElements && getComputedStyle(parent).overflow === 'hidden') {
    if (parent.dataset._scaleY) {
      offsetY /= parent.dataset._scaleY;
      offsetX /= parent.dataset._scaleX;
    }

    offsetY += parent.offsetTop;
    offsetX += parent.offsetLeft;
    parent = parent.offsetParent;

    if (!parent) {
      return; // no need to scroll
    }
  }

  if (spot) {
    if (spot.top !== undefined) {
      offsetY += spot.top;
    }

    if (spot.left !== undefined) {
      offsetX += spot.left;
      parent.scrollLeft = offsetX;
    }
  }

  parent.scrollTop = offsetY;
}
/**
 * Helper function to start monitoring the scroll event and converting them into
 * PDF.js friendly one: with scroll debounce and scroll direction.
 */


function watchScroll(viewAreaElement, callback) {
  var debounceScroll = function debounceScroll(evt) {
    if (rAF) {
      return;
    } // schedule an invocation of scroll for next animation frame.


    rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
      rAF = null;
      var currentX = viewAreaElement.scrollLeft;
      var lastX = state.lastX;

      if (currentX !== lastX) {
        state.right = currentX > lastX;
      }

      state.lastX = currentX;
      var currentY = viewAreaElement.scrollTop;
      var lastY = state.lastY;

      if (currentY !== lastY) {
        state.down = currentY > lastY;
      }

      state.lastY = currentY;
      callback(state);
    });
  };

  var state = {
    right: true,
    down: true,
    lastX: viewAreaElement.scrollLeft,
    lastY: viewAreaElement.scrollTop,
    _eventHandler: debounceScroll
  };
  var rAF = null;
  viewAreaElement.addEventListener('scroll', debounceScroll, true);
  return state;
}
/**
 * Helper function to parse query string (e.g. ?param1=value&parm2=...).
 */


function parseQueryString(query) {
  var parts = query.split('&');
  var params = Object.create(null);

  for (var i = 0, ii = parts.length; i < ii; ++i) {
    var param = parts[i].split('=');
    var key = param[0].toLowerCase();
    var value = param.length > 1 ? param[1] : null;
    params[decodeURIComponent(key)] = decodeURIComponent(value);
  }

  return params;
}
/**
 * Use binary search to find the index of the first item in a given array which
 * passes a given condition. The items are expected to be sorted in the sense
 * that if the condition is true for one item in the array, then it is also true
 * for all following items.
 *
 * @returns {Number} Index of the first array element to pass the test,
 *                   or |items.length| if no such element exists.
 */


function binarySearchFirstItem(items, condition) {
  var minIndex = 0;
  var maxIndex = items.length - 1;

  if (items.length === 0 || !condition(items[maxIndex])) {
    return items.length;
  }

  if (condition(items[minIndex])) {
    return minIndex;
  }

  while (minIndex < maxIndex) {
    var currentIndex = minIndex + maxIndex >> 1;
    var currentItem = items[currentIndex];

    if (condition(currentItem)) {
      maxIndex = currentIndex;
    } else {
      minIndex = currentIndex + 1;
    }
  }

  return minIndex;
  /* === maxIndex */
}
/**
 *  Approximates float number as a fraction using Farey sequence (max order
 *  of 8).
 *  @param {number} x - Positive float number.
 *  @returns {Array} Estimated fraction: the first array item is a numerator,
 *                   the second one is a denominator.
 */


function approximateFraction(x) {
  // Fast paths for int numbers or their inversions.
  if (Math.floor(x) === x) {
    return [x, 1];
  }

  var xinv = 1 / x;
  var limit = 8;

  if (xinv > limit) {
    return [1, limit];
  } else if (Math.floor(xinv) === xinv) {
    return [1, xinv];
  }

  var x_ = x > 1 ? xinv : x; // a/b and c/d are neighbours in Farey sequence.

  var a = 0,
      b = 1,
      c = 1,
      d = 1; // Limiting search to order 8.

  while (true) {
    // Generating next term in sequence (order of q).
    var p = a + c,
        q = b + d;

    if (q > limit) {
      break;
    }

    if (x_ <= p / q) {
      c = p;
      d = q;
    } else {
      a = p;
      b = q;
    }
  }

  var result; // Select closest of the neighbours to x.

  if (x_ - a / b < c / d - x_) {
    result = x_ === x ? [a, b] : [b, a];
  } else {
    result = x_ === x ? [c, d] : [d, c];
  }

  return result;
}

function roundToDivide(x, div) {
  var r = x % div;
  return r === 0 ? x : Math.round(x - r + div);
}
/**
 * Gets the size of the specified page, converted from PDF units to inches.
 * @param {Object} An Object containing the properties: {Array} `view`,
 *   {number} `userUnit`, and {number} `rotate`.
 * @return {Object} An Object containing the properties: {number} `width`
 *   and {number} `height`, given in inches.
 */


function getPageSizeInches(_ref) {
  var {
    view,
    userUnit,
    rotate
  } = _ref;
  var [x1, y1, x2, y2] = view; // We need to take the page rotation into account as well.

  var changeOrientation = rotate % 180 !== 0;
  var width = (x2 - x1) / 72 * userUnit;
  var height = (y2 - y1) / 72 * userUnit;
  return {
    width: changeOrientation ? height : width,
    height: changeOrientation ? width : height
  };
}
/**
 * Helper function for getVisibleElements.
 *
 * @param {number} index - initial guess at the first visible element
 * @param {Array} views - array of pages, into which `index` is an index
 * @param {number} top - the top of the scroll pane
 * @returns {number} less than or equal to `index` that is definitely at or
 *   before the first visible element in `views`, but not by too much. (Usually,
 *   this will be the first element in the first partially visible row in
 *   `views`, although sometimes it goes back one row further.)
 */


function backtrackBeforeAllVisibleElements(index, views, top) {
  // binarySearchFirstItem's assumption is that the input is ordered, with only
  // one index where the conditions flips from false to true: [false ...,
  // true...]. With vertical scrolling and spreads, it is possible to have
  // [false ..., true, false, true ...]. With wrapped scrolling we can have a
  // similar sequence, with many more mixed true and false in the middle.
  //
  // So there is no guarantee that the binary search yields the index of the
  // first visible element. It could have been any of the other visible elements
  // that were preceded by a hidden element.
  // Of course, if either this element or the previous (hidden) element is also
  // the first element, there's nothing to worry about.
  if (index < 2) {
    return index;
  } // That aside, the possible cases are represented below.
  //
  //     ****  = fully hidden
  //     A*B*  = mix of partially visible and/or hidden pages
  //     CDEF  = fully visible
  //
  // (1) Binary search could have returned A, in which case we can stop.
  // (2) Binary search could also have returned B, in which case we need to
  // check the whole row.
  // (3) Binary search could also have returned C, in which case we need to
  // check the whole previous row.
  //
  // There's one other possibility:
  //
  //     ****  = fully hidden
  //     ABCD  = mix of fully and/or partially visible pages
  //
  // (4) Binary search could only have returned A.
  // Initially assume that we need to find the beginning of the current row
  // (case 1, 2, or 4), which means finding a page that is above the current
  // page's top. If the found page is partially visible, we're definitely not in
  // case 3, and this assumption is correct.


  var elt = views[index].div;
  var pageTop = elt.offsetTop + elt.clientTop;

  if (pageTop >= top) {
    // The found page is fully visible, so we're actually either in case 3 or 4,
    // and unfortunately we can't tell the difference between them without
    // scanning the entire previous row, so we just conservatively assume that
    // we do need to backtrack to that row. In both cases, the previous page is
    // in the previous row, so use its top instead.
    elt = views[index - 1].div;
    pageTop = elt.offsetTop + elt.clientTop;
  } // Now we backtrack to the first page that still has its bottom below
  // `pageTop`, which is the top of a page in the first visible row (unless
  // we're in case 4, in which case it's the row before that).
  // `index` is found by binary search, so the page at `index - 1` is
  // invisible and we can start looking for potentially visible pages from
  // `index - 2`. (However, if this loop terminates on its first iteration,
  // which is the case when pages are stacked vertically, `index` should remain
  // unchanged, so we use a distinct loop variable.)


  for (var i = index - 2; i >= 0; --i) {
    elt = views[i].div;

    if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
      // We have reached the previous row, so stop now.
      // This loop is expected to terminate relatively quickly because the
      // number of pages per row is expected to be small.
      break;
    }

    index = i;
  }

  return index;
}
/**
 * Generic helper to find out what elements are visible within a scroll pane.
 *
 * Well, pretty generic. There are some assumptions placed on the elements
 * referenced by `views`:
 *   - If `horizontal`, no left of any earlier element is to the right of the
 *     left of any later element.
 *   - Otherwise, `views` can be split into contiguous rows where, within a row,
 *     no top of any element is below the bottom of any other element, and
 *     between rows, no bottom of any element in an earlier row is below the
 *     top of any element in a later row.
 *
 * (Here, top, left, etc. all refer to the padding edge of the element in
 * question. For pages, that ends up being equivalent to the bounding box of the
 * rendering canvas. Earlier and later refer to index in `views`, not page
 * layout.)
 *
 * @param scrollEl {HTMLElement} - a container that can possibly scroll
 * @param views {Array} - objects with a `div` property that contains an
 *   HTMLElement, which should all be descendents of `scrollEl` satisfying the
 *   above layout assumptions
 * @param sortByVisibility {boolean} - if true, the returned elements are sorted
 *   in descending order of the percent of their padding box that is visible
 * @param horizontal {boolean} - if true, the elements are assumed to be laid
 *   out horizontally instead of vertically
 * @returns {Object} `{ first, last, views: [{ id, x, y, view, percent }] }`
 */


function getVisibleElements(scrollEl, views) {
  var sortByVisibility = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var horizontal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var top = scrollEl.scrollTop,
      bottom = top + scrollEl.clientHeight;
  var left = scrollEl.scrollLeft,
      right = left + scrollEl.clientWidth; // Throughout this "generic" function, comments will assume we're working with
  // PDF document pages, which is the most important and complex case. In this
  // case, the visible elements we're actually interested is the page canvas,
  // which is contained in a wrapper which adds no padding/border/margin, which
  // is itself contained in `view.div` which adds no padding (but does add a
  // border). So, as specified in this function's doc comment, this function
  // does all of its work on the padding edge of the provided views, starting at
  // offsetLeft/Top (which includes margin) and adding clientLeft/Top (which is
  // the border). Adding clientWidth/Height gets us the bottom-right corner of
  // the padding edge.

  function isElementBottomAfterViewTop(view) {
    var element = view.div;
    var elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
    return elementBottom > top;
  }

  function isElementRightAfterViewLeft(view) {
    var element = view.div;
    var elementRight = element.offsetLeft + element.clientLeft + element.clientWidth;
    return elementRight > left;
  }

  var visible = [],
      numViews = views.length;
  var firstVisibleElementInd = numViews === 0 ? 0 : binarySearchFirstItem(views, horizontal ? isElementRightAfterViewLeft : isElementBottomAfterViewTop); // Please note the return value of the `binarySearchFirstItem` function when
  // no valid element is found (hence the `firstVisibleElementInd` check below).

  if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
    // In wrapped scrolling (or vertical scrolling with spreads), with some page
    // sizes, isElementBottomAfterViewTop doesn't satisfy the binary search
    // condition: there can be pages with bottoms above the view top between
    // pages with bottoms below. This function detects and corrects that error;
    // see it for more comments.
    firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
  } // lastEdge acts as a cutoff for us to stop looping, because we know all
  // subsequent pages will be hidden.
  //
  // When using wrapped scrolling or vertical scrolling with spreads, we can't
  // simply stop the first time we reach a page below the bottom of the view;
  // the tops of subsequent pages on the same row could still be visible. In
  // horizontal scrolling, we don't have that issue, so we can stop as soon as
  // we pass `right`, without needing the code below that handles the -1 case.


  var lastEdge = horizontal ? right : -1;

  for (var i = firstVisibleElementInd; i < numViews; i++) {
    var view = views[i],
        element = view.div;
    var currentWidth = element.offsetLeft + element.clientLeft;
    var currentHeight = element.offsetTop + element.clientTop;
    var viewWidth = element.clientWidth,
        viewHeight = element.clientHeight;
    var viewRight = currentWidth + viewWidth;
    var viewBottom = currentHeight + viewHeight;

    if (lastEdge === -1) {
      // As commented above, this is only needed in non-horizontal cases.
      // Setting lastEdge to the bottom of the first page that is partially
      // visible ensures that the next page fully below lastEdge is on the
      // next row, which has to be fully hidden along with all subsequent rows.
      if (viewBottom >= bottom) {
        lastEdge = viewBottom;
      }
    } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
      break;
    }

    if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
      continue;
    }

    var hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
    var hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
    var percent = (viewHeight - hiddenHeight) * (viewWidth - hiddenWidth) * 100 / viewHeight / viewWidth | 0;
    visible.push({
      id: view.id,
      x: currentWidth,
      y: currentHeight,
      view,
      percent
    });
  }

  var first = visible[0],
      last = visible[visible.length - 1];

  if (sortByVisibility) {
    visible.sort(function (a, b) {
      var pc = a.percent - b.percent;

      if (Math.abs(pc) > 0.001) {
        return -pc;
      }

      return a.id - b.id; // ensure stability
    });
  }

  return {
    first,
    last,
    views: visible
  };
}
/**
 * Event handler to suppress context menu.
 */


function noContextMenuHandler(evt) {
  evt.preventDefault();
}

function isDataSchema(url) {
  var i = 0,
      ii = url.length;

  while (i < ii && url[i].trim() === '') {
    i++;
  }

  return url.substring(i, i + 5).toLowerCase() === 'data:';
}
/**
 * Returns the filename or guessed filename from the url (see issue 3455).
 * @param {string} url - The original PDF location.
 * @param {string} defaultFilename - The value returned if the filename is
 *   unknown, or the protocol is unsupported.
 * @returns {string} Guessed PDF filename.
 */


function getPDFFileNameFromURL(url) {
  var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'document.pdf';

  if (typeof url !== 'string') {
    return defaultFilename;
  }

  if (isDataSchema(url)) {
    console.warn('getPDFFileNameFromURL: ' + 'ignoring "data:" URL for performance reasons.');
    return defaultFilename;
  }

  var reURI = /^(?:(?:[^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/; //            SCHEME        HOST         1.PATH  2.QUERY   3.REF
  // Pattern to get last matching NAME.pdf

  var reFilename = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  var splitURI = reURI.exec(url);
  var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];

    if (suggestedFilename.includes('%')) {
      // URL-encoded %2Fpath%2Fto%2Ffile.pdf should be file.pdf
      try {
        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
      } catch (ex) {// Possible (extremely rare) errors:
        // URIError "Malformed URI", e.g. for "%AA.pdf"
        // TypeError "null has no properties", e.g. for "%2F.pdf"
      }
    }
  }

  return suggestedFilename || defaultFilename;
}

function normalizeWheelEventDelta(evt) {
  var delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY);
  var angle = Math.atan2(evt.deltaY, evt.deltaX);

  if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
    // All that is left-up oriented has to change the sign.
    delta = -delta;
  }

  var MOUSE_DOM_DELTA_PIXEL_MODE = 0;
  var MOUSE_DOM_DELTA_LINE_MODE = 1;
  var MOUSE_PIXELS_PER_LINE = 30;
  var MOUSE_LINES_PER_PAGE = 30; // Converts delta to per-page units

  if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
    delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
  } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
    delta /= MOUSE_LINES_PER_PAGE;
  }

  return delta;
}

function isValidRotation(angle) {
  return Number.isInteger(angle) && angle % 90 === 0;
}

function isValidScrollMode(mode) {
  return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
}

function isValidSpreadMode(mode) {
  return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
}

function isPortraitOrientation(size) {
  return size.width <= size.height;
}

var WaitOnType = {
  EVENT: 'event',
  TIMEOUT: 'timeout'
};
/**
 * @typedef {Object} WaitOnEventOrTimeoutParameters
 * @property {Object} target - The event target, can for example be:
 *   `window`, `document`, a DOM element, or an {EventBus} instance.
 * @property {string} name - The name of the event.
 * @property {number} delay - The delay, in milliseconds, after which the
 *   timeout occurs (if the event wasn't already dispatched).
 */

/**
 * Allows waiting for an event or a timeout, whichever occurs first.
 * Can be used to ensure that an action always occurs, even when an event
 * arrives late or not at all.
 *
 * @param {WaitOnEventOrTimeoutParameters}
 * @returns {Promise} A promise that is resolved with a {WaitOnType} value.
 */

function waitOnEventOrTimeout(_ref2) {
  var {
    target,
    name,
    delay = 0
  } = _ref2;
  return new Promise(function (resolve, reject) {
    if (typeof target !== 'object' || !(name && typeof name === 'string') || !(Number.isInteger(delay) && delay >= 0)) {
      throw new Error('waitOnEventOrTimeout - invalid parameters.');
    }

    function handler(type) {
      if (target instanceof EventBus) {
        target.off(name, eventHandler);
      } else {
        target.removeEventListener(name, eventHandler);
      }

      if (timeout) {
        clearTimeout(timeout);
      }

      resolve(type);
    }

    var eventHandler = handler.bind(null, WaitOnType.EVENT);

    if (target instanceof EventBus) {
      target.on(name, eventHandler);
    } else {
      target.addEventListener(name, eventHandler);
    }

    var timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
    var timeout = setTimeout(timeoutHandler, delay);
  });
}
/**
 * Promise that is resolved when DOM window becomes visible.
 */


var animationStarted = new Promise(function (resolve) {
  if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('LIB') && typeof window === 'undefined') {
    // Prevent "ReferenceError: window is not defined" errors when running the
    // unit-tests in Node.js/Travis.
    setTimeout(resolve, 20);
    return;
  }

  window.requestAnimationFrame(resolve);
});
/**
 * Simple event bus for an application. Listeners are attached using the
 * `on` and `off` methods. To raise an event, the `dispatch` method shall be
 * used.
 */

class EventBus {
  constructor() {
    var {
      dispatchToDOM = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._listeners = Object.create(null);
    this._dispatchToDOM = dispatchToDOM === true;
  }

  on(eventName, listener) {
    var eventListeners = this._listeners[eventName];

    if (!eventListeners) {
      eventListeners = [];
      this._listeners[eventName] = eventListeners;
    }

    eventListeners.push(listener);
  }

  off(eventName, listener) {
    var eventListeners = this._listeners[eventName];
    var i;

    if (!eventListeners || (i = eventListeners.indexOf(listener)) < 0) {
      return;
    }

    eventListeners.splice(i, 1);
  }

  dispatch(eventName) {
    var eventListeners = this._listeners[eventName];

    if (!eventListeners || eventListeners.length === 0) {
      if (this._dispatchToDOM) {
        var _args = Array.prototype.slice.call(arguments, 1);

        this._dispatchDOMEvent(eventName, _args);
      }

      return;
    } // Passing all arguments after the eventName to the listeners.


    var args = Array.prototype.slice.call(arguments, 1); // Making copy of the listeners array in case if it will be modified
    // during dispatch.

    eventListeners.slice(0).forEach(function (listener) {
      listener.apply(null, args);
    });

    if (this._dispatchToDOM) {
      this._dispatchDOMEvent(eventName, args);
    }
  }
  /**
   * @private
   */


  _dispatchDOMEvent(eventName) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var details = Object.create(null);

    if (args && args.length > 0) {
      var obj = args[0];

      for (var key in obj) {
        var value = obj[key];

        if (key === 'source') {
          if (value === window || value === document) {
            return; // No need to re-dispatch (already) global events.
          }

          continue; // Ignore the `source` property.
        }

        details[key] = value;
      }
    }

    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(eventName, true, true, details);
    document.dispatchEvent(event);
  }

}

var globalEventBus = null;

function getGlobalEventBus() {
  var dispatchToDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  if (!globalEventBus) {
    globalEventBus = new EventBus({
      dispatchToDOM
    });
  }

  return globalEventBus;
}

function clamp(v, min, max) {
  return Math.min(Math.max(v, min), max);
}

class ProgressBar {
  constructor(id) {
    var {
      height,
      width,
      units
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.visible = true; // Fetch the sub-elements for later.

    this.div = document.querySelector(id + ' .progress'); // Get the loading bar element, so it can be resized to fit the viewer.

    this.bar = this.div.parentNode; // Get options, with sensible defaults.

    this.height = height || 100;
    this.width = width || 100;
    this.units = units || '%'; // Initialize heights.

    this.div.style.height = this.height + this.units;
    this.percent = 0;
  }

  _updateBar() {
    if (this._indeterminate) {
      this.div.classList.add('indeterminate');
      this.div.style.width = this.width + this.units;
      return;
    }

    this.div.classList.remove('indeterminate');
    var progressSize = this.width * this._percent / 100;
    this.div.style.width = progressSize + this.units;
  }

  get percent() {
    return this._percent;
  }

  set percent(val) {
    this._indeterminate = isNaN(val);
    this._percent = clamp(val, 0, 100);

    this._updateBar();
  }

  setWidth(viewer) {
    if (!viewer) {
      return;
    }

    var container = viewer.parentNode;
    var scrollbarWidth = container.offsetWidth - viewer.offsetWidth;

    if (scrollbarWidth > 0) {
      this.bar.setAttribute('style', 'width: calc(100% - ' + scrollbarWidth + 'px);');
    }
  }

  hide() {
    if (!this.visible) {
      return;
    }

    this.visible = false;
    this.bar.classList.add('hidden');
    document.body.classList.remove('loadingInProgress');
  }

  show() {
    if (this.visible) {
      return;
    }

    this.visible = true;
    document.body.classList.add('loadingInProgress');
    this.bar.classList.remove('hidden');
  }

}
/**
 * Moves all elements of an array that satisfy condition to the end of the
 * array, preserving the order of the rest.
 */


function moveToEndOfArray(arr, condition) {
  var moved = [],
      len = arr.length;
  var write = 0;

  for (var read = 0; read < len; ++read) {
    if (condition(arr[read])) {
      moved.push(arr[read]);
    } else {
      arr[write] = arr[read];
      ++write;
    }
  }

  for (var _read2 = 0; write < len; ++_read2, ++write) {
    arr[write] = moved[_read2];
  }
}



/***/ }),

/***/ "./node_modules/canvas/browser.js":
/*!****************************************!*\
  !*** ./node_modules/canvas/browser.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* globals document, ImageData */

const parseFont = __webpack_require__(/*! ./lib/parse-font */ "./node_modules/canvas/lib/parse-font.js")

exports.parseFont = parseFont

exports.createCanvas = function (width, height) {
  return Object.assign(document.createElement('canvas'), { width: width, height: height })
}

exports.createImageData = function (array, width, height) {
  // Browser implementation of ImageData looks at the number of arguments passed
  switch (arguments.length) {
    case 0: return new ImageData()
    case 1: return new ImageData(array)
    case 2: return new ImageData(array, width)
    default: return new ImageData(array, width, height)
  }
}

exports.loadImage = function (src, options) {
  return new Promise(function (resolve, reject) {
    const image = Object.assign(document.createElement('img'), options)

    function cleanup () {
      image.onload = null
      image.onerror = null
    }

    image.onload = function () { cleanup(); resolve(image) }
    image.onerror = function () { cleanup(); reject(new Error('Failed to load the image "' + src + '"')) }

    image.src = src
  })
}


/***/ }),

/***/ "./node_modules/canvas/lib/parse-font.js":
/*!***********************************************!*\
  !*** ./node_modules/canvas/lib/parse-font.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/**
 * Font RegExp helpers.
 */

const weights = 'bold|bolder|lighter|[1-9]00'
const styles = 'italic|oblique'
const variants = 'small-caps'
const stretches = 'ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded'
const units = 'px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q'
const string = '\'([^\']+)\'|"([^"]+)"|[\\w\\s-]+'

// [ [ <‘font-style’> || <font-variant-css21> || <‘font-weight’> || <‘font-stretch’> ]?
//    <‘font-size’> [ / <‘line-height’> ]? <‘font-family’> ]
// https://drafts.csswg.org/css-fonts-3/#font-prop
const weightRe = new RegExp(`(${weights}) +`, 'i')
const styleRe = new RegExp(`(${styles}) +`, 'i')
const variantRe = new RegExp(`(${variants}) +`, 'i')
const stretchRe = new RegExp(`(${stretches}) +`, 'i')
const sizeFamilyRe = new RegExp(
  `([\\d\\.]+)(${units}) *((?:${string})( *, *(?:${string}))*)`)

/**
 * Cache font parsing.
 */

const cache = {}

const defaultHeight = 16 // pt, common browser default

/**
 * Parse font `str`.
 *
 * @param {String} str
 * @return {Object} Parsed font. `size` is in device units. `unit` is the unit
 *   appearing in the input string.
 * @api private
 */

module.exports = str => {
  // Cached
  if (cache[str]) return cache[str]

  // Try for required properties first.
  const sizeFamily = sizeFamilyRe.exec(str)
  if (!sizeFamily) return // invalid

  // Default values and required properties
  const font = {
    weight: 'normal',
    style: 'normal',
    stretch: 'normal',
    variant: 'normal',
    size: parseFloat(sizeFamily[1]),
    unit: sizeFamily[2],
    family: sizeFamily[3].replace(/["']/g, '').replace(/ *, */g, ',')
  }

  // Optional, unordered properties.
  let weight, style, variant, stretch
  // Stop search at `sizeFamily.index`
  const substr = str.substring(0, sizeFamily.index)
  if ((weight = weightRe.exec(substr))) font.weight = weight[1]
  if ((style = styleRe.exec(substr))) font.style = style[1]
  if ((variant = variantRe.exec(substr))) font.variant = variant[1]
  if ((stretch = stretchRe.exec(substr))) font.stretch = stretch[1]

  // Convert to device units. (`font.unit` is the original unit)
  // TODO: ch, ex
  switch (font.unit) {
    case 'pt':
      font.size /= 0.75
      break
    case 'pc':
      font.size *= 16
      break
    case 'in':
      font.size *= 96
      break
    case 'cm':
      font.size *= 96.0 / 2.54
      break
    case 'mm':
      font.size *= 96.0 / 25.4
      break
    case '%':
      // TODO disabled because existing unit tests assume 100
      // font.size *= defaultHeight / 100 / 0.75
      break
    case 'em':
    case 'rem':
      font.size *= defaultHeight / 0.75
      break
    case 'q':
      font.size *= 96 / 25.4 / 4
      break
  }

  return (cache[str] = font)
}


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/annotation_layer_builder.css":
/*!********************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/annotation_layer_builder.css ***!
  \********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Copyright 2014 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n.annotationLayer section {\n  position: absolute;\n}\n\n.annotationLayer .linkAnnotation > a,\n.annotationLayer .buttonWidgetAnnotation.pushButton > a {\n  position: absolute;\n  font-size: 1em;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.annotationLayer .linkAnnotation > a:hover,\n.annotationLayer .buttonWidgetAnnotation.pushButton > a:hover {\n  opacity: 0.2;\n  background: #ff0;\n  box-shadow: 0px 2px 10px #ff0;\n}\n\n.annotationLayer .textAnnotation img {\n  position: absolute;\n  cursor: pointer;\n}\n\n.annotationLayer .textWidgetAnnotation input,\n.annotationLayer .textWidgetAnnotation textarea,\n.annotationLayer .choiceWidgetAnnotation select,\n.annotationLayer .buttonWidgetAnnotation.checkBox input,\n.annotationLayer .buttonWidgetAnnotation.radioButton input {\n  background-color: rgba(0, 54, 255, 0.13);\n  border: 1px solid transparent;\n  box-sizing: border-box;\n  font-size: 9px;\n  height: 100%;\n  margin: 0;\n  padding: 0 3px;\n  vertical-align: top;\n  width: 100%;\n}\n\n.annotationLayer .choiceWidgetAnnotation select option {\n  padding: 0;\n}\n\n.annotationLayer .buttonWidgetAnnotation.radioButton input {\n  border-radius: 50%;\n}\n\n.annotationLayer .textWidgetAnnotation textarea {\n  font: message-box;\n  font-size: 9px;\n  resize: none;\n}\n\n.annotationLayer .textWidgetAnnotation input[disabled],\n.annotationLayer .textWidgetAnnotation textarea[disabled],\n.annotationLayer .choiceWidgetAnnotation select[disabled],\n.annotationLayer .buttonWidgetAnnotation.checkBox input[disabled],\n.annotationLayer .buttonWidgetAnnotation.radioButton input[disabled] {\n  background: none;\n  border: 1px solid transparent;\n  cursor: not-allowed;\n}\n\n.annotationLayer .textWidgetAnnotation input:hover,\n.annotationLayer .textWidgetAnnotation textarea:hover,\n.annotationLayer .choiceWidgetAnnotation select:hover,\n.annotationLayer .buttonWidgetAnnotation.checkBox input:hover,\n.annotationLayer .buttonWidgetAnnotation.radioButton input:hover {\n  border: 1px solid #000;\n}\n\n.annotationLayer .textWidgetAnnotation input:focus,\n.annotationLayer .textWidgetAnnotation textarea:focus,\n.annotationLayer .choiceWidgetAnnotation select:focus {\n  background: none;\n  border: 1px solid transparent;\n}\n\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,\n.annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before {\n  background-color: #000;\n  content: '';\n  display: block;\n  position: absolute;\n}\n\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after {\n  height: 80%;\n  left: 45%;\n  width: 1px;\n}\n\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before {\n  transform: rotate(45deg);\n}\n\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after {\n  transform: rotate(-45deg);\n}\n\n.annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before {\n  border-radius: 50%;\n  height: 50%;\n  left: 30%;\n  top: 20%;\n  width: 50%;\n}\n\n.annotationLayer .textWidgetAnnotation input.comb {\n  font-family: monospace;\n  padding-left: 2px;\n  padding-right: 0;\n}\n\n.annotationLayer .textWidgetAnnotation input.comb:focus {\n  /*\n   * Letter spacing is placed on the right side of each character. Hence, the\n   * letter spacing of the last character may be placed outside the visible\n   * area, causing horizontal scrolling. We avoid this by extending the width\n   * when the element has focus and revert this when it loses focus.\n   */\n  width: 115%;\n}\n\n.annotationLayer .buttonWidgetAnnotation.checkBox input,\n.annotationLayer .buttonWidgetAnnotation.radioButton input {\n  appearance: none;\n  padding: 0;\n}\n\n.annotationLayer .popupWrapper {\n  position: absolute;\n  width: 20em;\n}\n\n.annotationLayer .popup {\n  position: absolute;\n  z-index: 200;\n  max-width: 20em;\n  background-color: #FFFF99;\n  box-shadow: 0px 2px 5px #333;\n  border-radius: 2px;\n  padding: 0.6em;\n  margin-left: 5px;\n  cursor: pointer;\n  font: message-box;\n  word-wrap: break-word;\n}\n\n.annotationLayer .popup h1 {\n  font-size: 1em;\n  border-bottom: 1px solid #000000;\n  margin: 0;\n  padding-bottom: 0.2em;\n}\n\n.annotationLayer .popup p {\n  margin: 0;\n  padding-top: 0.2em;\n}\n\n.annotationLayer .highlightAnnotation,\n.annotationLayer .underlineAnnotation,\n.annotationLayer .squigglyAnnotation,\n.annotationLayer .strikeoutAnnotation,\n.annotationLayer .freeTextAnnotation,\n.annotationLayer .lineAnnotation svg line,\n.annotationLayer .squareAnnotation svg rect,\n.annotationLayer .circleAnnotation svg ellipse,\n.annotationLayer .polylineAnnotation svg polyline,\n.annotationLayer .polygonAnnotation svg polygon,\n.annotationLayer .caretAnnotation,\n.annotationLayer .inkAnnotation svg polyline,\n.annotationLayer .stampAnnotation,\n.annotationLayer .fileAttachmentAnnotation {\n  cursor: pointer;\n}\n", "",{"version":3,"sources":["webpack://./src/annotation_layer_builder.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;EAaE;;AAEF;EACE,kBAAkB;AACpB;;AAEA;;EAEE,kBAAkB;EAClB,cAAc;EACd,MAAM;EACN,OAAO;EACP,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,YAAY;EACZ,gBAAgB;EAChB,6BAA6B;AAC/B;;AAEA;EACE,kBAAkB;EAClB,eAAe;AACjB;;AAEA;;;;;EAKE,wCAAwC;EACxC,6BAA6B;EAC7B,sBAAsB;EACtB,cAAc;EACd,YAAY;EACZ,SAAS;EACT,cAAc;EACd,mBAAmB;EACnB,WAAW;AACb;;AAEA;EACE,UAAU;AACZ;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,iBAAiB;EACjB,cAAc;EACd,YAAY;AACd;;AAEA;;;;;EAKE,gBAAgB;EAChB,6BAA6B;EAC7B,mBAAmB;AACrB;;AAEA;;;;;EAKE,sBAAsB;AACxB;;AAEA;;;EAGE,gBAAgB;EAChB,6BAA6B;AAC/B;;AAEA;;;EAGE,sBAAsB;EACtB,WAAW;EACX,cAAc;EACd,kBAAkB;AACpB;;AAEA;;EAEE,WAAW;EACX,SAAS;EACT,UAAU;AACZ;;AAEA;EACE,wBAAwB;AAC1B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,SAAS;EACT,QAAQ;EACR,UAAU;AACZ;;AAEA;EACE,sBAAsB;EACtB,iBAAiB;EACjB,gBAAgB;AAClB;;AAEA;EACE;;;;;IAKE;EACF,WAAW;AACb;;AAEA;;EAEE,gBAAgB;EAChB,UAAU;AACZ;;AAEA;EACE,kBAAkB;EAClB,WAAW;AACb;;AAEA;EACE,kBAAkB;EAClB,YAAY;EACZ,eAAe;EACf,yBAAyB;EACzB,4BAA4B;EAC5B,kBAAkB;EAClB,cAAc;EACd,gBAAgB;EAChB,eAAe;EACf,iBAAiB;EACjB,qBAAqB;AACvB;;AAEA;EACE,cAAc;EACd,gCAAgC;EAChC,SAAS;EACT,qBAAqB;AACvB;;AAEA;EACE,SAAS;EACT,kBAAkB;AACpB;;AAEA;;;;;;;;;;;;;;EAcE,eAAe;AACjB","sourcesContent":["/* Copyright 2014 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n.annotationLayer section {\n  position: absolute;\n}\n\n.annotationLayer .linkAnnotation > a,\n.annotationLayer .buttonWidgetAnnotation.pushButton > a {\n  position: absolute;\n  font-size: 1em;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.annotationLayer .linkAnnotation > a:hover,\n.annotationLayer .buttonWidgetAnnotation.pushButton > a:hover {\n  opacity: 0.2;\n  background: #ff0;\n  box-shadow: 0px 2px 10px #ff0;\n}\n\n.annotationLayer .textAnnotation img {\n  position: absolute;\n  cursor: pointer;\n}\n\n.annotationLayer .textWidgetAnnotation input,\n.annotationLayer .textWidgetAnnotation textarea,\n.annotationLayer .choiceWidgetAnnotation select,\n.annotationLayer .buttonWidgetAnnotation.checkBox input,\n.annotationLayer .buttonWidgetAnnotation.radioButton input {\n  background-color: rgba(0, 54, 255, 0.13);\n  border: 1px solid transparent;\n  box-sizing: border-box;\n  font-size: 9px;\n  height: 100%;\n  margin: 0;\n  padding: 0 3px;\n  vertical-align: top;\n  width: 100%;\n}\n\n.annotationLayer .choiceWidgetAnnotation select option {\n  padding: 0;\n}\n\n.annotationLayer .buttonWidgetAnnotation.radioButton input {\n  border-radius: 50%;\n}\n\n.annotationLayer .textWidgetAnnotation textarea {\n  font: message-box;\n  font-size: 9px;\n  resize: none;\n}\n\n.annotationLayer .textWidgetAnnotation input[disabled],\n.annotationLayer .textWidgetAnnotation textarea[disabled],\n.annotationLayer .choiceWidgetAnnotation select[disabled],\n.annotationLayer .buttonWidgetAnnotation.checkBox input[disabled],\n.annotationLayer .buttonWidgetAnnotation.radioButton input[disabled] {\n  background: none;\n  border: 1px solid transparent;\n  cursor: not-allowed;\n}\n\n.annotationLayer .textWidgetAnnotation input:hover,\n.annotationLayer .textWidgetAnnotation textarea:hover,\n.annotationLayer .choiceWidgetAnnotation select:hover,\n.annotationLayer .buttonWidgetAnnotation.checkBox input:hover,\n.annotationLayer .buttonWidgetAnnotation.radioButton input:hover {\n  border: 1px solid #000;\n}\n\n.annotationLayer .textWidgetAnnotation input:focus,\n.annotationLayer .textWidgetAnnotation textarea:focus,\n.annotationLayer .choiceWidgetAnnotation select:focus {\n  background: none;\n  border: 1px solid transparent;\n}\n\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,\n.annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before {\n  background-color: #000;\n  content: '';\n  display: block;\n  position: absolute;\n}\n\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after {\n  height: 80%;\n  left: 45%;\n  width: 1px;\n}\n\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before {\n  transform: rotate(45deg);\n}\n\n.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after {\n  transform: rotate(-45deg);\n}\n\n.annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before {\n  border-radius: 50%;\n  height: 50%;\n  left: 30%;\n  top: 20%;\n  width: 50%;\n}\n\n.annotationLayer .textWidgetAnnotation input.comb {\n  font-family: monospace;\n  padding-left: 2px;\n  padding-right: 0;\n}\n\n.annotationLayer .textWidgetAnnotation input.comb:focus {\n  /*\n   * Letter spacing is placed on the right side of each character. Hence, the\n   * letter spacing of the last character may be placed outside the visible\n   * area, causing horizontal scrolling. We avoid this by extending the width\n   * when the element has focus and revert this when it loses focus.\n   */\n  width: 115%;\n}\n\n.annotationLayer .buttonWidgetAnnotation.checkBox input,\n.annotationLayer .buttonWidgetAnnotation.radioButton input {\n  appearance: none;\n  padding: 0;\n}\n\n.annotationLayer .popupWrapper {\n  position: absolute;\n  width: 20em;\n}\n\n.annotationLayer .popup {\n  position: absolute;\n  z-index: 200;\n  max-width: 20em;\n  background-color: #FFFF99;\n  box-shadow: 0px 2px 5px #333;\n  border-radius: 2px;\n  padding: 0.6em;\n  margin-left: 5px;\n  cursor: pointer;\n  font: message-box;\n  word-wrap: break-word;\n}\n\n.annotationLayer .popup h1 {\n  font-size: 1em;\n  border-bottom: 1px solid #000000;\n  margin: 0;\n  padding-bottom: 0.2em;\n}\n\n.annotationLayer .popup p {\n  margin: 0;\n  padding-top: 0.2em;\n}\n\n.annotationLayer .highlightAnnotation,\n.annotationLayer .underlineAnnotation,\n.annotationLayer .squigglyAnnotation,\n.annotationLayer .strikeoutAnnotation,\n.annotationLayer .freeTextAnnotation,\n.annotationLayer .lineAnnotation svg line,\n.annotationLayer .squareAnnotation svg rect,\n.annotationLayer .circleAnnotation svg ellipse,\n.annotationLayer .polylineAnnotation svg polyline,\n.annotationLayer .polygonAnnotation svg polygon,\n.annotationLayer .caretAnnotation,\n.annotationLayer .inkAnnotation svg polyline,\n.annotationLayer .stampAnnotation,\n.annotationLayer .fileAttachmentAnnotation {\n  cursor: pointer;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/mablviewer.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/mablviewer.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "body {\n  background-color: white;\n  margin: 0;\n  padding: 0;\n}\n#viewerContainer {\n  overflow: auto;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n}\n#viewer {\n  display: none;\n}\n#mabl-spinner {\n  position: fixed;\n  left: 50%;\n  top: 50%;\n  background-color: white;\n  z-index: 100;\n  height: 305px;\n  margin-top: -152px;\n  width: 218px;\n  margin-left: -109px;\n}\n#errorDialog {\n  font-family: 'Titillium Web', sans-serif;\n  font-size: 2em;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  margin: auto;\n  z-index: 1000;\n  text-align: center;\n}\n#errorMessage {\n  padding-top: 3em;\n}\n\n#errorDisclosure {\n  text-decoration: underline;\n  padding-bottom: 2em;\n}\n#errorDND {\n  z-index: 100;\n  font-style: italic;\n  pointer-events: none;\n  color: #18c5cf;\n}\n", "",{"version":3,"sources":["webpack://./src/mablviewer.css"],"names":[],"mappings":"AAAA;EACE,uBAAuB;EACvB,SAAS;EACT,UAAU;AACZ;AACA;EACE,cAAc;EACd,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,aAAa;AACf;AACA;EACE,eAAe;EACf,SAAS;EACT,QAAQ;EACR,uBAAuB;EACvB,YAAY;EACZ,aAAa;EACb,kBAAkB;EAClB,YAAY;EACZ,mBAAmB;AACrB;AACA;EACE,wCAAwC;EACxC,cAAc;EACd,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,MAAM;EACN,SAAS;EACT,OAAO;EACP,QAAQ;EACR,YAAY;EACZ,aAAa;EACb,kBAAkB;AACpB;AACA;EACE,gBAAgB;AAClB;;AAEA;EACE,0BAA0B;EAC1B,mBAAmB;AACrB;AACA;EACE,YAAY;EACZ,kBAAkB;EAClB,oBAAoB;EACpB,cAAc;AAChB","sourcesContent":["body {\n  background-color: white;\n  margin: 0;\n  padding: 0;\n}\n#viewerContainer {\n  overflow: auto;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n}\n#viewer {\n  display: none;\n}\n#mabl-spinner {\n  position: fixed;\n  left: 50%;\n  top: 50%;\n  background-color: white;\n  z-index: 100;\n  height: 305px;\n  margin-top: -152px;\n  width: 218px;\n  margin-left: -109px;\n}\n#errorDialog {\n  font-family: 'Titillium Web', sans-serif;\n  font-size: 2em;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  margin: auto;\n  z-index: 1000;\n  text-align: center;\n}\n#errorMessage {\n  padding-top: 3em;\n}\n\n#errorDisclosure {\n  text-decoration: underline;\n  padding-bottom: 2em;\n}\n#errorDND {\n  z-index: 100;\n  font-style: italic;\n  pointer-events: none;\n  color: #18c5cf;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/text_layer_builder.css":
/*!**************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/text_layer_builder.css ***!
  \**************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Copyright 2014 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n.textLayer {\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  opacity: 0.2;\n  line-height: 1.0;\n}\n\n.textLayer > div {\n  color: transparent;\n  position: absolute;\n  white-space: pre;\n  cursor: text;\n  transform-origin: 0% 0%;\n}\n\n.textLayer .highlight {\n  margin: -1px;\n  padding: 1px;\n\n  background-color: rgb(180, 0, 170);\n  border-radius: 4px;\n}\n\n.textLayer .highlight.begin {\n  border-radius: 4px 0px 0px 4px;\n}\n\n.textLayer .highlight.end {\n  border-radius: 0px 4px 4px 0px;\n}\n\n.textLayer .highlight.middle {\n  border-radius: 0px;\n}\n\n.textLayer .highlight.selected {\n  background-color: rgb(0, 100, 0);\n}\n\n.textLayer ::selection { background: rgb(0,0,255); }\n\n.textLayer .endOfContent {\n  display: block;\n  position: absolute;\n  left: 0px;\n  top: 100%;\n  right: 0px;\n  bottom: 0px;\n  z-index: -1;\n  cursor: default;\n  user-select: none;\n}\n\n.textLayer .endOfContent.active {\n  top: 0px;\n}\n", "",{"version":3,"sources":["webpack://./src/text_layer_builder.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;EAaE;;AAEF;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,QAAQ;EACR,SAAS;EACT,gBAAgB;EAChB,YAAY;EACZ,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,kBAAkB;EAClB,gBAAgB;EAChB,YAAY;EACZ,uBAAuB;AACzB;;AAEA;EACE,YAAY;EACZ,YAAY;;EAEZ,kCAAkC;EAClC,kBAAkB;AACpB;;AAEA;EACE,8BAA8B;AAChC;;AAEA;EACE,8BAA8B;AAChC;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,gCAAgC;AAClC;;AAEA,yBAAyB,wBAAwB,EAAE;;AAEnD;EACE,cAAc;EACd,kBAAkB;EAClB,SAAS;EACT,SAAS;EACT,UAAU;EACV,WAAW;EACX,WAAW;EACX,eAAe;EACf,iBAAiB;AACnB;;AAEA;EACE,QAAQ;AACV","sourcesContent":["/* Copyright 2014 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n.textLayer {\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  opacity: 0.2;\n  line-height: 1.0;\n}\n\n.textLayer > div {\n  color: transparent;\n  position: absolute;\n  white-space: pre;\n  cursor: text;\n  transform-origin: 0% 0%;\n}\n\n.textLayer .highlight {\n  margin: -1px;\n  padding: 1px;\n\n  background-color: rgb(180, 0, 170);\n  border-radius: 4px;\n}\n\n.textLayer .highlight.begin {\n  border-radius: 4px 0px 0px 4px;\n}\n\n.textLayer .highlight.end {\n  border-radius: 0px 4px 4px 0px;\n}\n\n.textLayer .highlight.middle {\n  border-radius: 0px;\n}\n\n.textLayer .highlight.selected {\n  background-color: rgb(0, 100, 0);\n}\n\n.textLayer ::selection { background: rgb(0,0,255); }\n\n.textLayer .endOfContent {\n  display: block;\n  position: absolute;\n  left: 0px;\n  top: 100%;\n  right: 0px;\n  bottom: 0px;\n  z-index: -1;\n  cursor: default;\n  user-select: none;\n}\n\n.textLayer .endOfContent.active {\n  top: 0px;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./src/mabl_attention_move.gif":
/*!*************************************!*\
  !*** ./src/mabl_attention_move.gif ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "mabl_attention_move.gif");

/***/ }),

/***/ "./src/mabl_error_artwork_Unplugged.gif":
/*!**********************************************!*\
  !*** ./src/mabl_error_artwork_Unplugged.gif ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "mabl_error_artwork_Unplugged.gif");

/***/ }),

/***/ "./src/annotation_layer_builder.css":
/*!******************************************!*\
  !*** ./src/annotation_layer_builder.css ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var api = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./annotation_layer_builder.css */ "./node_modules/css-loader/dist/cjs.js!./src/annotation_layer_builder.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "./src/mablviewer.css":
/*!****************************!*\
  !*** ./src/mablviewer.css ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var api = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./mablviewer.css */ "./node_modules/css-loader/dist/cjs.js!./src/mablviewer.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "./src/text_layer_builder.css":
/*!************************************!*\
  !*** ./src/text_layer_builder.css ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var api = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./text_layer_builder.css */ "./node_modules/css-loader/dist/cjs.js!./src/text_layer_builder.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js?esModule=false&filename=[name].[contenthash].js!./src/pdf_js/build/pdf.worker.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js?esModule=false&filename=[name].[contenthash].js!./src/pdf_js/build/pdf.worker.js ***!
  \*********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = function Worker_fn() {
  return new Worker(__webpack_require__.p + "pdf.worker.9e2021092643447a5b9f.js");
}


/***/ }),

/***/ "?47a5":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?3676":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?dac2":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?f7a6":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c6f9":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!******************************!*\
  !*** ./src/mablPdfViewer.js ***!
  \******************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PDF_ERROR_DIALOG_ID": () => (/* binding */ PDF_ERROR_DIALOG_ID),
/* harmony export */   "PDF_SPINNER_ID": () => (/* binding */ PDF_SPINNER_ID),
/* harmony export */   "PDF_VIEWER_CONTAINER_ID": () => (/* binding */ PDF_VIEWER_CONTAINER_ID),
/* harmony export */   "PDF_VIEWER_ID": () => (/* binding */ PDF_VIEWER_ID),
/* harmony export */   "mablPdfViewer": () => (/* binding */ mablPdfViewer),
/* harmony export */   "setGlobalWorkerLocation": () => (/* binding */ setGlobalWorkerLocation)
/* harmony export */ });
/* harmony import */ var _text_layer_builder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text_layer_builder.js */ "./src/text_layer_builder.js");
/* harmony import */ var _mabl_pdf_js_lib_web_pdf_link_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mabl/pdf.js/lib/web/pdf_link_service */ "./src/pdf_js/lib/web/pdf_link_service.js");
/* harmony import */ var _mabl_pdf_js_lib_web_event_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mabl/pdf.js/lib/web/event_utils */ "./src/pdf_js/lib/web/event_utils.js");
/* harmony import */ var _annotation_layer_builder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./annotation_layer_builder.js */ "./src/annotation_layer_builder.js");
/* harmony import */ var _mabl_pdf_js_webpack__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mabl/pdf.js/webpack */ "./src/pdf_js/webpack.js");
/* harmony import */ var _mabl_pdf_js_webpack__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_mabl_pdf_js_webpack__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _text_layer_builder_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./text_layer_builder.css */ "./src/text_layer_builder.css");
/* harmony import */ var _text_layer_builder_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_text_layer_builder_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _annotation_layer_builder_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./annotation_layer_builder.css */ "./src/annotation_layer_builder.css");
/* harmony import */ var _annotation_layer_builder_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_annotation_layer_builder_css__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _mablviewer_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mablviewer.css */ "./src/mablviewer.css");
/* harmony import */ var _mablviewer_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_mablviewer_css__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _mabl_attention_move_gif__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mabl_attention_move.gif */ "./src/mabl_attention_move.gif");
/* harmony import */ var _mabl_error_artwork_Unplugged_gif__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mabl_error_artwork_Unplugged.gif */ "./src/mabl_error_artwork_Unplugged.gif");










var PDF_VIEWER_CONTAINER_ID = 'viewerContainer';
var PDF_VIEWER_ID = 'viewer';
var PDF_ERROR_DIALOG_ID = 'errorDialog';
var PDF_SPINNER_ID = 'mabl-spinner';

class mablPdfViewer {
  constructor() {
    this.renderPage = this.renderPage.bind(this);
    this.renderLayers = this.renderLayers.bind(this);
    this.handleErrorUpload = this.handleErrorUpload.bind(this);
    this.displayPdf = this.displayPdf.bind(this);
  }

  displayPdf(pdfUrl, pdfName, viewerElem, cMapUrl) {
    cMapUrl = cMapUrl || 'cmaps/';
    var cMapPacked = true;
    this.spinnerDiv = this.getSpinnerDiv();
    this.errorDialog = this.getErrorDiv();
    this.viewerElement = viewerElem || document.getElementById(PDF_VIEWER_ID) || this.createViewer();
    this.linkService = new _mabl_pdf_js_lib_web_pdf_link_service__WEBPACK_IMPORTED_MODULE_1__.PDFLinkService({
      eventBus: new _mabl_pdf_js_lib_web_event_utils__WEBPACK_IMPORTED_MODULE_2__.EventBus()
    });

    if (pdfName) {
      document.title = 'mabl PDF: ' + pdfName;
      this.pdfName = pdfName;
    }

    if (!pdfUrl) {
      this.displayError('No PDF URL was specified');
      return;
    }

    var loadingTask = _mabl_pdf_js_webpack__WEBPACK_IMPORTED_MODULE_4__.getDocument({
      url: pdfUrl,
      cMapUrl,
      cMapPacked,
      rangeChunkSize: 1000000
    });
    return loadingTask.promise.then(pdf => {
      this.linkService.setDocument(pdf, null);
      var pagePromises = [];

      for (var pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        pagePromises.push(pdf.getPage(pageNum).then(this.renderPage));
      }

      return Promise.all(pagePromises);
    }).catch(err => {
      this.displayError('Error loading PDF', err);
      throw err;
    });
  }

  createViewer() {
    var container = document.createElement('div'); // we never actually use the container, but we had it at launch and don't want to have the DOM change

    var viewer = document.createElement('div');
    container.id = PDF_VIEWER_CONTAINER_ID;
    viewer.id = PDF_VIEWER_ID;
    viewer.class = 'pdfViewer';
    container.appendChild(viewer);
    document.body.appendChild(container);
    return viewer;
  }

  getSpinnerDiv() {
    var spinnerDiv = document.getElementById(PDF_SPINNER_ID);

    if (!spinnerDiv) {
      spinnerDiv = document.createElement('div');
      spinnerDiv.id = PDF_SPINNER_ID;
      var spinnerImg = document.createElement('img');
      spinnerImg.src = _mabl_attention_move_gif__WEBPACK_IMPORTED_MODULE_8__["default"];
      spinnerDiv.appendChild(spinnerImg);
      document.body.appendChild(spinnerDiv);
    }

    return spinnerDiv;
  }

  getErrorDiv() {
    var errorDiv = document.getElementById(PDF_ERROR_DIALOG_ID);

    if (!errorDiv) {
      errorDiv = document.createElement('div');
      var errorMessage = document.createElement('div');
      errorMessage.id = 'errorMessage';
      var errorImg = document.createElement('img');
      errorImg.src = _mabl_error_artwork_Unplugged_gif__WEBPACK_IMPORTED_MODULE_9__["default"];
      errorDiv.appendChild(errorImg);
      var apologyMessage = document.createElement('div');
      apologyMessage.id = 'errorMessage';
      apologyMessage.innerText = "I'm sorry, we couldn't load your PDF.";
      errorDiv.appendChild(apologyMessage);
      var errorDisclosure = document.createElement('div');
      errorDisclosure.id = 'errorDisclosure';
      errorDisclosure.innerText = 'See error';
      var errorDetails = document.createElement('div');
      errorDetails.setAttribute('hidden', 'true');
      errorDetails.id = 'errorText';
      errorDisclosure.addEventListener('click', () => {
        // show more error details
        errorDetails.removeAttribute('hidden');
      });
      errorDiv.appendChild(errorDisclosure);
      errorDiv.appendChild(errorDetails);
      var dragAndDropHint = document.createElement('p');
      var tryAgain = document.createElement('p');
      tryAgain.innerText = "Let's try that again...";
      dragAndDropHint.appendChild(tryAgain);
      var dragAndDropText = document.createElement('p');
      dragAndDropText.innerHTML = 'Drag and drop your PDF here to continue.';
      dragAndDropText.id = 'errorDND';
      dragAndDropHint.appendChild(dragAndDropText);
      errorDiv.appendChild(dragAndDropHint);
      errorDiv.addEventListener('dragenter', event => {
        event.stopPropagation();
        event.preventDefault();
        errorImg.src = _mabl_attention_move_gif__WEBPACK_IMPORTED_MODULE_8__["default"];
      }, false);
      errorDiv.addEventListener('dragleave', event => {
        event.stopPropagation();
        event.preventDefault();
        errorImg.src = _mabl_error_artwork_Unplugged_gif__WEBPACK_IMPORTED_MODULE_9__["default"];
      }, false);
      errorDiv.addEventListener('dragover', event => {
        event.stopPropagation();
        event.preventDefault();
      }, false);
      errorDiv.addEventListener('drop', this.handleErrorUpload, false);
      errorDiv.hidden = true;
      errorDiv.id = PDF_ERROR_DIALOG_ID;
      document.body.appendChild(errorDiv);
    }

    return errorDiv;
  }

  displayError(text, details) {
    this.disableProgress();
    var errorSpan = document.getElementById('errorText');
    errorSpan.innerText = "".concat(text, " ").concat(details || '');
    errorDialog.removeAttribute('hidden');
    this.viewerElement.setAttribute('hidden', 'true');
  }

  renderPage(page) {
    var pageDiv = document.createElement('div');
    var canvasWrapper = document.createElement('div');
    var canvas = document.createElement('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    var context = canvas.getContext('2d');
    var viewport = page.getViewport({
      scale: canvas.width / page.getViewport({
        scale: 1.0
      }).width
    });
    var pageNum = page.pageNumber;
    var renderContext = {
      canvasContext: context,
      viewport: viewport
    }; // these five attributes are for maintaining compatibility with beta release
    // version

    pageDiv.setAttribute('data-page-number', pageNum);
    pageDiv.setAttribute('data-loaded', true);
    pageDiv.setAttribute('class', 'page');
    canvas.id = 'page' + pageNum;
    canvasWrapper.setAttribute('class', 'canvasWrapper');
    pageDiv.setAttribute('style', 'position: relative');
    this.viewerElement.appendChild(pageDiv);
    canvas.height = viewport.height;
    canvas.width = viewport.width;
    canvasWrapper.appendChild(canvas);
    pageDiv.appendChild(canvasWrapper);
    this.linkService.cachePageRef(pageNum, page.ref);
    return page.render(renderContext).promise.then(this.renderLayers(page, pageDiv, viewport));
  }

  renderLayers(page, pageDiv, viewport) {
    return page.getTextContent().then(textContent => {
      // Create div which will hold text-fragments
      var textLayerDiv = document.createElement('div');
      var textLayer = new _text_layer_builder_js__WEBPACK_IMPORTED_MODULE_0__.TextLayerBuilder({
        textLayerDiv: textLayerDiv,
        pageIndex: page._pageIndex,
        viewport: viewport
      });
      var annotationLayerDiv = document.createElement('div');
      var annotationLayer = new _annotation_layer_builder_js__WEBPACK_IMPORTED_MODULE_3__.AnnotationLayerBuilder({
        pageDiv,
        pdfPage: page,
        linkService: this.linkService,
        div: annotationLayerDiv
      });
      textLayerDiv.setAttribute('class', 'textLayer');
      textLayer.setTextContent(textContent);
      textLayer.render();
      pageDiv.appendChild(textLayerDiv);
      annotationLayer.render(viewport);

      if (page._pageIndex === 0) {
        this.disableProgress();
        this.viewerElement.style.display = 'block';
      }
    });
  }

  handleErrorUpload(event) {
    var failedUploadErrorMessage = 'That PDF upload did not seem to work. Try again!';
    event.stopPropagation();
    event.preventDefault(); // TODO: check if multiples break things

    var file = event.dataTransfer.files[0];

    if (!file || !file.type || file.type.indexOf('pdf') === -1) {
      //TODO: add error handling for non PDFs
      this.displayError(failedUploadErrorMessage);
      return;
    }

    var reader = new FileReader();

    reader.onload = (that => {
      return event => {
        that.displayPdf(event.target.result, that.pdfName);
      };
    })(this);

    reader.onerror = (that => {
      return _event => {
        reader.abort();
        that.displayError(failedUploadErrorMessage);
      };
    })(this);

    reader.readAsDataURL(file);
    errorDialog.setAttribute('hidden', true);
  }

  disableProgress() {
    this.spinnerDiv.setAttribute('hidden', 'true');
  }

}

function setGlobalWorkerLocation(url) {
  GlobalWorkerOptions.workerSrc = url;
}

})();

mablPdfViewer = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=libmablPdfViewer.js.map