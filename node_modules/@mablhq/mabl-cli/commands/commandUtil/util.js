"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCredentialType = exports.parseColonJoinedVariablePair = exports.validateValuePairInputs = exports.validateArrayInputs = exports.getWorkspaceIdFromAppOrEnv = exports.getJourneyFlowArray = exports.TEST_WITHOUT_FLOWS_MESSAGE = exports.getWorkspaceId = exports.failWrapper = exports.getDescribeDescriptions = void 0;
const mablApi_1 = require("../../mablApi");
const cliConfigProvider_1 = require("../../providers/cliConfigProvider");
const constants_1 = require("../constants");
const loggingProvider_1 = require("../../providers/logging/loggingProvider");
const pluralize_1 = __importDefault(require("pluralize"));
const chalk = require('chalk');
function getDescribeDescriptions(entityName) {
    return `Describe a specific ${entityName}`;
}
exports.getDescribeDescriptions = getDescribeDescriptions;
function failWrapper(func, exitCodeOnError = 1) {
    return (parsed) => func(parsed).catch((error) => {
        var _a;
        loggingProvider_1.logger.error(chalk.red.bold((_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : 'An unexpected error occurred'));
        loggingProvider_1.logger.error(error.stack);
        if (exitCodeOnError) {
            process.exitCode = exitCodeOnError;
        }
    });
}
exports.failWrapper = failWrapper;
async function getWorkspaceId(parsed) {
    const workspaceId = parsed[constants_1.CommandArgWorkspaceId];
    if (workspaceId) {
        return workspaceId;
    }
    const configuredWorkspace = await cliConfigProvider_1.CliConfigProvider.getWorkspace();
    if (configuredWorkspace === null || configuredWorkspace === void 0 ? void 0 : configuredWorkspace.id) {
        return configuredWorkspace.id;
    }
    throw new Error('Please specify a workspace ID (--workspace-id) or configure a default in the CLI (mabl config set workspace <id>)');
}
exports.getWorkspaceId = getWorkspaceId;
exports.TEST_WITHOUT_FLOWS_MESSAGE = `Test does not have any flows. You may need to specify a branch [--${constants_1.CommandArgMablBranch}] if the test is not on master.`;
async function getJourneyFlowArray(journey, apiClient, branchName) {
    var _a;
    if (!((_a = journey.flows) === null || _a === void 0 ? void 0 : _a.length)) {
        throw new Error(exports.TEST_WITHOUT_FLOWS_MESSAGE);
    }
    const flows = {};
    const requests = journey.flows.map((flowId) => apiClient
        .getFlow(flowId, branchName)
        .then((result) => (flows[flowId] = result)));
    await Promise.all(requests);
    return journey.flows.map((flowId) => flows[flowId]).filter((flow) => flow);
}
exports.getJourneyFlowArray = getJourneyFlowArray;
async function getWorkspaceIdFromAppOrEnv(apiClient, applicationId, environmentId) {
    if (applicationId) {
        const application = await apiClient.getApplication(applicationId);
        return application.organization_id;
    }
    else if (environmentId) {
        const environment = await apiClient.getEnvironment(environmentId);
        return environment.organization_id;
    }
    throw new Error('Either Application or Environment ID must be provided');
}
exports.getWorkspaceIdFromAppOrEnv = getWorkspaceIdFromAppOrEnv;
function validateArrayInputs(possibleInput, errorMessage) {
    if (possibleInput !== undefined) {
        const labels = possibleInput;
        if (labels.some((label) => /[,|;]/.test(label))) {
            throw new Error(errorMessage);
        }
    }
}
exports.validateArrayInputs = validateArrayInputs;
function validateValuePairInputs(inputName, inputs) {
    if (inputs) {
        const missingColonInputs = inputs
            .map((input) => input.trim())
            .filter((input) => !/^([^:]+)?:(.+)?$/m.test(input));
        if (missingColonInputs.length > 0) {
            throw new Error(`${inputName} ${(0, pluralize_1.default)('value', missingColonInputs.length)} must separate kev/value with a colon ':', [${missingColonInputs.join(',')}]`);
        }
        const missingNameInputs = inputs
            .map((input) => input.replace(/^[ ]+/, ''))
            .filter((input) => !/^([^:]+):(.+)?$/m.test(input));
        if (missingNameInputs.length > 0) {
            throw new Error(`${inputName} ${(0, pluralize_1.default)('name', missingNameInputs.length)} cannot be blank [${missingNameInputs.join(',')}]`);
        }
        const illegalCharacterHeaders = inputs.filter((input) => /[\n\r]/m.test(input));
        if (illegalCharacterHeaders.length > 0) {
            const escapedHeaders = illegalCharacterHeaders.map((input) => input.replace('\n', '\\n').replace('\r', '\\r'));
            throw new Error(`${inputName} shouldn't contain carriage return or line feed characters [${escapedHeaders.join(',')}]`);
        }
        const wrappingWhitespace = inputs.filter((header) => !/^([^\s:]{1,2}|[^\s:][^:]+[^\s:]):([^\s:]{1,2}|[^\s:][^:]+[^\s:])?$/m.test(header));
        if (wrappingWhitespace.length > 0) {
            const cleanFunction = (header) => {
                const { name, value } = parseColonJoinedVariablePair(header);
                return [name, value].map((part) => part.trim()).join(':');
            };
            const cleaned = inputs.map(cleanFunction);
            const cleanedAffectedHeaders = wrappingWhitespace.map(cleanFunction);
            loggingProvider_1.logger.info(chalk.yellow.bold(`${inputName} wrapping whitespace detected. Whitespace has been trimmed to [`) +
                chalk.white.bold(cleanedAffectedHeaders.join(',')) +
                chalk.yellow.bold(']'));
            return cleaned;
        }
    }
    return inputs;
}
exports.validateValuePairInputs = validateValuePairInputs;
function parseColonJoinedVariablePair(input) {
    const name = input.substring(0, input.indexOf(':'));
    const value = input.substring(input.indexOf(':') + 1);
    return { name, value };
}
exports.parseColonJoinedVariablePair = parseColonJoinedVariablePair;
function getCredentialType(credential) {
    if (credential.cloud_only) {
        return credential.type === mablApi_1.Credentials.TypeEnum.Basic
            ? 'Cloud'
            : 'Cloud with MFA';
    }
    return credential.type === mablApi_1.Credentials.TypeEnum.Basic
        ? 'Basic'
        : 'Basic with MFA';
}
exports.getCredentialType = getCredentialType;
