"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOutReportOptions = exports.handleReportingForTestsRun = void 0;
const constants_1 = require("../commands/constants");
const TestResult_1 = require("../core/execution/TestResult");
const loggingProvider_1 = require("../providers/logging/loggingProvider");
const mochAwesomeReporter_1 = require("./mochAwesome/mochAwesomeReporter");
const playwright_reporter_1 = require("@mablhq/playwright-reporter");
async function handleReportingForTestsRun(reporter, testResults, apiClient, workspaceId, reportOptions, browser) {
    let options;
    try {
        options = reportOptions ? parseOutReportOptions(reportOptions) : {};
    }
    catch (error) {
        throw new Error('Could not parse the supplied reporter options');
    }
    try {
        switch (reporter) {
            case constants_1.Reporter.Mochawesome:
                await (0, mochAwesomeReporter_1.generateMochAwesomeReportFromTestResults)(testResults, options);
                break;
            case constants_1.Reporter.Mabl:
                if (!workspaceId) {
                    throw new Error('Workspace ID is required for Mabl reporting');
                }
                if (!browser) {
                    throw new Error('Browser is required for Mabl reporting');
                }
                await generateMablReportFromTestResults(workspaceId, testResults, options, apiClient, browser);
                break;
            default:
                throw new Error(`Unsupported reporter options supplied: ${reporter}`);
        }
    }
    catch (error) {
        loggingProvider_1.logger.error(`Unable to create report for the test run using reporter: ${reporter} due to Error: ${error}`);
    }
}
exports.handleReportingForTestsRun = handleReportingForTestsRun;
async function generateMablReportFromTestResults(workspaceId, testResults, _options, apiClient, browser) {
    const reporterApiClient = new playwright_reporter_1.MablApiClient({
        httpClient: apiClient.httpClient,
        apiUrl: apiClient.baseApiUrl,
        log: (message) => {
            loggingProvider_1.logger.info(message);
            return;
        },
        logError: (message) => {
            loggingProvider_1.logger.error(message);
            return;
        },
    });
    const uploadClient = new playwright_reporter_1.UploadClient({
        uploadServiceUrl: new URL(apiClient.baseApiUrl),
        httpClient: apiClient.httpClient,
    });
    const mablReporter = new playwright_reporter_1.MablReporter({
        apiClient: reporterApiClient,
        uploadClient,
        log: (message) => {
            loggingProvider_1.logger.debug(message);
        },
        logError: (message) => {
            loggingProvider_1.logger.error(message);
        },
        workspaceId,
        context: 'mabl_local',
    });
    for (const result of testResults.testResults.filter((result) => shouldReportTestResult(result.status))) {
        const outcome = testResultStatusToReporterOutcome(result.status);
        const status = outcome === 'passed' ? 'passed' : 'failed';
        try {
            await mablReporter.createTestResult({
                workspace_id: workspaceId,
                started_time: result.startTime,
                completed_time: result.endTime,
                test_id: result.testId,
                test_type: 'browser',
                outcome,
                status: testResultStatusToReporterStatus(result.status),
                browser,
            }, undefined, [], status);
        }
        catch (error) {
            loggingProvider_1.logger.error(`Unable to create Mabl test result due to error: ${error}`);
        }
    }
}
function parseOutReportOptions(suppliedOptions) {
    const reporterOptions = {};
    const pairs = suppliedOptions.split(',');
    pairs.forEach((pair) => {
        const [key, value] = pair.split('=', 3);
        if (value.toLowerCase() === 'false' || value.toLowerCase() === 'true') {
            reporterOptions[key] = value.toLowerCase() === 'true';
        }
        else if (!Number.isNaN(Number(value))) {
            reporterOptions[key] = Number(key);
        }
        else {
            reporterOptions[key] = value;
        }
    });
    return reporterOptions;
}
exports.parseOutReportOptions = parseOutReportOptions;
function testResultStatusToReporterOutcome(status) {
    if (status === TestResult_1.TestResultStatus.passed) {
        return 'passed';
    }
    return 'failed';
}
function shouldReportTestResult(status) {
    return (status === TestResult_1.TestResultStatus.failed || status === TestResult_1.TestResultStatus.passed);
}
function testResultStatusToReporterStatus(status) {
    if (status === TestResult_1.TestResultStatus.passed) {
        return 'completed';
    }
    return 'failed';
}
