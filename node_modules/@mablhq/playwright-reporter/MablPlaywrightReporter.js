"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MablPlaywrightReporter = void 0;
const uploadService_1 = require("./uploadService");
const axios_1 = __importDefault(require("axios"));
const MablApiClient_1 = require("./common/MablApiClient");
const MablReporter_1 = require("./common/MablReporter");
class MablPlaywrightReporter {
    constructor(options) {
        var _a, _b, _c;
        this.testEndPromises = [];
        this.attachmentToTestMap = new Map();
        this.stepToAttachmentsMap = new Map();
        this.apiKey = options.apiKey;
        this.workspaceId = options.workspaceId;
        this.mablApiUrl = (_a = options.mablApiUrl) !== null && _a !== void 0 ? _a : MablApiClient_1.MABL_PROD_API_URL;
        this.verbose = (_b = options.verbose) !== null && _b !== void 0 ? _b : false;
        this.planName = options.planName;
        this.executionId = options.executionId;
        const axiosConfig = {
            auth: {
                username: 'key',
                password: this.apiKey,
            },
        };
        const httpClient = axios_1.default.create(axiosConfig);
        (_c = this.mablApiUrl) !== null && _c !== void 0 ? _c : (this.mablApiUrl = MablApiClient_1.MABL_PROD_API_URL);
        const apiClient = new MablApiClient_1.MablApiClient({
            httpClient,
            apiUrl: this.mablApiUrl,
            log: (message) => this.log(message),
            logError: (message) => console.error(message),
        });
        const uploadClient = new uploadService_1.UploadClient({
            authorizationProvider: () => Promise.resolve({
                type: 'key',
                key: this.apiKey,
            }),
            uploadServiceUrl: new URL(this.mablApiUrl),
            httpClient,
        });
        this.mablReporter = new MablReporter_1.MablReporter({
            apiClient,
            uploadClient,
            planName: this.planName,
            log: (message) => this.log(message),
            logError: (message) => console.error(message),
            workspaceId: this.workspaceId,
            executionId: this.executionId,
            context: 'external',
        });
    }
    onBegin(_config, suite) {
        this.suite = suite;
        this.planRunPromise = this.mablReporter.createPlanRunToMabl();
    }
    onTestEnd(test, result) {
        this.log(`Finished test: ${test.title}`);
        this.testEndPromises.push(this.postTestResult(test, result));
    }
    onEnd(result) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.log(`Finished the run: ${result.status}`);
            const projectSuites = (_a = this.suite) === null || _a === void 0 ? void 0 : _a.suites;
            if (!projectSuites) {
                return;
            }
            yield Promise.allSettled(this.testEndPromises);
            if (this.planName) {
                const planRunId = yield this.planRunPromise;
                if (planRunId) {
                    yield this.mablReporter.finalizePlanRun(planRunId, this.playwrightStatusToMablStatus(result.status));
                }
            }
        });
    }
    postTestResult(testCase, result) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const testResult = this.mapTestCaseToMablTestResult(testCase);
            testResult.parent_execution = yield this.planRunPromise;
            const screenshotFile = (_a = result.attachments.find((attachment) => attachment.name === 'screenshot')) === null || _a === void 0 ? void 0 : _a.path;
            const steps = yield this.mapStepsToMablExecutionSteps(testCase.id, result.steps);
            const status = result.status === 'passed' ? 'passed' : 'failed';
            return this.mablReporter.createTestResult(testResult, screenshotFile, steps, status);
        });
    }
    onStepEnd(test, result, step) {
        // Evaluate orphan mabl attachments
        const adoptedAttachments = Array.from(this.attachmentToTestMap.keys());
        for (const attachment of result.attachments) {
            if (!adoptedAttachments.find((mablAttachment) => mablAttachment === attachment) &&
                attachment.name.startsWith('mabl')) {
                this.attachmentToTestMap.set(attachment, step);
                this.stepToAttachmentsMap.set(step, [
                    ...(this.stepToAttachmentsMap.get(step) || []),
                    attachment,
                ]);
            }
        }
    }
    mapStepsToMablExecutionSteps(testId, steps) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(steps.map((step) => __awaiter(this, void 0, void 0, function* () {
                const mablStep = {
                    title: step.title,
                    startTime: step.startTime.toISOString(),
                    duration: step.duration,
                    status: step.error ? 'failed' : 'passed',
                    observations: [],
                    rawCategory: step.category,
                    category: this.mapStepCategoryToMablExecutionStepCategory(step.category),
                };
                // If there are adopted attachments, add them to the step
                const adoptedAttachments = Array.from(this.stepToAttachmentsMap.get(step) || []);
                for (const attachment of adoptedAttachments) {
                    if (attachment.name === 'mabl-log' && attachment.body) {
                        const logFile = yield this.mablReporter.uploadStepLogContent(testId, attachment.body.toString());
                        if (logFile) {
                            mablStep.observations.push({
                                type: 'log',
                                url: logFile,
                            });
                        }
                    }
                    if (attachment.name === 'mabl-screenshot' && attachment.body) {
                        //Write content to disk
                        const screenshotFile = yield this.mablReporter.uploadStepScreenshotContent(testId, attachment.body);
                        if (screenshotFile) {
                            mablStep.observations.push({
                                type: 'screenshot',
                                url: screenshotFile,
                            });
                        }
                    }
                }
                if (step.steps && step.steps.length > 0) {
                    mablStep.steps = yield this.mapStepsToMablExecutionSteps(testId, step.steps);
                }
                return mablStep;
            })));
        });
    }
    mapStepCategoryToMablExecutionStepCategory(category) {
        switch (category) {
            case 'hook':
                return 'setup';
            case 'fixture':
                return 'flow';
            case 'pw:api':
                return 'step';
            case 'attach':
                return 'internal';
            default:
                return 'unknown';
        }
    }
    mapTestCaseToMablTestResult(testCase) {
        var _a, _b, _c, _d, _e, _f;
        const lastResult = testCase.results[testCase.results.length - 1];
        let browserName = (_c = (_b = (_a = testCase.parent
            .project()) === null || _a === void 0 ? void 0 : _a.use) === null || _b === void 0 ? void 0 : _b.browserName) === null || _c === void 0 ? void 0 : _c.toLowerCase();
        if (!browserName) {
            browserName = (_f = (_e = (_d = testCase.parent
                .project()) === null || _d === void 0 ? void 0 : _d.use) === null || _e === void 0 ? void 0 : _e.defaultBrowserType) === null || _f === void 0 ? void 0 : _f.toLowerCase();
        }
        return {
            workspace_id: this.workspaceId,
            started_time: lastResult.startTime.getTime(),
            completed_time: lastResult.startTime.getTime() + lastResult.duration,
            test_ref_id: testCase.id,
            test_labels: [],
            test_name: testCase.title,
            test_type: 'browser',
            outcome: testCase.outcome() === 'unexpected' ? 'failed' : 'passed',
            status: testCase.outcome() === 'unexpected' ? 'failed' : 'completed',
            browser: mapBrowserNameToMablBrowserType(browserName),
        };
    }
    playwrightStatusToMablStatus(status) {
        switch (status) {
            case 'passed':
                return 'succeeded';
            case 'failed':
                return 'failed';
            case 'timedout':
                return 'failed';
            case 'interrupted':
                return 'terminated';
        }
    }
    log(message) {
        if (this.verbose) {
            console.log(message);
        }
    }
}
exports.MablPlaywrightReporter = MablPlaywrightReporter;
// Debugging helper to print playwright's objects
function circularSafe(value) {
    // implement circular safe JSON stringify
    const seen = new WeakSet();
    return JSON.stringify(value, (k, v) => {
        // eslint-disable-next-line no-null/no-null
        if (typeof v === 'object' && v !== null) {
            if (seen.has(v)) {
                return;
            }
            seen.add(v);
        }
        return v;
    });
}
function mapBrowserNameToMablBrowserType(browserName) {
    switch (browserName) {
        case 'chrome':
        case 'chromium':
            return 'chrome';
        case 'firefox':
            return 'firefox';
        case 'edge':
            return 'edge';
        case 'webkit':
            return 'webkit';
        default:
            return 'chrome';
    }
}
