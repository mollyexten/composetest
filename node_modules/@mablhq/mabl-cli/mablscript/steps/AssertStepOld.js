"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssertStepOld = void 0;
const ExtractAction_1 = require("../actions/ExtractAction");
const MablStep_1 = require("../MablStep");
const FindAction_1 = require("../actions/FindAction");
const domUtil_1 = require("../../domUtil");
const importer_1 = require("../importer");
const GetCurrentLocationDescriptor_1 = require("../types/GetCurrentLocationDescriptor");
const GetVariableDescriptor_1 = require("../types/GetVariableDescriptor");
const GetViewportDescriptor_1 = require("../types/GetViewportDescriptor");
const oldToNewAssertionTypes = {
    assert_contains: 'AssertContains',
    assert_does_not_contain: 'AssertDoesNotContain',
    assert_does_not_equal: 'AssertDoesNotEqual',
    assert_download: 'AssertDownload',
    assert_equals: 'AssertEquals',
    assert_greater_than: 'AssertGreaterThan',
    assert_greater_than_or_equals: 'AssertGreaterThanOrEquals',
    assert_less_than: 'AssertLessThan',
    assert_less_than_or_equals: 'AssertLessThanOrEquals',
    assert_not_present: 'AssertNotPresent',
    assert_present: 'AssertPresent',
    assert_starts_with: 'AssertStartsWith',
    assert_starts_without: 'AssertStartsWithout',
    assert_ends_with: 'AssertEndsWith',
    assert_ends_without: 'AssertEndsWithout',
};
class AssertStepOld extends MablStep_1.MablStep {
    constructor(name, args, actions) {
        super(name, args, actions, name);
        this.assertionType = '';
        this.assertAttribute = '';
        this.validate();
        this.setAssertAttribute();
        this.assertionType = this.name;
        this.primaryAction = actions[0];
        this.extractAction = actions[1];
        if (args.length === 1) {
            this.onFailure = args[0].onFailure;
            this.observationScope = args[0].observationScope;
        }
        else if (args.length === 2) {
            this.onFailure = args[1].onFailure;
            this.observationScope = args[1].observationScope;
        }
    }
    validate() {
        if (this.actions.length !== 2 &&
            !(this.actions[0] instanceof FindAction_1.FindAction) &&
            !(this.actions[1] instanceof ExtractAction_1.ExtractAction)) {
            throw new Error('Legacy assert steps should have exactly two sub action:  a find and an extract');
        }
    }
    setAssertAttribute() {
        this.assertAttribute = this.getActionArgs()[0];
    }
    getStepName() {
        return oldToNewAssertionTypes[this.getAssertionType()];
    }
    getAssertionType() {
        return this.assertionType;
    }
    toStepDescriptor() {
        const formatted = {};
        if (this.assertionType !== 'assert_present' &&
            this.assertionType !== 'assert_not_present') {
            formatted.assertionValue = this.assertAttribute;
        }
        if (this.extractAction) {
            formatted.extractType =
                ExtractAction_1.ExtractAction.mablscriptToYamlType[this.extractAction.extractionType];
            formatted.attribute = this.extractAction.extractionAttribute;
        }
        const find = this.primaryAction.toDescriptor();
        formatted.findOptions = find.selectorFindOption;
        if ((0, GetCurrentLocationDescriptor_1.isGetCurrentLocationDescriptor)(find) ||
            (0, GetVariableDescriptor_1.isGetVariableDescriptor)(find) ||
            (0, GetViewportDescriptor_1.isGetViewportDescriptor)(find)) {
            formatted.kind = find.kind;
        }
        else {
            switch (find.findType) {
                case domUtil_1.FindType.FIND_COOKIE:
                case domUtil_1.FindType.FIND_EMAIL:
                    formatted.findType = FindAction_1.findTypesToFormattedType[find.findType];
                    formatted.selector = find.findTarget;
                    break;
                case domUtil_1.FindType.FIND_FIRST:
                case domUtil_1.FindType.FIND_LAST:
                case domUtil_1.FindType.FIND_ANY:
                case domUtil_1.FindType.FIND_ALL:
                    formatted.findType = FindAction_1.findTypesToFormattedType[find.findType];
                    formatted.selector = find.findTarget;
                    break;
                case domUtil_1.FindType.FIND_ONE:
                    formatted.selector = find.findTarget.selector;
                    break;
                default:
                    throw new Error(`Error generating step descriptor for ${this.getStepName()}: Unexpected find type ${find.findType}`);
            }
        }
        formatted.assertArguments = {
            onFailure: this.onFailure,
            observationScope: this.observationScope,
        };
        return formatted;
    }
    getFormattedStep(_fullLocatorsOn) {
        const result = {};
        result[this.getStepName()] = { ...this.annotationsAsYml() };
        const formatted = result[this.getStepName()];
        if (this.extractAction) {
            formatted.attribute = this.extractAction.extractionAttribute;
            formatted.extractType =
                ExtractAction_1.ExtractAction.mablscriptToYamlType[this.extractAction.extractionType];
        }
        if (this.assertionType !== 'assert_present' &&
            this.assertionType !== 'assert_not_present') {
            formatted.assertionValue = this.assertAttribute;
        }
        const targetDescriptor = this.primaryAction.toDescriptor();
        if ((0, GetVariableDescriptor_1.isGetVariableDescriptor)(targetDescriptor)) {
            formatted.target = (0, GetVariableDescriptor_1.convertGetVariableDescriptorToYaml)(targetDescriptor);
        }
        else {
            formatted.target = targetDescriptor;
        }
        formatted.assertArguments = {
            onFailure: this.onFailure,
            observationScope: this.observationScope,
        };
        if (this.stepId()) {
            formatted.id = this.stepId();
        }
        return result;
    }
    getNewAssertionStep() {
        const yamlified = (0, importer_1.yamlifyTheLoadedSteps)([this]);
        const reloadedSteps = (0, importer_1.loadYamlSteps)(yamlified);
        const result = reloadedSteps[0];
        if (this.stepSourceIndexInFlow !== undefined) {
            result.setStepSourceIndexInFlow(this.stepSourceIndexInFlow);
        }
        this.actions.forEach((_oldAction, actionIndex) => {
            result.actions[actionIndex].setActionSourceIndexInStep(actionIndex);
        });
        if (this.actionSourceIndexInStep !== undefined) {
            result.setActionSourceIndexInStep(this.actionSourceIndexInStep);
        }
        return result;
    }
    static fromYaml(stepName, _stepArgs) {
        return new MablStep_1.MablStep(stepName, [], [], 'assert');
    }
}
exports.AssertStepOld = AssertStepOld;
AssertStepOld.mablScriptStepNames = Object.keys(oldToNewAssertionTypes);
AssertStepOld.yamlMablScriptNames = [];
