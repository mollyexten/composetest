"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitLines = exports.PRE_REQUEST_LISTEN = exports.convertMablAssertionsToExecArray = exports.convertMablVariableAssignmentsToExecArray = exports.createMablGeneratedScripts = exports.toPostmanScript = exports.replaceVariables = exports.getActualValue = exports.readBody = exports.getResponseContentType = exports.valueToUnquotedString = exports.assertionTypeSupportsCaseSensitivity = exports.assertionTargetSupportsCaseSensitivity = exports.humanizeAssertion = exports.getAssertionTargetArgument = exports.assertionHasTest = exports.isValidMablAssertion = exports.normalizeRegExpExpectedValue = exports.normalizeExpectedValue = exports.normalizeAssertionValue = exports.assertionRequiresValue = exports.filterValidMablAssertions = exports.filterValidMablVariableAssignments = exports.isValidMablVariableAssignment = exports.removeMablGeneratedScripts = exports.createEmptyRequestEvent = exports.findFirstMatchingEvent = exports.restoreCustomRequestFields = exports.deduplicateApiTestExecutionResults = exports.createEmptyVariable = exports.createEmptyAssertion = exports.humanizeAssertionType = exports.getAssertionTypesForTarget = exports.caseInsensitiveEquals = exports.compareStringsCaseInsensitive = exports.ASSERT_TYPES = exports.ASSERT_TARGETS = exports.COLLECTION_WITH_FOLDERS_ERROR = exports.HMAC_SHA1_SIGNATURE = exports.DEFAULT_ADD_OAUTH1_TO_HEADER_VALUE = exports.DEFAULT_OAUTH1_VERSION = exports.OAUTH1_AUTH = exports.NO_AUTH = exports.BEARER_TOKEN_AUTH = exports.BASIC_AUTH = exports.API_KEY_AUTH = exports.INHERIT_AUTH_FROM_PARENT_VALUE = exports.MABL_GENERATED_COMMENT = exports.MABL_GENERATED_ASSERTION_TOKEN = exports.TEST_LISTEN = void 0;
exports.getSnippetReferencesInTest = exports.getSnippetReferencesInCollection = exports.uuid = exports.postmanEventToExecutableSnippets = exports.postmanAuthToApiTestAuth = exports.getValueFromAuthVariables = exports.executableSnippetToApiTestSnippet = exports.executableSnippetsToPostmanEvent = exports.apiTestAuthToPostmanAuth = exports.insertTestConfigurationIntoFlow = exports.createCommentForApiTestSnippet = exports.convertMablSnippetsToExecArray = exports.createPostmanScript = exports.insertMablScriptsIntoCollection = exports.processPostmanItem = exports.replaceRawScriptWithExecArray = exports.removeInvalidHeaders = exports.processItemAuth = exports.mablAuthToPostman = exports.formatContent = exports.getRequestMode = exports.getFormDataArray = exports.isBinary = exports.isText = exports.isXML = exports.isJson = exports.isSupportedAuthType = exports.isItemDefinition = exports.isCollectionDefinition = exports.isItemGroupDefinition = exports.isFolder = exports.validateCollectionFeaturesForApiTestEditor = exports.generateRawScriptField = exports.processPostmanItems = exports.createEmptyRequest = exports.createEmptyRequestEventArray = void 0;
const newman_types_1 = require("./newman-types");
const lodash_1 = __importDefault(require("lodash"));
const uuid_1 = require("uuid");
const mablApi_1 = require("../../mablApi");
const encodingUtil_1 = require("../../util/encodingUtil");
const stepValidation_1 = require("../entityValidation/stepValidation");
exports.TEST_LISTEN = 'test';
exports.MABL_GENERATED_ASSERTION_TOKEN = '__MABL_GENERATED__';
exports.MABL_GENERATED_COMMENT = `// ${exports.MABL_GENERATED_ASSERTION_TOKEN} Do not edit below this line`;
exports.INHERIT_AUTH_FROM_PARENT_VALUE = 'inherit_from_parent';
exports.API_KEY_AUTH = 'apikey';
exports.BASIC_AUTH = 'basic';
exports.BEARER_TOKEN_AUTH = 'bearer';
exports.NO_AUTH = 'noauth';
exports.OAUTH1_AUTH = 'oauth1';
exports.DEFAULT_OAUTH1_VERSION = '1.0';
const ADD_OAUTH1_TO_HEADER = true;
const ADD_OAUTH1_TO_HEADER_VALUE = `${ADD_OAUTH1_TO_HEADER}`;
exports.DEFAULT_ADD_OAUTH1_TO_HEADER_VALUE = ADD_OAUTH1_TO_HEADER_VALUE;
exports.HMAC_SHA1_SIGNATURE = 'HMAC-SHA1';
exports.COLLECTION_WITH_FOLDERS_ERROR = 'Collections with folders are not supported';
const RESPONSE_PROPERTIES = {
    Size: 'size().body',
    Status: 'code',
    TextBody: 'text()',
};
exports.ASSERT_TARGETS = [
    { label: 'Header', value: newman_types_1.AssertionTarget.Header },
    { label: 'Status', value: newman_types_1.AssertionTarget.Status },
    { label: 'Size (bytes)', value: newman_types_1.AssertionTarget.Size },
    { label: 'JSON Body', value: newman_types_1.AssertionTarget.JSONBody },
    { label: 'Text Body', value: newman_types_1.AssertionTarget.TextBody },
];
exports.ASSERT_TYPES = [
    { label: 'Equals', value: newman_types_1.AssertionType.Equals },
    { label: 'Not equals', value: newman_types_1.AssertionType.NotEquals },
    { label: 'Contains', value: newman_types_1.AssertionType.Contains },
    { label: 'Not contains', value: newman_types_1.AssertionType.DoesNotContain },
    { label: 'Is present', value: newman_types_1.AssertionType.Present },
    { label: 'Not present', value: newman_types_1.AssertionType.NotPresent },
    { label: 'Greater than', value: newman_types_1.AssertionType.GreaterThan },
    {
        label: 'Greater than or equal to',
        value: newman_types_1.AssertionType.GreaterThanOrEqualTo,
    },
    { label: 'Less than', value: newman_types_1.AssertionType.LessThan },
    { label: 'Less than or equal to', value: newman_types_1.AssertionType.LessThanOrEqualTo },
    { label: 'Starts with', value: newman_types_1.AssertionType.StartsWith },
    { label: 'Ends with', value: newman_types_1.AssertionType.EndsWith },
    { label: 'Matches regular expression', value: newman_types_1.AssertionType.MatchesRegExp },
];
const EXPECTED_VALUE_TOKEN = '!!EXPECTED_VALUE!!';
const EXPECT_FUNCTIONS = {
    Equals: `eql(${EXPECTED_VALUE_TOKEN})`,
    NotEquals: `not.eql(${EXPECTED_VALUE_TOKEN})`,
    Contains: `include(${EXPECTED_VALUE_TOKEN})`,
    DoesNotContain: `not.include(${EXPECTED_VALUE_TOKEN})`,
    Present: `not.be.undefined`,
    NotPresent: `be.undefined`,
    GreaterThan: `be.above(${EXPECTED_VALUE_TOKEN})`,
    GreaterThanOrEqualTo: `be.at.least(${EXPECTED_VALUE_TOKEN})`,
    LessThan: `be.below(${EXPECTED_VALUE_TOKEN})`,
    LessThanOrEqualTo: `be.at.most(${EXPECTED_VALUE_TOKEN})`,
    StartsWith: `satisfy(value => value.startsWith(${EXPECTED_VALUE_TOKEN}))`,
    EndsWith: `satisfy(value => value.endsWith(${EXPECTED_VALUE_TOKEN}))`,
    MatchesRegExp: `match(${EXPECTED_VALUE_TOKEN})`,
};
const MEDIA_TYPE_TOKEN = "[0-9A-Za-z!#$%&'*+.^_`|~-]+";
function compareStringsCaseInsensitive(a, b) {
    a = a === null || a === void 0 ? void 0 : a.toUpperCase().toLowerCase();
    b = b === null || b === void 0 ? void 0 : b.toUpperCase().toLowerCase();
    if (!a) {
        return -1;
    }
    if (!b) {
        return 1;
    }
    return a.localeCompare(b, undefined, { sensitivity: 'base' });
}
exports.compareStringsCaseInsensitive = compareStringsCaseInsensitive;
function caseInsensitiveEquals(a, b) {
    return compareStringsCaseInsensitive(a, b) === 0;
}
exports.caseInsensitiveEquals = caseInsensitiveEquals;
function getAssertionTypesForTarget(target) {
    switch (target) {
        case newman_types_1.AssertionTarget.Size:
        case newman_types_1.AssertionTarget.Status:
            return exports.ASSERT_TYPES.filter((assertType) => [
                newman_types_1.AssertionType.Equals,
                newman_types_1.AssertionType.NotEquals,
                newman_types_1.AssertionType.GreaterThan,
                newman_types_1.AssertionType.GreaterThanOrEqualTo,
                newman_types_1.AssertionType.LessThan,
                newman_types_1.AssertionType.LessThanOrEqualTo,
            ].includes(assertType.value));
        case newman_types_1.AssertionTarget.Header:
        case newman_types_1.AssertionTarget.JSONBody:
        case newman_types_1.AssertionTarget.TextBody:
        default:
            return exports.ASSERT_TYPES;
    }
}
exports.getAssertionTypesForTarget = getAssertionTypesForTarget;
function humanizeAssertionType(assertionType) {
    switch (assertionType) {
        case 'NotEquals':
            return 'not equals';
        case 'DoesNotContain':
            return 'does not contain';
        case 'Present':
            return 'is present';
        case 'NotPresent':
            return 'is not present';
        case 'GreaterThan':
            return 'greater than';
        case 'GreaterThanOrEqualTo':
            return 'greater than or equal to';
        case 'LessThan':
            return 'less than';
        case 'LessThanOrEqualTo':
            return 'less than or equal to';
        case 'StartsWith':
            return 'starts with';
        case 'EndsWith':
            return 'ends with';
        case 'MatchesRegExp':
            return 'matches regular expression';
        default:
            return assertionType.toString().toLowerCase();
    }
}
exports.humanizeAssertionType = humanizeAssertionType;
function createEmptyAssertion(contentType) {
    const isJsonContent = !contentType || isJson(contentType);
    return {
        id: (0, uuid_1.v4)(),
        assertTarget: isJsonContent
            ? newman_types_1.AssertionTarget.JSONBody
            : isText(contentType) || isXML(contentType)
                ? newman_types_1.AssertionTarget.TextBody
                : newman_types_1.AssertionTarget.Header,
        assertType: newman_types_1.AssertionType.Present,
        description: '',
    };
}
exports.createEmptyAssertion = createEmptyAssertion;
function createEmptyVariable(contentType) {
    const isJsonContent = !contentType || isJson(contentType);
    return {
        id: (0, uuid_1.v4)(),
        assertTarget: isJsonContent
            ? newman_types_1.AssertionTarget.JSONBody
            : isText(contentType) || isXML(contentType)
                ? newman_types_1.AssertionTarget.TextBody
                : newman_types_1.AssertionTarget.Header,
        variableName: '',
        description: '',
    };
}
exports.createEmptyVariable = createEmptyVariable;
function deduplicateApiTestExecutionResults(postmanResult) {
    var _a;
    const executionsById = {};
    const orderedExecutionIds = [];
    (_a = postmanResult.run.executions) === null || _a === void 0 ? void 0 : _a.forEach((execution) => {
        const executionId = execution.id;
        if (!executionsById[executionId]) {
            orderedExecutionIds.push(executionId);
        }
        executionsById[executionId] = execution;
    });
    postmanResult.run.executions = orderedExecutionIds.map((executionId) => executionsById[executionId]);
    return postmanResult;
}
exports.deduplicateApiTestExecutionResults = deduplicateApiTestExecutionResults;
function restoreCustomRequestFields(postmanResult, collection) {
    const requestItemsById = collection.item.reduce((collectionSet, itemDefinition) => {
        collectionSet[itemDefinition.id] = itemDefinition;
        return collectionSet;
    }, {});
    postmanResult.run.executions.forEach((execution) => {
        var _a;
        const requestItemDefinition = requestItemsById[execution.id];
        if (((_a = execution.request.body) === null || _a === void 0 ? void 0 : _a.mode) === 'formdata' &&
            (requestItemDefinition === null || requestItemDefinition === void 0 ? void 0 : requestItemDefinition.request)) {
            restoreFormDataFileMetadata(execution.request, requestItemDefinition.request);
        }
    });
    return postmanResult;
}
exports.restoreCustomRequestFields = restoreCustomRequestFields;
function restoreFormDataFileMetadata(resultRequest, collectionRequest) {
    var _a, _b, _c, _d, _e;
    if ((_a = resultRequest.body) === null || _a === void 0 ? void 0 : _a.formdata) {
        const requestFormDataBySrc = (_c = (_b = collectionRequest === null || collectionRequest === void 0 ? void 0 : collectionRequest.body) === null || _b === void 0 ? void 0 : _b.formdata) === null || _c === void 0 ? void 0 : _c.reduce((set, formData) => {
            if (formData.src) {
                set[formData.src] = formData;
            }
            return set;
        }, {});
        if (!Array.isArray((_d = resultRequest.body) === null || _d === void 0 ? void 0 : _d.formdata)) {
            resultRequest.body.formdata = resultRequest.body.formdata
                .all()
                .map((formParam) => formParam);
        }
        for (const resultFormParam of resultRequest.body.formdata) {
            if (resultFormParam.type === 'file' &&
                resultFormParam.src &&
                !resultFormParam.mablFile) {
                resultFormParam.mablFile =
                    (_e = requestFormDataBySrc[resultFormParam.src]) === null || _e === void 0 ? void 0 : _e.mablFile;
            }
        }
    }
}
function findFirstMatchingEvent(eventDefinition, listen) {
    if (!eventDefinition) {
        return { eventIndex: -1 };
    }
    const eventIndex = eventDefinition.findIndex((def) => def.listen === listen);
    let eventValue;
    if (eventIndex !== -1) {
        eventValue = eventDefinition === null || eventDefinition === void 0 ? void 0 : eventDefinition[eventIndex];
    }
    return { eventIndex, eventValue };
}
exports.findFirstMatchingEvent = findFirstMatchingEvent;
function createEmptyRequestEvent() {
    return {
        listen: exports.TEST_LISTEN,
        id: (0, exports.uuid)(),
        script: {
            exec: [],
            raw: '',
            type: 'text/javascript',
        },
        mablAssertions: [
            {
                id: (0, uuid_1.v4)(),
                assertTarget: newman_types_1.AssertionTarget.Status,
                assertType: newman_types_1.AssertionType.Equals,
                value: '200',
            },
        ],
        mablVariables: [],
        mablSnippets: [],
    };
}
exports.createEmptyRequestEvent = createEmptyRequestEvent;
function removeMablGeneratedScriptsFromLines(lines) {
    const mablGeneratedIndex = lines.findIndex((line) => line.includes(exports.MABL_GENERATED_ASSERTION_TOKEN));
    if (mablGeneratedIndex >= 0) {
        return lines.slice(0, mablGeneratedIndex);
    }
    return lines;
}
function removeMablGeneratedScripts(eventDefinition) {
    var _a, _b;
    eventDefinition.script.exec = removeMablGeneratedScriptsFromLines((_b = (_a = eventDefinition.script) === null || _a === void 0 ? void 0 : _a.exec) !== null && _b !== void 0 ? _b : []);
}
exports.removeMablGeneratedScripts = removeMablGeneratedScripts;
function isValidMablVariableAssignment(variable) {
    return !!variable.assertTarget && !!variable.variableName;
}
exports.isValidMablVariableAssignment = isValidMablVariableAssignment;
function filterValidMablVariableAssignments(variables) {
    return variables === null || variables === void 0 ? void 0 : variables.filter(isValidMablVariableAssignment);
}
exports.filterValidMablVariableAssignments = filterValidMablVariableAssignments;
function filterValidMablAssertions(assertions) {
    return assertions === null || assertions === void 0 ? void 0 : assertions.filter(isValidMablAssertion);
}
exports.filterValidMablAssertions = filterValidMablAssertions;
function assertionRequiresValue(assertion) {
    switch (assertion.assertType) {
        case newman_types_1.AssertionType.Present:
        case newman_types_1.AssertionType.NotPresent:
            return false;
        default:
            return true;
    }
}
exports.assertionRequiresValue = assertionRequiresValue;
function normalizeAssertionValue(assertion) {
    switch (assertion.assertType) {
        case 'MatchesRegExp':
            return normalizeRegExpExpectedValue(assertion.value);
        default:
            return normalizeExpectedValue(assertion.value);
    }
}
exports.normalizeAssertionValue = normalizeAssertionValue;
function normalizeExpectedValue(value) {
    if (value === undefined) {
        return;
    }
    value = value.trim();
    if (value.match(/".*"/)) {
        return `pm.variables.replaceIn(${value})`;
    }
    const lower = value.toUpperCase().toLowerCase();
    if (lower === 'true' || lower === 'false' || !Number.isNaN(Number(value))) {
        return JSON.stringify(value);
    }
    return `pm.variables.replaceIn(${JSON.stringify(value)})`;
}
exports.normalizeExpectedValue = normalizeExpectedValue;
function normalizeRegExpExpectedValue(value) {
    if (value === undefined) {
        return;
    }
    value = value.trim();
    if (value.match(stepValidation_1.REGEXP_LITERAL_PATTERN)) {
        return value;
    }
    return `new RegExp(${JSON.stringify(value)})`;
}
exports.normalizeRegExpExpectedValue = normalizeRegExpExpectedValue;
function isValidMablAssertion(assertion) {
    var _a, _b, _c, _d, _e;
    if (!assertion.assertType) {
        return false;
    }
    const assertTarget = assertion.assertTarget;
    const requiresValue = assertionRequiresValue(assertion);
    const expectedValue = normalizeAssertionValue(assertion);
    const hasExpectedValue = !!expectedValue;
    const hasRequiredValue = !requiresValue || hasExpectedValue;
    let valid = false;
    switch (assertTarget) {
        case 'JSONBody':
            const hasBodyPath = ((_c = (_b = (_a = assertion.bodyPath) === null || _a === void 0 ? void 0 : _a.trim()) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 0;
            valid = hasBodyPath && hasRequiredValue;
            break;
        case 'Status':
            valid = hasExpectedValue;
            break;
        case 'Header':
            const hasHeaderName = ((_e = (_d = assertion.headerName) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0;
            valid = hasHeaderName && hasRequiredValue;
            break;
        case 'Size':
            valid =
                isValidSizeAssertionType(assertion.assertType) && hasExpectedValue;
            break;
        case 'TextBody':
            valid = hasExpectedValue;
            break;
    }
    return valid;
}
exports.isValidMablAssertion = isValidMablAssertion;
function isValidSizeAssertionType(assertType) {
    switch (assertType) {
        case newman_types_1.AssertionType.Equals:
        case newman_types_1.AssertionType.NotEquals:
        case newman_types_1.AssertionType.GreaterThan:
        case newman_types_1.AssertionType.GreaterThanOrEqualTo:
        case newman_types_1.AssertionType.LessThan:
        case newman_types_1.AssertionType.LessThanOrEqualTo:
            return true;
    }
    return false;
}
function assertionHasTest(assertion) {
    if (!assertion.assertTarget || !assertion.assertType) {
        return false;
    }
    switch (assertion.assertTarget) {
        case 'Header':
            return !!assertion.headerName;
        case 'JSONBody':
            return !!assertion.bodyPath;
        default:
            return !!assertion.assertType && !!assertion.value;
    }
}
exports.assertionHasTest = assertionHasTest;
function getAssertionTargetArgument(assertion) {
    switch (assertion.assertTarget) {
        case 'JSONBody':
            return assertion.bodyPath;
        case 'Header':
            return assertion.headerName;
        default:
            return;
    }
}
exports.getAssertionTargetArgument = getAssertionTargetArgument;
function humanizeAssertion(assertion) {
    var _a, _b;
    const { assertTarget, assertType, value, description } = assertion;
    if (description && description !== '') {
        return description;
    }
    const humanizedAssertTarget = (_b = (_a = exports.ASSERT_TARGETS.filter((target) => target.value === assertTarget)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.label;
    if (assertionHasTest(assertion)) {
        const assertionTargetArgument = getAssertionTargetArgument(assertion);
        const humanized = `${humanizedAssertTarget}${assertionTargetArgument ? ` ${assertionTargetArgument}` : ''} ${humanizeAssertionType(assertType)}`;
        return assertionRequiresValue(assertion)
            ? `${humanized} ${value}`
            : humanized;
    }
    if (assertType && humanizedAssertTarget) {
        return `${humanizedAssertTarget} ${humanizeAssertionType(assertType)}`;
    }
    return '';
}
exports.humanizeAssertion = humanizeAssertion;
function generateAssertionScript(assertion) {
    if (!assertion.assertType) {
        return;
    }
    const assertTarget = assertion.assertTarget;
    const assertType = assertion.assertType;
    const description = humanizeAssertion(assertion);
    const requiresValue = assertionRequiresValue(assertion);
    const expectedValue = normalizeAssertionValue(assertion);
    const caseSensitive = assertion.caseSensitive !== false;
    switch (assertTarget) {
        case 'JSONBody':
            return generateJsonBodyAssertion(description, assertType, requiresValue, assertion.bodyPath, expectedValue, caseSensitive);
        case 'Status':
            return generateStatusAssertion(description, assertType, expectedValue);
        case 'Header':
            return generateHeaderAssertion(description, assertType, assertion.headerName, expectedValue, caseSensitive);
        case 'Size':
            return generateSizeAssertion(description, assertTarget, assertType, expectedValue);
        case 'TextBody':
            return generateTextBodyAssertion(description, assertType, expectedValue, caseSensitive);
    }
    return;
}
function generateVariableAssignmentScript(variable) {
    if (!variable.variableName) {
        return;
    }
    const assertTarget = variable.assertTarget;
    switch (assertTarget) {
        case 'JSONBody':
            return generateJsonBodyVariableAssignment(variable.variableName, variable.bodyPath);
        case 'Header':
            return generateHeaderVariableAssignment(variable.variableName, variable.headerName);
        default:
            return generateSimpleVariableAssignment(variable.variableName, assertTarget);
    }
}
function generateJsonBodyAssertion(description, assertType, requiresValues, path, expectedValue, caseSensitive) {
    if (!(path === null || path === void 0 ? void 0 : path.trim().length) || (requiresValues && !(expectedValue === null || expectedValue === void 0 ? void 0 : expectedValue.length))) {
        return;
    }
    let propertyAccessor = getJsonBodyProperty(path);
    if (requiresValues) {
        propertyAccessor = valueToUnquotedString(propertyAccessor);
    }
    switch (assertType) {
        case 'Present':
        case 'NotPresent':
        case 'Equals':
        case 'NotEquals':
        case 'Contains':
        case 'DoesNotContain':
        case 'StartsWith':
        case 'EndsWith':
        case 'MatchesRegExp':
            break;
        case 'GreaterThan':
        case 'GreaterThanOrEqualTo':
        case 'LessThan':
        case 'LessThanOrEqualTo':
            propertyAccessor = `parseFloat(${propertyAccessor})`;
            expectedValue = `parseFloat(${expectedValue})`;
            break;
        default:
            throw new Error(`Unexpected header assert type: ${assertType}`);
    }
    return generatePostmanAssertion(description, propertyAccessor, assertType, expectedValue, caseSensitive);
}
function generateJsonBodyVariableAssignment(variableName, path) {
    return generatePostmanVariableAssignment(variableName, getJsonBodyProperty(path));
}
function getJsonBodyProperty(path) {
    const jsonBodyAccessor = 'pm.response.json()';
    return path
        ? `_.get(${jsonBodyAccessor}, pm.variables.replaceIn('${path}'))`
        : jsonBodyAccessor;
}
function generateHeaderVariableAssignment(variableName, headerName) {
    if (!headerName) {
        return;
    }
    return generatePostmanVariableAssignment(variableName, generateGetHeaderValue(headerName));
}
function generateGetHeaderValue(headerName) {
    return `pm.response.headers.get(${JSON.stringify(headerName)})`;
}
function generateStatusAssertion(description, assertType, expectedValue) {
    if (!(expectedValue === null || expectedValue === void 0 ? void 0 : expectedValue.length)) {
        return;
    }
    let expect;
    let target = 'pm.response.code';
    switch (assertType) {
        case 'Equals':
            expect = `pm.response.to.have.status(parseInt(${expectedValue}))`;
            break;
        case 'NotEquals':
            expect = `pm.response.to.not.have.status(parseInt(${expectedValue}))`;
            break;
        case 'Contains':
        case 'DoesNotContain':
        case 'StartsWith':
        case 'EndsWith':
        case 'MatchesRegExp':
            target += '.toString()';
            break;
        case 'GreaterThan':
        case 'GreaterThanOrEqualTo':
        case 'LessThan':
        case 'LessThanOrEqualTo':
            expectedValue = `parseInt(${expectedValue})`;
            break;
        default:
            throw new Error(`Unexpected status assert type: ${assertType}`);
    }
    return generatePostmanTest(description, expect !== null && expect !== void 0 ? expect : generatePostmanExpect(target, assertType, expectedValue));
}
function generateHeaderAssertion(description, assertType, headerName, expectedValue, caseSensitive) {
    if (!headerName) {
        return;
    }
    const normalizedHeaderName = JSON.stringify(headerName);
    let test;
    let target = `pm.response.headers.get(${normalizedHeaderName})`;
    switch (assertType) {
        case 'Present':
            test = `pm.response.to.have.header(${normalizedHeaderName})`;
            break;
        case 'NotPresent':
            test = `pm.response.to.not.have.header(${normalizedHeaderName})`;
            break;
        case 'Equals':
        case 'NotEquals':
        case 'Contains':
        case 'DoesNotContain':
        case 'StartsWith':
        case 'EndsWith':
        case 'MatchesRegExp':
            break;
        case 'GreaterThan':
        case 'GreaterThanOrEqualTo':
        case 'LessThan':
        case 'LessThanOrEqualTo':
            target = `parseFloat(${target})`;
            expectedValue = `parseFloat(${expectedValue})`;
            break;
        default:
            throw new Error(`Unexpected header assert type: ${assertType}`);
    }
    return generatePostmanTest(description, test !== null && test !== void 0 ? test : generatePostmanExpect(target, assertType, expectedValue, caseSensitive));
}
function generateSizeAssertion(description, target, type, expectedValue) {
    if (!(expectedValue === null || expectedValue === void 0 ? void 0 : expectedValue.length)) {
        return;
    }
    if (type !== newman_types_1.AssertionType.MatchesRegExp) {
        expectedValue = `parseInt(${expectedValue})`;
    }
    return generateSimpleAssertion(description, target, type, expectedValue);
}
function generateTextBodyAssertion(description, assertType, expectedValue, caseSensitive) {
    let target = 'pm.response.text()';
    switch (assertType) {
        case 'Present':
        case 'NotPresent':
        case 'Equals':
        case 'NotEquals':
        case 'Contains':
        case 'DoesNotContain':
        case 'StartsWith':
        case 'EndsWith':
        case 'MatchesRegExp':
            break;
        case 'GreaterThan':
        case 'GreaterThanOrEqualTo':
        case 'LessThan':
        case 'LessThanOrEqualTo':
            target = `parseFloat(${target})`;
            expectedValue = `parseFloat(${expectedValue})`;
            break;
        default:
            throw new Error(`Unexpected header assert type: ${assertType}`);
    }
    return generatePostmanAssertion(description, target, assertType, expectedValue, caseSensitive);
}
function generateSimpleAssertion(description, target, type, expectedValue, caseSensitive = true) {
    return generatePostmanTest(description, generatePostmanExpect(getResponseProperty(target), type, expectedValue, caseSensitive));
}
function generateSimpleVariableAssignment(name, target) {
    return generatePostmanVariableAssignment(name, getResponseProperty(target));
}
function getResponseProperty(target) {
    const property = RESPONSE_PROPERTIES[target];
    if (!property) {
        throw new Error(`No response property found for target [${target}]`);
    }
    return `pm.response.${property}`;
}
function generatePostmanAssertion(description, target, assertType, expectedValue, caseSensitive) {
    return generatePostmanTest(description, generatePostmanExpect(target, assertType, expectedValue, caseSensitive));
}
function generatePostmanExpect(target, assertType, expectedValue, caseSensitive = true) {
    if (!caseSensitive && assertionTypeSupportsCaseSensitivity(assertType)) {
        target += '?.toUpperCase().toLowerCase()';
        expectedValue = `${expectedValue !== null && expectedValue !== void 0 ? expectedValue : ''}.toUpperCase().toLowerCase()`;
    }
    return `pm.expect(${target}).to.${EXPECT_FUNCTIONS[assertType].replace(EXPECTED_VALUE_TOKEN, () => expectedValue !== null && expectedValue !== void 0 ? expectedValue : '')}`;
}
function assertionTargetSupportsCaseSensitivity(assertTarget) {
    switch (assertTarget) {
        case 'Header':
        case 'JSONBody':
        case 'TextBody':
            return true;
        default:
            return false;
    }
}
exports.assertionTargetSupportsCaseSensitivity = assertionTargetSupportsCaseSensitivity;
function assertionTypeSupportsCaseSensitivity(assertionType) {
    switch (assertionType) {
        case 'Contains':
        case 'DoesNotContain':
        case 'StartsWith':
        case 'EndsWith':
        case 'Equals':
        case 'NotEquals':
            return true;
        default:
            return false;
    }
}
exports.assertionTypeSupportsCaseSensitivity = assertionTypeSupportsCaseSensitivity;
function generatePostmanTest(description, test) {
    return `pm.test(${JSON.stringify(description)}, function () { ${test}; });`;
}
function generatePostmanVariableAssignment(name, value) {
    return `pm.environment.set(${JSON.stringify(name)}, ${valueToUnquotedString(value)});`;
}
function valueToUnquotedString(value) {
    return `JSON.stringify(${value})?.replace(/^"(.+(?="$))"$/, '$1')`;
}
exports.valueToUnquotedString = valueToUnquotedString;
function getResponseContentType(response) {
    var _a, _b;
    const contentType = (_b = (_a = response === null || response === void 0 ? void 0 : response.header) === null || _a === void 0 ? void 0 : _a.find((header) => header.key.toLowerCase() === 'content-type')) === null || _b === void 0 ? void 0 : _b.value;
    return contentType === null || contentType === void 0 ? void 0 : contentType.toLowerCase();
}
exports.getResponseContentType = getResponseContentType;
function readBody(body, contentType) {
    var _a;
    const bodyLength = (_a = body === null || body === void 0 ? void 0 : body.data) === null || _a === void 0 ? void 0 : _a.length;
    if (!body || !bodyLength) {
        return;
    }
    if (!contentType) {
        return `${bodyLength} bytes of data with unknown type`;
    }
    else if (isJson(contentType)) {
        let bodyAsString = `${bodyLength} bytes of data`;
        try {
            bodyAsString = Buffer.from(body.data).toString();
        }
        catch (e) {
            console.error('Unable to convert body.data to string', e);
            return bodyAsString;
        }
        try {
            return JSON.parse(bodyAsString);
        }
        catch (e) {
            console.error('Unable to parse body into JSON object.', e);
            return bodyAsString;
        }
    }
    else {
        try {
            return Buffer.from(body.data).toString();
        }
        catch (e) {
            console.error('Unable to convert body.data to string', e);
            return `${bodyLength} bytes of data`;
        }
    }
}
exports.readBody = readBody;
function getActualValue(assertion, apiStepExecutionResult, variables) {
    var _a, _b, _c, _d, _e, _f;
    const { assertTarget, bodyPath, headerName } = assertion;
    const contentType = getResponseContentType(apiStepExecutionResult.response);
    switch (assertTarget) {
        case newman_types_1.AssertionTarget.Header:
            return ((_b = (_a = apiStepExecutionResult.response) === null || _a === void 0 ? void 0 : _a.header) !== null && _b !== void 0 ? _b : []).find((header) => caseInsensitiveEquals(header.key, headerName));
        case newman_types_1.AssertionTarget.JSONBody:
            const content = readBody((_c = apiStepExecutionResult.response) === null || _c === void 0 ? void 0 : _c.stream, contentType);
            return bodyPath
                ? lodash_1.default.get(content, replaceVariables(bodyPath, variables))
                : content;
        case newman_types_1.AssertionTarget.Size:
            return (_d = apiStepExecutionResult.response) === null || _d === void 0 ? void 0 : _d.responseSize;
        case newman_types_1.AssertionTarget.Status:
            return (_e = apiStepExecutionResult.response) === null || _e === void 0 ? void 0 : _e.code;
        case newman_types_1.AssertionTarget.TextBody:
            return readBody((_f = apiStepExecutionResult.response) === null || _f === void 0 ? void 0 : _f.stream, contentType);
    }
    return null;
}
exports.getActualValue = getActualValue;
function replaceVariables(value, variables) {
    var _a, _b;
    let toReplace = value;
    let matches;
    while ((matches = toReplace.match(new RegExp('{{@(?<name>[^{}]+)}}')))) {
        const variableName = (_a = matches.groups) === null || _a === void 0 ? void 0 : _a.name;
        const variableValue = (_b = (variableName && variables[variableName])) !== null && _b !== void 0 ? _b : '';
        toReplace = toReplace.replace(new RegExp(`{{@${variableName}}}`, 'g'), variableValue);
    }
    return toReplace;
}
exports.replaceVariables = replaceVariables;
function toPostmanScript(assertion) {
    return [
        generateAssertionScript(assertion),
        generateVariableAssignmentScript(assertion),
    ]
        .filter((script) => script)
        .map((script) => script);
}
exports.toPostmanScript = toPostmanScript;
function createMablGeneratedScripts(event) {
    const mablVariables = convertMablVariableAssignmentsToExecArray(event);
    const mablAssertions = convertMablAssertionsToExecArray(event);
    if (mablVariables.length || mablAssertions.length) {
        return [exports.MABL_GENERATED_COMMENT, ...mablVariables, ...mablAssertions];
    }
    return [];
}
exports.createMablGeneratedScripts = createMablGeneratedScripts;
function convertMablVariableAssignmentsToExecArray(event) {
    var _a, _b;
    return ((_b = (_a = filterValidMablVariableAssignments(event.mablVariables)) === null || _a === void 0 ? void 0 : _a.map((variable) => toPostmanScript(variable)).flat()) !== null && _b !== void 0 ? _b : []);
}
exports.convertMablVariableAssignmentsToExecArray = convertMablVariableAssignmentsToExecArray;
function convertMablAssertionsToExecArray(event) {
    var _a, _b;
    return ((_b = (_a = filterValidMablAssertions(event.mablAssertions)) === null || _a === void 0 ? void 0 : _a.map((assertion) => toPostmanScript(assertion)).flat()) !== null && _b !== void 0 ? _b : []);
}
exports.convertMablAssertionsToExecArray = convertMablAssertionsToExecArray;
exports.PRE_REQUEST_LISTEN = 'prerequest';
function splitLines(value) {
    return value.length ? value.split(/\r?\n/) : [];
}
exports.splitLines = splitLines;
function createEmptyRequestEventArray() {
    return [createEmptyRequestEvent()];
}
exports.createEmptyRequestEventArray = createEmptyRequestEventArray;
const createEmptyRequest = (id = (0, uuid_1.v4)()) => ({
    id,
    name: '',
    request: {
        auth: {
            type: '',
        },
        body: {
            mode: 'none',
            raw: '',
            file: '',
            graphql: '',
            formdata: [],
            urlencoded: [],
        },
        header: [],
        method: 'GET',
        url: '',
    },
    event: createEmptyRequestEventArray(),
});
exports.createEmptyRequest = createEmptyRequest;
function processPostmanItems(items, handleItem, handleFolder) {
    items === null || items === void 0 ? void 0 : items.forEach((item) => {
        if (isItemGroupDefinition(item)) {
            handleFolder === null || handleFolder === void 0 ? void 0 : handleFolder(item);
            processPostmanItems(item.item, handleItem, handleFolder);
        }
        else {
            handleItem === null || handleItem === void 0 ? void 0 : handleItem(item);
        }
    });
}
exports.processPostmanItems = processPostmanItems;
function generateRawScriptField(eventValue) {
    if (eventValue.script) {
        eventValue.script.raw = eventValue.script.exec.join('\n');
    }
}
exports.generateRawScriptField = generateRawScriptField;
function validateCollectionFeaturesForApiTestEditor(collection) {
    let hasFolders = false;
    const handleFolder = (_item) => {
        hasFolders = true;
    };
    processPostmanItems(collection.item, () => { }, handleFolder);
    if (hasFolders) {
        return exports.COLLECTION_WITH_FOLDERS_ERROR;
    }
    return undefined;
}
exports.validateCollectionFeaturesForApiTestEditor = validateCollectionFeaturesForApiTestEditor;
function isFolder(item) {
    return 'item' in item && !!item.item;
}
exports.isFolder = isFolder;
function isItemGroupDefinition(item) {
    return isFolder(item) && !isCollectionDefinition(item);
}
exports.isItemGroupDefinition = isItemGroupDefinition;
function isCollectionDefinition(item) {
    return isFolder(item) && 'info' in item;
}
exports.isCollectionDefinition = isCollectionDefinition;
function isItemDefinition(item) {
    return !isFolder(item);
}
exports.isItemDefinition = isItemDefinition;
function isSupportedAuthType(authDefinition) {
    if (!authDefinition.type) {
        return false;
    }
    return (newman_types_1.MablSupportedPostmanAuthTypes.includes(authDefinition.type) || authDefinition.type === 'noauth');
}
exports.isSupportedAuthType = isSupportedAuthType;
function isJson(contentType) {
    return contentTypeMatches(contentType, (ct) => ct.startsWith('application/json'), (ct) => ct.match(new RegExp(`${MEDIA_TYPE_TOKEN}\/${MEDIA_TYPE_TOKEN}\\+json.*`, 'i')));
}
exports.isJson = isJson;
function isXML(contentType) {
    return contentTypeMatches(contentType, (ct) => ct.startsWith('application/xml'), (ct) => ct.startsWith('text/xml'), (ct) => ct.match(new RegExp(`${MEDIA_TYPE_TOKEN}\/${MEDIA_TYPE_TOKEN}\\+xml.*`, 'i')));
}
exports.isXML = isXML;
function isText(contentType) {
    return contentTypeMatches(contentType, (ct) => ct.startsWith('text/'));
}
exports.isText = isText;
function isBinary(contentType) {
    return contentTypeMatches(contentType, (ct) => ct.startsWith('image/'), (ct) => ct.startsWith('audio/'), (ct) => ct.startsWith('video/'), (ct) => ct.startsWith('application/octet-stream'), (ct) => ct.startsWith('application/zip'), (ct) => ct.startsWith('application/gzip'), (ct) => ct.startsWith('application/x-gzip'), (ct) => ct.startsWith('application/x-tar'), (ct) => ct.startsWith('application/x-rar-compressed'), (ct) => ct.startsWith('application/x-7z-compressed'), (ct) => ct.startsWith('application/x-bzip'), (ct) => ct.startsWith('application/x-rar'));
}
exports.isBinary = isBinary;
function contentTypeMatches(contentType, ...predicates) {
    if (!contentType) {
        return false;
    }
    return predicates.some((predicate) => predicate(contentType));
}
function getFormDataArray(item) {
    var _a, _b, _c;
    if (getRequestMode(item) === 'formdata') {
        const formdata = (_b = (_a = item === null || item === void 0 ? void 0 : item.request) === null || _a === void 0 ? void 0 : _a.body) === null || _b === void 0 ? void 0 : _b.formdata;
        if (Array.isArray(formdata)) {
            return formdata;
        }
        return (_c = formdata === null || formdata === void 0 ? void 0 : formdata.all()) !== null && _c !== void 0 ? _c : [];
    }
    return [];
}
exports.getFormDataArray = getFormDataArray;
function getRequestMode(item) {
    var _a, _b;
    return (_b = (_a = item === null || item === void 0 ? void 0 : item.request) === null || _a === void 0 ? void 0 : _a.body) === null || _b === void 0 ? void 0 : _b.mode;
}
exports.getRequestMode = getRequestMode;
function formatContent(contentContainer) {
    if (contentContainer === null || contentContainer === void 0 ? void 0 : contentContainer.hasOwnProperty('content')) {
        return contentContainer.content;
    }
    return contentContainer;
}
exports.formatContent = formatContent;
function processMablProtocolProfileBehavior(item) {
    var _a, _b;
    const mablProtocolProfileBehavior = (_b = (_a = item.mablTemporaryStorage) === null || _a === void 0 ? void 0 : _a.mablProtocolProfileBehavior) !== null && _b !== void 0 ? _b : [];
    if (mablProtocolProfileBehavior.length === 0) {
        delete item.protocolProfileBehavior;
        return;
    }
    item.protocolProfileBehavior = {};
    mablProtocolProfileBehavior === null || mablProtocolProfileBehavior === void 0 ? void 0 : mablProtocolProfileBehavior.forEach((setting) => {
        if (setting.key && setting.value) {
            let valueToSet;
            try {
                valueToSet = JSON.parse(setting.value);
            }
            catch (error) {
                valueToSet = setting.value;
            }
            item.protocolProfileBehavior[setting.key] = valueToSet;
        }
    });
}
function createOptionalVariable(key, type, value, defaultValue) {
    if (value === undefined && defaultValue === undefined) {
        return;
    }
    let parsedValue = value !== null && value !== void 0 ? value : defaultValue;
    if (type === 'boolean') {
        parsedValue = parsedValue === 'true';
    }
    return { key, type, value: parsedValue };
}
function mablAuthToPostman(mablAuth, undefinedType) {
    let auth;
    if (mablAuth) {
        const { apikey, basic, bearer, oauth1 } = mablAuth;
        const type = mablAuth.type;
        if (type === undefinedType) {
            return;
        }
        else if (type === exports.NO_AUTH) {
            auth = { type };
        }
        else if (type === exports.API_KEY_AUTH) {
            auth = {
                type,
                apikey: [
                    {
                        key: 'key',
                        value: apikey === null || apikey === void 0 ? void 0 : apikey.key,
                        type: 'string',
                    },
                    {
                        key: 'value',
                        value: apikey === null || apikey === void 0 ? void 0 : apikey.value,
                        type: 'string',
                    },
                    {
                        key: 'in',
                        value: apikey === null || apikey === void 0 ? void 0 : apikey.in,
                        type: 'string',
                    },
                ],
            };
        }
        else if (type === exports.BASIC_AUTH) {
            auth = {
                type,
                basic: [
                    {
                        key: 'username',
                        value: basic === null || basic === void 0 ? void 0 : basic.username,
                        type: 'string',
                    },
                    {
                        key: 'password',
                        value: basic === null || basic === void 0 ? void 0 : basic.password,
                        type: 'string',
                    },
                ],
            };
        }
        else if (type === exports.BEARER_TOKEN_AUTH) {
            auth = {
                type,
                bearer: [
                    {
                        key: 'token',
                        value: bearer === null || bearer === void 0 ? void 0 : bearer.token,
                        type: 'string',
                    },
                ],
            };
        }
        else if (type === exports.OAUTH1_AUTH) {
            auth = {
                type,
                oauth1: [
                    createOptionalVariable('addParamsToHeader', 'boolean', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.addParamsToHeader, exports.DEFAULT_ADD_OAUTH1_TO_HEADER_VALUE),
                    createOptionalVariable('addEmptyParamsToSign', 'boolean', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.addEmptyParamsToSign),
                    createOptionalVariable('callback', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.callback),
                    createOptionalVariable('consumerKey', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.consumerKey),
                    createOptionalVariable('consumerSecret', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.consumerSecret),
                    createOptionalVariable('includeBodyHash', 'boolean', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.includeBodyHash),
                    createOptionalVariable('nonce', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.nonce),
                    createOptionalVariable('realm', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.realm),
                    createOptionalVariable('signatureMethod', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.signatureMethod, exports.HMAC_SHA1_SIGNATURE),
                    createOptionalVariable('timestamp', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.timestamp),
                    createOptionalVariable('token', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.token),
                    createOptionalVariable('tokenSecret', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.tokenSecret),
                    createOptionalVariable('verifier', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.verifier),
                    createOptionalVariable('version', 'string', oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.version, exports.DEFAULT_OAUTH1_VERSION),
                ].filter((variable) => variable),
            };
        }
    }
    return auth;
}
exports.mablAuthToPostman = mablAuthToPostman;
function processItemAuth(item) {
    var _a, _b;
    const itemAuth = mablAuthToPostman((_a = item.mablTemporaryStorage) === null || _a === void 0 ? void 0 : _a.mablAuth, exports.INHERIT_AUTH_FROM_PARENT_VALUE);
    if (itemAuth) {
        item.request.auth = itemAuth;
    }
    else if ((_b = item.request) === null || _b === void 0 ? void 0 : _b.auth) {
        item.request.auth = {};
    }
}
exports.processItemAuth = processItemAuth;
function removeInvalidHeaders(item) {
    var _a;
    if ((_a = item.request) === null || _a === void 0 ? void 0 : _a.header) {
        item.request.header = item.request.header.filter((header) => { var _a, _b; return (_b = (_a = header.key) === null || _a === void 0 ? void 0 : _a.trim()) === null || _b === void 0 ? void 0 : _b.length; });
    }
}
exports.removeInvalidHeaders = removeInvalidHeaders;
function replaceRawScriptWithExecArray(eventsContainer, processingForRepair) {
    var _a;
    (_a = eventsContainer.event) === null || _a === void 0 ? void 0 : _a.forEach((event) => {
        var _a;
        if (event.script) {
            if (!processingForRepair) {
                event.script.exec = splitLines((_a = event.script.raw) !== null && _a !== void 0 ? _a : '');
            }
            else if (event.script.raw && event.script.raw.length > 0) {
                event.script.exec = splitLines(event.script.raw);
            }
            delete event.script.raw;
        }
    });
}
exports.replaceRawScriptWithExecArray = replaceRawScriptWithExecArray;
function processPostmanItem(item) {
    if (!item.id) {
        item.id = (0, uuid_1.v4)();
    }
    processMablProtocolProfileBehavior(item);
    processItemAuth(item);
    removeInvalidHeaders(item);
}
exports.processPostmanItem = processPostmanItem;
function insertMablScriptsIntoCollection(itemGroup, getSnippet) {
    var _a, _b;
    (_a = itemGroup.event) === null || _a === void 0 ? void 0 : _a.forEach((event) => insertMablScriptsIntoEvent(event, getSnippet));
    (_b = itemGroup.item) === null || _b === void 0 ? void 0 : _b.forEach((item) => insertMablScriptsIntoCollection(item, getSnippet));
}
exports.insertMablScriptsIntoCollection = insertMablScriptsIntoCollection;
function insertMablScriptsIntoEvent(event, getSnippet) {
    var _a;
    removeMablGeneratedScripts(event);
    const mablScripts = createPostmanScript(convertMablSnippetsToExecArray(event, getSnippet), createMablGeneratedScripts(event));
    if (!((_a = event.mablSnippets) === null || _a === void 0 ? void 0 : _a.length)) {
        mablScripts.exec = [...event.script.exec, ...mablScripts.exec];
    }
    event.script = mablScripts;
    delete event.mablAssertions;
    delete event.mablSnippets;
    delete event.mablVariables;
}
function createPostmanScript(...scripts) {
    return {
        id: (0, exports.uuid)(),
        exec: scripts.flatMap((lines) => lines),
        type: 'text/javascript',
    };
}
exports.createPostmanScript = createPostmanScript;
function convertMablSnippetsToExecArray(event, getSnippetFromInvariantId) {
    if (!event.mablSnippets) {
        return [];
    }
    const snippetBodies = event.mablSnippets.map((apiTestSnippet) => {
        const snippet = apiTestSnippet.reusable
            ? getSnippetFromInvariantId(apiTestSnippet.invariantId)
            : apiTestSnippet;
        if (!(snippet === null || snippet === void 0 ? void 0 : snippet.body)) {
            if (apiTestSnippet.reusable) {
                throw new Error(`Unable to find reusable snippet with invariant ID ${apiTestSnippet.invariantId}`);
            }
            return '';
        }
        const body = (0, encodingUtil_1.b64DecodeUnicodeNodeOrBrowser)(snippet.body);
        return [
            createCommentForApiTestSnippet(snippet, 'start'),
            body,
            createCommentForApiTestSnippet(snippet, 'end'),
            '',
        ].join('\n');
    });
    return snippetBodies.flatMap((body) => body.split('\n'));
}
exports.convertMablSnippetsToExecArray = convertMablSnippetsToExecArray;
function createCommentForApiTestSnippet(snippet, position) {
    var _a, _b;
    if (snippet.reusable) {
        return `// ${position} of reusable snippet "${(_a = snippet.name) !== null && _a !== void 0 ? _a : snippet.id}"`;
    }
    return `// ${position} of one-time snippet "${(_b = snippet.name) !== null && _b !== void 0 ? _b : snippet.id}"`;
}
exports.createCommentForApiTestSnippet = createCommentForApiTestSnippet;
function insertTestConfigurationIntoFlow(test, flow) {
    var _a;
    const collection = flow.api_steps;
    const testConfiguration = test.api_configuration;
    if (!testConfiguration) {
        return;
    }
    const { authentication, pre_request_snippets: preRequestSnippets, post_request_snippets: postRequestSnippets, } = testConfiguration;
    if (!authentication &&
        !(preRequestSnippets === null || preRequestSnippets === void 0 ? void 0 : preRequestSnippets.length) &&
        !(postRequestSnippets === null || postRequestSnippets === void 0 ? void 0 : postRequestSnippets.length)) {
        return;
    }
    const folder = {
        name: (_a = flow.id) !== null && _a !== void 0 ? _a : 'Flow',
        item: collection.item,
    };
    folder.auth = collection.auth;
    folder.event = collection.event;
    delete collection.auth;
    delete collection.event;
    collection.item = [folder];
    if (authentication) {
        collection.auth = apiTestAuthToPostmanAuth(authentication);
    }
    const event = [];
    if (preRequestSnippets === null || preRequestSnippets === void 0 ? void 0 : preRequestSnippets.length) {
        event.push(executableSnippetsToPostmanEvent(preRequestSnippets, 'prerequest'));
    }
    if (postRequestSnippets === null || postRequestSnippets === void 0 ? void 0 : postRequestSnippets.length) {
        event.push(executableSnippetsToPostmanEvent(postRequestSnippets, 'test'));
    }
    if (event.length) {
        collection.event = event;
    }
}
exports.insertTestConfigurationIntoFlow = insertTestConfigurationIntoFlow;
function apiTestAuthToPostmanAuth(apiTestAuth) {
    const postmanAuth = {
        type: `${apiTestAuth.type}`,
    };
    switch (apiTestAuth.type) {
        case 'apikey':
            postmanAuth.apikey = apiKeyAuthenticationToPostman(apiTestAuth.api_key);
            break;
        case 'basic':
            postmanAuth.basic = basicAuthenticationToPostman(apiTestAuth.basic);
            break;
        case 'bearer':
            postmanAuth.bearer = bearerAuthenticationToPostman(apiTestAuth.bearer);
            break;
        case 'oauth1':
            postmanAuth.oauth1 = oauth1AuthenticationToPostman(apiTestAuth.oauth1);
            break;
    }
    return postmanAuth;
}
exports.apiTestAuthToPostmanAuth = apiTestAuthToPostmanAuth;
function apiKeyAuthenticationToPostman(auth) {
    return removeUndefinedValues([
        toPostmanConfigurationValue('key', auth === null || auth === void 0 ? void 0 : auth.key),
        toPostmanConfigurationValue('value', auth === null || auth === void 0 ? void 0 : auth.value),
        toPostmanConfigurationValue('in', auth === null || auth === void 0 ? void 0 : auth.location),
    ]);
}
function basicAuthenticationToPostman(auth) {
    return removeUndefinedValues([
        toPostmanConfigurationValue('username', auth === null || auth === void 0 ? void 0 : auth.username),
        toPostmanConfigurationValue('password', auth === null || auth === void 0 ? void 0 : auth.password),
    ]);
}
function bearerAuthenticationToPostman(auth) {
    return removeUndefinedValues([
        toPostmanConfigurationValue('token', auth === null || auth === void 0 ? void 0 : auth.token),
    ]);
}
function oauth1AuthenticationToPostman(auth) {
    return removeUndefinedValues([
        toPostmanConfigurationValue('addParamsToHeader', auth === null || auth === void 0 ? void 0 : auth.add_parameters_to_header, 'boolean'),
        toPostmanConfigurationValue('addEmptyParamsToSign', auth === null || auth === void 0 ? void 0 : auth.add_empty_parameters_to_signature, 'boolean'),
        toPostmanConfigurationValue('callback', auth === null || auth === void 0 ? void 0 : auth.callback_url),
        toPostmanConfigurationValue('consumerKey', auth === null || auth === void 0 ? void 0 : auth.consumer_key),
        toPostmanConfigurationValue('consumerSecret', auth === null || auth === void 0 ? void 0 : auth.consumer_secret),
        toPostmanConfigurationValue('includeBodyHash', auth === null || auth === void 0 ? void 0 : auth.include_body_hash, 'boolean'),
        toPostmanConfigurationValue('nonce', auth === null || auth === void 0 ? void 0 : auth.nonce),
        toPostmanConfigurationValue('realm', auth === null || auth === void 0 ? void 0 : auth.realm),
        toPostmanConfigurationValue('signatureMethod', auth === null || auth === void 0 ? void 0 : auth.signature_method),
        toPostmanConfigurationValue('timestamp', auth === null || auth === void 0 ? void 0 : auth.timestamp),
        toPostmanConfigurationValue('token', auth === null || auth === void 0 ? void 0 : auth.token),
        toPostmanConfigurationValue('tokenSecret', auth === null || auth === void 0 ? void 0 : auth.token_secret),
        toPostmanConfigurationValue('verifier', auth === null || auth === void 0 ? void 0 : auth.verifier),
        toPostmanConfigurationValue('version', auth === null || auth === void 0 ? void 0 : auth.version),
    ]);
}
const removeUndefinedValues = (values) => values.filter((value) => value !== undefined);
function toPostmanConfigurationValue(key, value, type = 'string') {
    if (!value) {
        return;
    }
    if (type === 'string') {
        value = `${value}`;
    }
    if (type === 'boolean') {
        value = `${value}`.toLowerCase() === 'true';
    }
    return {
        key,
        value,
        type,
    };
}
function executableSnippetsToPostmanEvent(snippets, type) {
    return {
        id: (0, exports.uuid)(),
        listen: type,
        mablSnippets: snippets.map((snippet) => executableSnippetToApiTestSnippet(snippet)),
        script: {
            exec: [],
            id: (0, exports.uuid)(),
            type: 'text/javascript',
        },
    };
}
exports.executableSnippetsToPostmanEvent = executableSnippetsToPostmanEvent;
function executableSnippetToApiTestSnippet(executableSnippet) {
    const { invariant_id: invariantId, ...snippet } = { ...executableSnippet };
    if (executableSnippet.reusable) {
        return {
            invariantId: invariantId,
            reusable: true,
        };
    }
    return {
        ...snippet,
        reusable: false,
    };
}
exports.executableSnippetToApiTestSnippet = executableSnippetToApiTestSnippet;
function getValueFromAuthVariables(authVariables, variableName) {
    var _a;
    return (_a = authVariables === null || authVariables === void 0 ? void 0 : authVariables.find((variable) => variable.key === variableName)) === null || _a === void 0 ? void 0 : _a.value;
}
exports.getValueFromAuthVariables = getValueFromAuthVariables;
function postmanAuthToApiTestAuth(auth) {
    const { type: authType } = auth || {};
    if (!authType || authType === 'noauth') {
        return undefined;
    }
    const apiTestAuth = {
        type: authType,
    };
    const getValueFromVariablesForAuthType = (variableName) => getValueFromAuthVariables(auth[authType], variableName);
    switch (authType) {
        case 'apikey':
            apiTestAuth.api_key = {
                location: getValueFromVariablesForAuthType('in'),
                key: getValueFromVariablesForAuthType('key'),
                value: getValueFromVariablesForAuthType('value'),
            };
            break;
        case 'basic':
            apiTestAuth.basic = {
                username: getValueFromVariablesForAuthType('username'),
                password: getValueFromVariablesForAuthType('password'),
            };
            break;
        case 'bearer':
            apiTestAuth.bearer = {
                token: getValueFromVariablesForAuthType('token'),
            };
            break;
        case 'oauth1':
            apiTestAuth.oauth1 = {
                consumer_key: getValueFromVariablesForAuthType('consumerKey'),
                consumer_secret: getValueFromVariablesForAuthType('consumerSecret'),
                token: getValueFromVariablesForAuthType('token'),
                token_secret: getValueFromVariablesForAuthType('tokenSecret'),
                signature_method: getValueFromVariablesForAuthType('signatureMethod'),
                nonce: getValueFromVariablesForAuthType('nonce'),
                timestamp: getValueFromVariablesForAuthType('timestamp'),
                version: getValueFromVariablesForAuthType('version'),
                realm: getValueFromVariablesForAuthType('realm'),
                add_parameters_to_header: getValueFromVariablesForAuthType('addParamsToHeader'),
                add_empty_parameters_to_signature: getValueFromVariablesForAuthType('addEmptyParamsToSignature'),
                callback_url: getValueFromVariablesForAuthType('callbackUrl'),
                include_body_hash: getValueFromVariablesForAuthType('includeBodyHash'),
                verifier: getValueFromVariablesForAuthType('verifier'),
            };
            break;
    }
    return apiTestAuth;
}
exports.postmanAuthToApiTestAuth = postmanAuthToApiTestAuth;
function postmanEventToExecutableSnippets(event) {
    var _a, _b;
    if (!event) {
        return [];
    }
    return ((_b = (_a = event.mablSnippets) === null || _a === void 0 ? void 0 : _a.map((snippet) => {
        if (snippet.reusable) {
            const executableSnippet = {
                invariant_id: snippet.invariantId,
                reusable: true,
            };
            return executableSnippet;
        }
        const executableSnippet = {
            reusable: false,
            body: snippet.body,
            description: snippet.description,
            name: snippet.name,
            snippet_type: snippet.snippet_type,
            workspace_id: snippet.workspace_id,
        };
        return executableSnippet;
    })) !== null && _b !== void 0 ? _b : []);
}
exports.postmanEventToExecutableSnippets = postmanEventToExecutableSnippets;
const uuid = () => (0, uuid_1.v4)();
exports.uuid = uuid;
function getSnippetReferencesInCollection(collection) {
    var _a, _b;
    return (((_a = collection.item) !== null && _a !== void 0 ? _a : [])
        .flatMap((item) => { var _a; return (_a = item.event) !== null && _a !== void 0 ? _a : []; })
        .concat((_b = collection.event) !== null && _b !== void 0 ? _b : [])
        .flatMap((event) => { var _a; return (_a = event.mablSnippets) !== null && _a !== void 0 ? _a : []; })
        .filter((snippet) => snippet.reusable)
        .map((snippet) => snippet.invariantId)
        .map((invariantId) => ({
        id: invariantId,
        snippetType: mablApi_1.SnippetTypeEnum.Postman,
    })));
}
exports.getSnippetReferencesInCollection = getSnippetReferencesInCollection;
function getSnippetReferencesInTest(test) {
    var _a, _b, _c, _d;
    return ((_b = (_a = test.api_configuration) === null || _a === void 0 ? void 0 : _a.pre_request_snippets) !== null && _b !== void 0 ? _b : [])
        .concat((_d = (_c = test.api_configuration) === null || _c === void 0 ? void 0 : _c.post_request_snippets) !== null && _d !== void 0 ? _d : [])
        .filter((snippet) => snippet.reusable)
        .map(({ invariant_id: invariantId }) => ({
        id: invariantId,
        snippetType: mablApi_1.SnippetTypeEnum.Postman,
    }));
}
exports.getSnippetReferencesInTest = getSnippetReferencesInTest;
