"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestInterceptor = exports.headerStringToProtocol = exports.headerStringToHeaders = exports.MAX_SERIALIZED_BODY_SIZE_BYTES = void 0;
const axios_1 = __importDefault(require("axios"));
const loggingProvider_1 = require("../providers/logging/loggingProvider");
const uuid_1 = require("uuid");
const httpUtil_1 = require("./httpUtil");
const pureUtil_1 = require("../util/pureUtil");
exports.MAX_SERIALIZED_BODY_SIZE_BYTES = 1024 * 1024;
const HEADER_EXTRACT_REGEXP = /^(?<rawKey>[^:]+)(:)(?<value>.*)$/;
function headerStringToHeaders(rawHeader) {
    const headers = {};
    if (!rawHeader) {
        return headers;
    }
    rawHeader
        .split(/\r?\n/)
        .filter((value) => value !== '')
        .filter((value) => HEADER_EXTRACT_REGEXP.test(value))
        .map((value) => value.match(HEADER_EXTRACT_REGEXP).groups)
        .forEach(({ rawKey, value }) => {
        var _a;
        const normalizedHeader = rawKey.toLowerCase().trim();
        const values = (_a = headers[normalizedHeader]) !== null && _a !== void 0 ? _a : [];
        if (value === null || value === void 0 ? void 0 : value.trim()) {
            values.push(value.trim());
        }
        headers[normalizedHeader] = values;
    });
    return headers;
}
exports.headerStringToHeaders = headerStringToHeaders;
function headerStringToProtocol(rawHeader) {
    var _a, _b, _c;
    if (!rawHeader) {
        return;
    }
    const firstRowTrimmed = (_b = (_a = rawHeader.split(/\r?\n/, 2)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.trim();
    return (_c = firstRowTrimmed === null || firstRowTrimmed === void 0 ? void 0 : firstRowTrimmed.match(/\s(\S+)$/)) === null || _c === void 0 ? void 0 : _c[1];
}
exports.headerStringToProtocol = headerStringToProtocol;
function headerRecordToHeaderMultiMap(input) {
    const result = {};
    Object.entries(input).forEach(([key, value]) => {
        result[key] = [value];
    });
    return result;
}
function handleRawResponseBody(body) {
    body = body !== null && body !== void 0 ? body : '';
    switch (typeof body) {
        case 'number':
            return { body: body.toString(), responseSize: 8 };
        case 'boolean':
            return { body: body.toString(), responseSize: 4 };
        case 'string':
            return {
                body: body.substring(0, exports.MAX_SERIALIZED_BODY_SIZE_BYTES),
                responseSize: body.length,
            };
        case 'object':
            const serializedBody = JSON.stringify(body);
            if (serializedBody.length <= exports.MAX_SERIALIZED_BODY_SIZE_BYTES) {
                return { body, responseSize: serializedBody.length };
            }
            return {
                body: serializedBody.substring(0, exports.MAX_SERIALIZED_BODY_SIZE_BYTES),
                responseSize: serializedBody.length,
            };
        default:
            throw new Error(`Unhandled request intercept body type: [${typeof body}]`);
    }
}
function getContentLength(headers) {
    const contentLengthAsString = (0, pureUtil_1.getCaseInsensitiveProperty)(headers, 'content-length');
    return contentLengthAsString ? Number(contentLengthAsString) : undefined;
}
class RequestInterceptor {
    constructor() {
        this.interceptedRequests = [];
        this.handleRequest = this.handleRequest.bind(this);
        this.handleResponse = this.handleResponse.bind(this);
        this.handleError = this.handleError.bind(this);
    }
    get interceptedRequestBuffer() {
        return [...this.interceptedRequests];
    }
    clearInterceptBuffer() {
        this.interceptedRequests = [];
    }
    registerInterceptors(axiosInstance) {
        this.requestInterceptorId = axiosInstance.interceptors.request.use(this.handleRequest, this.handleError);
        this.responseInterceptorId = axios_1.default.interceptors.response.use(this.handleResponse, this.handleError);
    }
    ejectInterceptors(axiosInstance) {
        try {
            if (this.requestInterceptorId !== undefined) {
                axiosInstance.interceptors.request.eject(this.requestInterceptorId);
            }
        }
        catch (e) {
            loggingProvider_1.logger.warn(`Unable to eject request interceptor ${this.requestInterceptorId}`);
        }
        try {
            if (this.responseInterceptorId !== undefined) {
                axiosInstance.interceptors.response.eject(this.responseInterceptorId);
            }
        }
        catch (e) {
            loggingProvider_1.logger.warn(`Unable to eject request interceptor ${this.responseInterceptorId}`);
        }
    }
    handleRequest(config) {
        var _a, _b, _c;
        try {
            const requestId = (0, uuid_1.v4)();
            config.mablRequestId = requestId;
            const requestResponseChain = {
                requestId,
                request: {
                    headers: (_a = config.headers) !== null && _a !== void 0 ? _a : {},
                    url: (_b = config === null || config === void 0 ? void 0 : config.url) !== null && _b !== void 0 ? _b : '<Unknown URL>',
                    method: (_c = config.method) === null || _c === void 0 ? void 0 : _c.toUpperCase(),
                    request_sent_time: Date.now(),
                },
            };
            if (typeof config.data === 'string') {
                requestResponseChain.request.body = config.data.substring(0, exports.MAX_SERIALIZED_BODY_SIZE_BYTES);
            }
            this.interceptedRequests.push(requestResponseChain);
        }
        catch (e) {
            loggingProvider_1.logger.warn('Error in the response interceptor', e);
        }
        return config;
    }
    handleResponse(response) {
        try {
            const responseReceivedTime = Date.now();
            const chainEntry = this.getOrCreateEntry(response.config);
            const request = response.request;
            if (request) {
                chainEntry.request.headers = headerStringToHeaders(request._header);
                chainEntry.request.protocol = (request === null || request === void 0 ? void 0 : request._header)
                    ? headerStringToProtocol(request._header)
                    : '<Unknown protocol>';
            }
            const { body, responseSize } = handleRawResponseBody(response.data);
            const contentLength = getContentLength(response.headers);
            chainEntry.response = {
                headers: headerRecordToHeaderMultiMap(response.headers),
                status: response.status,
                response_received_time: responseReceivedTime,
                response_size: contentLength !== null && contentLength !== void 0 ? contentLength : responseSize,
                body,
            };
        }
        catch (e) {
            loggingProvider_1.logger.warn('Error in the response interceptor', e);
        }
        return response;
    }
    handleError(error) {
        var _a;
        try {
            const config = error.config;
            let chainEntry;
            if (config) {
                chainEntry = this.getOrCreateEntry(config);
            }
            else if (this.interceptedRequests.length) {
                chainEntry =
                    this.interceptedRequests[this.interceptedRequests.length - 1];
            }
            if (chainEntry) {
                chainEntry.error = {
                    code: (_a = error.code) !== null && _a !== void 0 ? _a : httpUtil_1.GENERAL_API_STEP_EXECUTION_ERROR_CODE,
                    message: error.message,
                    error_received_time: Date.now(),
                };
            }
            if (error.response) {
                this.handleResponse(error.response);
            }
        }
        catch (e) {
            loggingProvider_1.logger.warn('Error in the error interceptor', e);
        }
        return Promise.reject(error);
    }
    getOrCreateEntry(config) {
        const existingEntry = this.findEntry(config);
        if (existingEntry) {
            return existingEntry;
        }
        this.handleRequest(config);
        return this.findEntry(config);
    }
    findEntry(config) {
        return this.interceptedRequests.find((chain) => chain.requestId === config.mablRequestId);
    }
}
exports.RequestInterceptor = RequestInterceptor;
