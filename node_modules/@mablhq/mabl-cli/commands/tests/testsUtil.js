"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseBrowserType = exports.toBasicHttpAuthenticationCredentials = exports.logTestInfoIfPresent = exports.milliSecondsToSeconds = exports.calculateTotalTimeSeconds = exports.headerArrayToRecord = exports.getLinkCrawlerUrlOverride = exports.extractTestRunConfig = exports.pullDownTestRunConfig = exports.validateRunCommandWithLabels = exports.validateRunEditCommand = exports.cleanupTestResources = exports.sleep = exports.editTheTest = exports.runTheTest = exports.prepareTrainerForSplitPlayback = exports.cleanUpInitialPages = exports.getExtensionBackgroundPageWithCliTool = exports.createBrowserForExecutionEngine = exports.createBrowser = exports.getFinalUrl = void 0;
const cli_table3_1 = __importDefault(require("cli-table3"));
const fs = __importStar(require("fs"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const browserLauncher_1 = require("../../browserLauncher");
const trainingSessionActions_1 = require("../../core/messaging/actions/trainingSessionActions");
const logLineMessaging_1 = require("../../core/messaging/logLineMessaging");
const messaging_1 = require("../../core/messaging/messaging");
const mablApi_1 = require("../../mablApi");
const cliConfigProvider_1 = require("../../providers/cliConfigProvider");
const loggingProvider_1 = require("../../providers/logging/loggingProvider");
const fileUploadUtil_1 = require("../../util/fileUploadUtil");
const logUtils_1 = require("../../util/logUtils");
const browserTypes_1 = require("../browserTypes");
const constants_1 = require("../constants");
const utils_1 = require("../datatables/utils");
const trainerUtil_1 = require("./tests_cmds/trainerUtil");
const chalk = require('chalk');
const linkCrawlerStartUrlParam = 'mabl.link_crawler.starting_url';
let RUNNING_TEST = false;
function getFinalUrl(test, parsedUrl) {
    const finalUrl = parsedUrl || test.url;
    if (!finalUrl && test.test_type !== mablApi_1.TestTypeEnum.Performance) {
        throw new Error('No default URL found on test, please specify a URL using the -u or --url flag');
    }
    return finalUrl;
}
exports.getFinalUrl = getFinalUrl;
async function launchBrowserInstance(options) {
    var _a;
    const optionsProxy = await maybeGetProxyOptions(options);
    if (optionsProxy) {
        options = {
            ...options,
            proxy: optionsProxy,
        };
    }
    let browser;
    try {
        browser = await maybeLaunchBrowser(options);
    }
    catch (error) {
        if (error.message.includes('Running as root without --no-sandbox is not supported')) {
            (_a = options.commandLineArgs) === null || _a === void 0 ? void 0 : _a.push('--no-sandbox');
            messaging_1.mablEventEmitter.log('Unable to initialize browser with standard settings, attempting to run with --no-sandbox setting', Date.now(), logLineMessaging_1.LogLineColor.yellow);
            return maybeLaunchBrowser(options).catch((error) => {
                messaging_1.mablEventEmitter.log('Browser launch failed', Date.now(), logLineMessaging_1.LogLineColor.red);
                messaging_1.mablEventEmitter.log(error.message);
            });
        }
        messaging_1.mablEventEmitter.log('Browser launch failed', Date.now(), logLineMessaging_1.LogLineColor.red);
        messaging_1.mablEventEmitter.log(error.message);
    }
    return browser;
}
async function maybeGetProxyOptions(options) {
    const proxyServer = (await cliConfigProvider_1.CliConfigProvider.getCliConfig()).http.test
        .proxyHost;
    let optionsProxy;
    if (options === null || options === void 0 ? void 0 : options.proxy) {
        optionsProxy = {
            server: options.proxy.server,
            username: options.proxy.username,
            password: options.proxy.password,
        };
    }
    else if (proxyServer) {
        optionsProxy = {
            server: proxyServer.href,
            username: proxyServer.username,
            password: proxyServer.password,
        };
    }
    return optionsProxy;
}
function maybeLaunchBrowser(options) {
    return browserLauncher_1.BrowserLauncherFactory.createRunner(options === null || options === void 0 ? void 0 : options.runnerType, options === null || options === void 0 ? void 0 : options.loggerFunc).launch(options);
}
async function createBrowser(engine, options) {
    const userDataDir = await engine.prepareBrowserPreferencesDirectory(options.windowPlacement);
    const browserEngineLaunchOptions = engine.getBrowserLaunchOptions(options);
    const maybeBrowser = await launchBrowserInstance({
        ...options,
        ...browserEngineLaunchOptions,
        downloadPath: createDownloadDirectory(),
        userDataDir,
    });
    if (!maybeBrowser) {
        throw new Error('Unable to start browser session');
    }
    maybeBrowser.on(browserLauncher_1.BrowserEvent.Disconnected, () => maybeBrowser.removeBrowserPreferencesDirectory());
    return maybeBrowser;
}
exports.createBrowser = createBrowser;
async function createBrowserForExecutionEngine(engine, proxyInfo, options) {
    const userDataDir = await engine.prepareBrowserPreferencesDirectory(undefined, proxyInfo);
    const launchOptions = engine.getExecutionEngineBrowserLaunchOptions(options, proxyInfo);
    const proxy = engine.getProxySpec(proxyInfo);
    const maybeBrowser = await maybeLaunchBrowser({
        ...options,
        ...launchOptions,
        proxy,
        downloadPath: createDownloadDirectory(),
        userDataDir,
    });
    if (!maybeBrowser) {
        throw new Error('Unable to start browser session');
    }
    (0, logUtils_1.logCliOutput)(loggingProvider_1.LogLevel.Info, `Setting apiProxy server [${proxyInfo.httpProxy}]`);
    maybeBrowser.setApiProxy(proxyInfo.httpProxy);
    return maybeBrowser;
}
exports.createBrowserForExecutionEngine = createBrowserForExecutionEngine;
async function getExtensionBackgroundPageWithCliTool(browser) {
    const backgroundPage = await browser.getExtensionBackgroundPage((0, trainerUtil_1.getTrainerId)());
    if (backgroundPage) {
        await checkForMablCliTool(backgroundPage);
        await exposeMessagingFunctionToTrainer(backgroundPage, browser);
        return backgroundPage;
    }
    throw new Error('mabl test creation failure, unable to locate the mabl extension. Please try again');
}
exports.getExtensionBackgroundPageWithCliTool = getExtensionBackgroundPageWithCliTool;
async function checkForMablCliTool(backgroundPage) {
    let isReady = false;
    while (!isReady) {
        isReady = (await backgroundPage.evaluate(`!!window.mablCli`));
        if (!isReady) {
            await sleep(1000);
        }
    }
    return isReady;
}
async function cleanUpInitialPages(browser) {
    const currentPages = await browser.pages();
    const pagePromises = currentPages.map(async (page) => {
        const url = page.url();
        if (url === 'about:blank') {
            const pageCount = await browser.pages();
            if (pageCount.length > 1) {
                await page.close();
            }
        }
    });
    await Promise.all(pagePromises);
}
exports.cleanUpInitialPages = cleanUpInitialPages;
async function exposeMessagingFunctionToTrainer(backgroundPage, browser) {
    await backgroundPage
        .exposeFunction('postMessageToCli', (message) => handleExtensionMessage(message, browser))
        .catch((error) => messaging_1.mablEventEmitter.log('Error on the handle' + error));
}
function createRunLocalTestObject(test, flows, branchName, url, credentialsId, environment) {
    return {
        test,
        flows,
        branchName,
        url,
        credentialsId,
        environment,
    };
}
async function prepareTrainerForSplitPlayback(backgroundPage, test, flows, branchName, url, credentialsId) {
    const existingTestPayload = JSON.stringify(createRunLocalTestObject(test, flows, branchName, url, credentialsId));
    const script = `window.mablCli.remoteTest(${existingTestPayload});`;
    try {
        await backgroundPage.evaluate(script);
    }
    catch (error) {
        messaging_1.mablEventEmitter.log(chalk.red('Issue preparing the trainer for split playback'));
    }
}
exports.prepareTrainerForSplitPlayback = prepareTrainerForSplitPlayback;
async function runTheTest(trainingBrowser, backgroundPage, test, flows, branchName, url, credentialsId, environment) {
    const runLocalTest = createRunLocalTestObject(test, flows, branchName, url, credentialsId, environment);
    const script = `window.mablCli.runTest(${JSON.stringify(runLocalTest)});`;
    try {
        await backgroundPage.evaluate(script);
        RUNNING_TEST = true;
        while (RUNNING_TEST) {
            await sleep(1000);
            await cleanUpInitialPages(trainingBrowser);
        }
    }
    catch (error) {
        messaging_1.mablEventEmitter.log(chalk.red(error));
    }
}
exports.runTheTest = runTheTest;
async function editTheTest(backgroundPage, test, flows, branchName, url, credentialsId, environment) {
    const editLocalTest = {
        test,
        flows,
        branchName,
        url,
        credentialsId,
        environment,
    };
    const script = `window.mablCli.editTest(${JSON.stringify(editLocalTest)});`;
    try {
        await backgroundPage.evaluate(script);
    }
    catch (error) {
        messaging_1.mablEventEmitter.log(chalk.red(error));
    }
}
exports.editTheTest = editTheTest;
async function shutItDown(trainingBrowser) {
    await trainingBrowser.close().catch(() => 'Shutdown was a little bumpy');
}
function sleep(milliseconds) {
    return new Promise((resolve) => setTimeout(resolve, milliseconds));
}
exports.sleep = sleep;
const TRAINER_SHUTDOWN = 'TRAINER_SHUTDOWN';
const TRAINED_TEST_INFO = 'TRAINED_TEST_INFO';
const LOG_LINE_OUTPUT = 'LOG_LINE_OUTPUT';
const TRAINED_TEST_SAVED = 'TRAINED_TEST_SAVED';
function handleExtensionMessage(message, trainingBrowser) {
    switch (message.action) {
        case TRAINER_SHUTDOWN:
            const shutdownMessage = message;
            if (shutdownMessage.shutdown) {
                trainingSessionActions_1.TrainingEventEmitter.sessionClosed();
                setTimeout(shutItDown, 1000, trainingBrowser);
            }
            RUNNING_TEST = false;
            break;
        case TRAINED_TEST_SAVED:
            const trainedTestSavedMessage = message;
            if (!trainedTestSavedMessage.test.id ||
                !trainedTestSavedMessage.test.invariant_id) {
                break;
            }
            trainingSessionActions_1.TrainingEventEmitter.sessionSaved(trainedTestSavedMessage.test.id, trainedTestSavedMessage.test.invariant_id, trainedTestSavedMessage.branch, trainedTestSavedMessage.planId);
            break;
        case TRAINED_TEST_INFO:
            const trainedTestInfoMessage = message;
            if (!trainedTestInfoMessage.test.id ||
                !trainedTestInfoMessage.test.invariant_id) {
                break;
            }
            trainingSessionActions_1.TrainingEventEmitter.sessionSaved(trainedTestInfoMessage.test.id, trainedTestInfoMessage.test.invariant_id, trainedTestInfoMessage.branch, trainedTestInfoMessage.planId);
            const table = new cli_table3_1.default({
                head: [chalk.yellow('Saved Test Info')],
                wordWrap: true,
            });
            table.push([
                {
                    rowSpan: 1,
                    content: 'ID',
                    vAlign: 'center',
                },
                {
                    rowSpan: 1,
                    content: trainedTestInfoMessage.test.invariant_id,
                    vAlign: 'center',
                },
            ], [
                {
                    rowSpan: 1,
                    content: 'Name',
                    vAlign: 'center',
                },
                {
                    rowSpan: 1,
                    content: trainedTestInfoMessage.test.name,
                    vAlign: 'center',
                },
            ], [
                {
                    rowSpan: 1,
                    content: 'Branch',
                    vAlign: 'center',
                },
                {
                    rowSpan: 1,
                    content: trainedTestInfoMessage.branch,
                    vAlign: 'center',
                },
            ]);
            messaging_1.mablEventEmitter.log(table.toString());
            if (trainedTestInfoMessage.link) {
                messaging_1.mablEventEmitter.log(`View test: ${trainedTestInfoMessage.link}`);
            }
            messaging_1.mablEventEmitter.log('');
            break;
        case LOG_LINE_OUTPUT:
            const logLineMessage = message;
            if (logLineMessage.message) {
                switch (logLineMessage.level) {
                    case 'error':
                        messaging_1.mablEventEmitter.log(chalk.red(`[ERROR] ${logLineMessage.message}`), Date.now());
                        break;
                    case 'debug':
                        messaging_1.mablEventEmitter.debug(chalk.gray(logLineMessage.message), Date.now());
                        break;
                    default:
                        messaging_1.mablEventEmitter.log(logLineMessage.message, Date.now());
                }
            }
            break;
        default:
            break;
    }
}
function cleanupTestResources(testContext) {
    try {
        if (testContext) {
            testContext.getFileUploadDirs().forEach((dir) => (0, fileUploadUtil_1.removeUploadDirs)(dir));
            testContext.clearFileUploadDirs();
        }
    }
    catch (e) {
        const msg = `WARNING: error received when cleaning up after tests: ${e.message}`;
        (0, logUtils_1.logCliOutput)(loggingProvider_1.LogLevel.Warn, msg);
    }
}
exports.cleanupTestResources = cleanupTestResources;
function validateRunEditCommand(idArg, testRunIdArg) {
    if (!idArg && !testRunIdArg) {
        throw new Error(chalk.red(`Please specify a test ID (--${constants_1.CommandArgId}) or test run ID (--${constants_1.CommandArgTestRunId})\n`));
    }
    if (idArg && testRunIdArg) {
        throw new Error(chalk.red(`Command does not support specifying both the test id (--${constants_1.CommandArgId})  AND the test run id (--${constants_1.CommandArgTestRunId}), please only supply one\n`));
    }
    return true;
}
exports.validateRunEditCommand = validateRunEditCommand;
function validateRunCommandWithLabels(testId, suppliedLabelsInclude, suppliedLabelsExclude, testRunId, planId, checkForRunIdOrPlanId = false, testFile) {
    function cleanLabels(input) {
        const distinctLabels = new Set();
        input
            .map((label) => label.toString().trim().toLowerCase())
            .forEach((label) => distinctLabels.add(label));
        return [...distinctLabels];
    }
    const labelsInclude = cleanLabels(suppliedLabelsInclude !== null && suppliedLabelsInclude !== void 0 ? suppliedLabelsInclude : []);
    const labelsExclude = cleanLabels(suppliedLabelsExclude !== null && suppliedLabelsExclude !== void 0 ? suppliedLabelsExclude : []);
    if (labelsInclude.length > 0 && labelsExclude.length > 0) {
        const intersection = labelsInclude.filter((label) => labelsExclude.includes(label));
        if (intersection.length > 0) {
            throw new Error(`Include labels --${constants_1.CommandArgLabelsInclude} and exclude labels --${constants_1.CommandArgLabelsExclude} have overlapping values [${intersection.join(',')}]`);
        }
    }
    const maybeId = testId;
    if (checkForRunIdOrPlanId) {
        if (maybeId === undefined &&
            testRunId === undefined &&
            planId === undefined &&
            testFile === undefined &&
            labelsInclude.length === 0 &&
            labelsExclude.length === 0) {
            throw new Error(`Please provide at least one of --${constants_1.CommandArgId}, --${constants_1.CommandArgTestRunId},  --${constants_1.CommandArgLabelsInclude}, --${constants_1.CommandArgLabelsExclude}, --${constants_1.CommandArgFromPlanId}`);
        }
    }
    else if (maybeId === undefined &&
        labelsInclude.length === 0 &&
        labelsExclude.length === 0) {
        throw new Error(`Please provide at least one of --${constants_1.CommandArgId}, --${constants_1.CommandArgLabelsInclude}, --${constants_1.CommandArgLabelsExclude}`);
    }
    return true;
}
exports.validateRunCommandWithLabels = validateRunCommandWithLabels;
async function pullDownTestRunConfig(testRunId, apiClient) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const journeyRun = await apiClient.getTestRun(testRunId);
    const planRun = await apiClient.getPlanRun(journeyRun.parent_execution);
    const testDatatablevariables = ((_a = journeyRun === null || journeyRun === void 0 ? void 0 : journeyRun.journey_parameters) === null || _a === void 0 ? void 0 : _a.user_variables) &&
        (0, utils_1.variableRowAsScenario)((_b = journeyRun === null || journeyRun === void 0 ? void 0 : journeyRun.journey_parameters) === null || _b === void 0 ? void 0 : _b.user_variables);
    const dataTableId = testDatatablevariables === null || testDatatablevariables === void 0 ? void 0 : testDatatablevariables.table_id;
    if (dataTableId) {
        await apiClient.getDataTable(dataTableId);
    }
    return {
        basicAuthCredentialsId: ((_c = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _c === void 0 ? void 0 : _c.http_auth_credentials_required)
            ? (_d = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _d === void 0 ? void 0 : _d.http_auth_credentials_id
            : undefined,
        branchName: (_e = journeyRun.journey_parameters) === null || _e === void 0 ? void 0 : _e.source_control_tag,
        credentialsId: ((_f = planRun.run_policy) === null || _f === void 0 ? void 0 : _f.credentials_required)
            ? (_g = planRun.run_policy) === null || _g === void 0 ? void 0 : _g.credentials_id
            : undefined,
        dataTableVariables: testDatatablevariables,
        deviceEmulation: (_h = journeyRun.journey_parameters) === null || _h === void 0 ? void 0 : _h.device_emulation,
        environmentId: (_k = (_j = journeyRun.journey_parameters) === null || _j === void 0 ? void 0 : _j.deployment) === null || _k === void 0 ? void 0 : _k.environment_id,
        extraHttpHeaders: ((_l = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _l === void 0 ? void 0 : _l.http_headers_required) === true
            ? (_o = (_m = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _m === void 0 ? void 0 : _m.http_headers) === null || _o === void 0 ? void 0 : _o.reduce((headers, header) => {
                var _a;
                return ({
                    ...headers,
                    [header.name]: (_a = header.value) !== null && _a !== void 0 ? _a : '',
                });
            }, {})
            : undefined,
        filterHttpRequests: false,
        importedVariables: (_p = journeyRun.journey_parameters) === null || _p === void 0 ? void 0 : _p.imported_variables,
        linkCrawlerStartingUrlOverride: getLinkCrawlerUrlOverride(journeyRun),
        localizationOptions: journeyRun.localization_options,
        pageLoadWait: (_q = journeyRun.journey_parameters) === null || _q === void 0 ? void 0 : _q.page_load_wait,
        runId: journeyRun.id,
        testId: (_r = journeyRun.journey) === null || _r === void 0 ? void 0 : _r.invariant_id,
        url: (_t = (_s = journeyRun.journey_parameters) === null || _s === void 0 ? void 0 : _s.deployment) === null || _t === void 0 ? void 0 : _t.uri,
    };
}
exports.pullDownTestRunConfig = pullDownTestRunConfig;
async function extractTestRunConfig(executionMessage, apiClient) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    const journeyRun = (_a = executionMessage.journey_run) !== null && _a !== void 0 ? _a : (await apiClient.getTestRun(executionMessage.journey_run_id));
    const planRun = executionMessage.plan_run;
    const maybeRunnerType = ((_b = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _b === void 0 ? void 0 : _b.nodejs_runtime_variant)
        ?
            (_c = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _c === void 0 ? void 0 : _c.nodejs_runtime_variant
        : undefined;
    const config = {
        basicAuthCredentialsId: ((_d = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _d === void 0 ? void 0 : _d.http_auth_credentials_required)
            ? (_e = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _e === void 0 ? void 0 : _e.http_auth_credentials_id
            : undefined,
        branchName: (_f = journeyRun === null || journeyRun === void 0 ? void 0 : journeyRun.journey_parameters) === null || _f === void 0 ? void 0 : _f.source_control_tag,
        credentialsId: ((_g = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _g === void 0 ? void 0 : _g.credentials_required)
            ? (_h = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _h === void 0 ? void 0 : _h.credentials_id
            : undefined,
        dataTableVariables: ((_j = journeyRun === null || journeyRun === void 0 ? void 0 : journeyRun.journey_parameters) === null || _j === void 0 ? void 0 : _j.user_variables) &&
            (0, utils_1.variableRowAsScenario)((_k = journeyRun === null || journeyRun === void 0 ? void 0 : journeyRun.journey_parameters) === null || _k === void 0 ? void 0 : _k.user_variables),
        deviceEmulation: (_l = journeyRun === null || journeyRun === void 0 ? void 0 : journeyRun.journey_parameters) === null || _l === void 0 ? void 0 : _l.device_emulation,
        environmentId: (_o = (_m = journeyRun === null || journeyRun === void 0 ? void 0 : journeyRun.journey_parameters) === null || _m === void 0 ? void 0 : _m.deployment) === null || _o === void 0 ? void 0 : _o.environment_id,
        extraHttpHeaders: ((_p = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _p === void 0 ? void 0 : _p.http_headers_required) === true
            ? headerArrayToRecord((_q = planRun === null || planRun === void 0 ? void 0 : planRun.run_policy) === null || _q === void 0 ? void 0 : _q.http_headers)
            : undefined,
        filterHttpRequests: true,
        importedVariables: (_r = journeyRun.journey_parameters) === null || _r === void 0 ? void 0 : _r.imported_variables,
        linkCrawlerStartingUrlOverride: getLinkCrawlerUrlOverride(journeyRun),
        localizationOptions: journeyRun.localization_options,
        pageLoadWait: (_s = journeyRun.journey_parameters) === null || _s === void 0 ? void 0 : _s.page_load_wait,
        runId: journeyRun.id,
        runnerType: maybeRunnerType,
        testId: (_t = journeyRun === null || journeyRun === void 0 ? void 0 : journeyRun.journey) === null || _t === void 0 ? void 0 : _t.invariant_id,
        url: (_v = (_u = journeyRun === null || journeyRun === void 0 ? void 0 : journeyRun.journey_parameters) === null || _u === void 0 ? void 0 : _u.deployment) === null || _v === void 0 ? void 0 : _v.uri,
    };
    if (executionMessage.test_type === mablApi_1.TestTypeEnum.Mobile) {
        const mobileMessage = executionMessage;
        config.mobileConfig = {
            ...config.mobileConfig,
            deviceName: mobileMessage.mobile_device.device_name,
            platformName: mobileMessage.mobile_device.platform,
            mobileAppFileId: mobileMessage.mobile_app_file_id,
        };
        if (mobileMessage.mobile_device.platform === mablApi_1.MobilePlatformEnum.Ios) {
            config.mobileConfig.platformVersion =
                mobileMessage.mobile_device.os_version;
        }
    }
    return config;
}
exports.extractTestRunConfig = extractTestRunConfig;
function getLinkCrawlerUrlOverride(journeyRun) {
    var _a, _b, _c;
    return (_c = (_b = (_a = journeyRun === null || journeyRun === void 0 ? void 0 : journeyRun.journey_configuration) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 : _b.find((param) => param.name === linkCrawlerStartUrlParam)) === null || _c === void 0 ? void 0 : _c.value;
}
exports.getLinkCrawlerUrlOverride = getLinkCrawlerUrlOverride;
function headerArrayToRecord(headers) {
    return headers === null || headers === void 0 ? void 0 : headers.reduce((headers, header) => {
        var _a;
        return ({
            ...headers,
            [header.name]: (_a = header.value) !== null && _a !== void 0 ? _a : '',
        });
    }, {});
}
exports.headerArrayToRecord = headerArrayToRecord;
function calculateTotalTimeSeconds(startTimeMillis, endTimeMillis) {
    return (endTimeMillis - startTimeMillis) / 1000;
}
exports.calculateTotalTimeSeconds = calculateTotalTimeSeconds;
function milliSecondsToSeconds(timeMs) {
    return Math.round((timeMs !== null && timeMs !== void 0 ? timeMs : 0) / 100) / 10;
}
exports.milliSecondsToSeconds = milliSecondsToSeconds;
function logTestInfoIfPresent(description, infoArg) {
    if (infoArg !== undefined) {
        messaging_1.mablEventEmitter.log(chalk.cyan(description, chalk.magenta(infoArg.toString())));
    }
}
exports.logTestInfoIfPresent = logTestInfoIfPresent;
function createDownloadDirectory() {
    return fs.mkdtempSync(path.join(os.tmpdir(), `mablTestRun-${Date.now()}-`));
}
function toBasicHttpAuthenticationCredentials(credentials) {
    var _a, _b, _c, _d, _e;
    if (credentials === undefined ||
        ((_a = credentials.properties) === null || _a === void 0 ? void 0 : _a.username) === undefined) {
        return undefined;
    }
    return {
        username: (_c = (_b = credentials.properties) === null || _b === void 0 ? void 0 : _b.username) !== null && _c !== void 0 ? _c : '',
        password: (_e = (_d = credentials.properties) === null || _d === void 0 ? void 0 : _d.password) !== null && _e !== void 0 ? _e : '',
    };
}
exports.toBasicHttpAuthenticationCredentials = toBasicHttpAuthenticationCredentials;
function parseBrowserType(browserType) {
    switch (browserType) {
        case 'edge':
            return browserTypes_1.BrowserType.Edge;
        case 'firefox':
            return browserTypes_1.BrowserType.Firefox;
        case 'chrome':
            return browserTypes_1.BrowserType.Chrome;
        case 'webkit':
            return browserTypes_1.BrowserType.Webkit;
        default:
            return constants_1.DefaultBrowserType;
    }
}
exports.parseBrowserType = parseBrowserType;
