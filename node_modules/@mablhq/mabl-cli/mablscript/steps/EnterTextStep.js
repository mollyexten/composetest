"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnterTextStep = void 0;
const FindAction_1 = require("../actions/FindAction");
const MablAction_1 = require("../MablAction");
const domUtil_1 = require("../../domUtil");
const MablStepWithFindAction_1 = require("../MablStepWithFindAction");
class EnterTextStep extends MablStepWithFindAction_1.MablStepWithFindAction {
    constructor(name, args, actions) {
        super(name, args, actions, 'enter_text');
        const arg = this.getActionArgs()[0];
        this.text = (0, MablAction_1.parseArgument)(arg);
        this.validate();
        if ((0, domUtil_1.isFindElementType)(this.actions[0].getActionName())) {
            this.findAction = this.actions[0];
        }
        else {
            throw new Error(`Unexpected find action for ${name} step: ${JSON.stringify(this.actions[0])}`);
        }
    }
    validate() {
        if (this.actions.length !== 1 && !(this.actions[0] instanceof FindAction_1.FindAction)) {
            throw new Error('Enter text steps should have exactly on sub action and it should be a find');
        }
    }
    getStepName() {
        return 'EnterText';
    }
    toStepDescriptor() {
        const find = this.findAction.toDescriptor();
        switch (find.findType) {
            case domUtil_1.FindType.FIND_FIRST:
            case domUtil_1.FindType.FIND_LAST:
            case domUtil_1.FindType.FIND_ANY:
            case domUtil_1.FindType.FIND_ONE:
                return {
                    find,
                    descriptorToActionMap: new Map().set(find, this.findAction),
                    text: this.text,
                    actionCode: this.actionCode,
                };
            default:
                throw new Error(`Error generating step descriptor for ${this.getStepName()}: Unexpected find type ${find.findType}`);
        }
    }
    getFormattedStep() {
        var _a;
        const step = this.toStepDescriptor();
        const stepName = this.getStepName();
        const formatted = {
            [stepName]: {},
        };
        if (this.annotationsOnStep()) {
            formatted[stepName].annotation = this.annotation;
        }
        if (this.description) {
            formatted[stepName].description = this.description;
        }
        if (step.find.findType === domUtil_1.FindType.FIND_ONE) {
            formatted[stepName].selector = step.find.findTarget.selector;
            if ((_a = step.find.findTarget.auxiliaryDescriptors) === null || _a === void 0 ? void 0 : _a.length) {
                formatted[stepName].selectorAncestors =
                    step.find.findTarget.auxiliaryDescriptors.map((descriptor) => descriptor.selector);
            }
        }
        else {
            formatted[stepName].selector = step.find.findTarget;
        }
        formatted[stepName].findType = FindAction_1.findTypesToFormattedType[step.find.findType];
        formatted[stepName].text = this.text.toString();
        if (this.stepId()) {
            formatted[stepName].id = this.stepId();
        }
        return formatted;
    }
    static fromYaml(_stepName, stepArgs) {
        const step = new EnterTextStep('enter_text', [stepArgs.text], [FindAction_1.FindAction.findActionFromStepArgs(stepArgs)]);
        step.setStepId(stepArgs.id);
        return step;
    }
    toMablscript() {
        const enterText = typeof this.text === 'string'
            ? `"${(0, domUtil_1.escapeMablscriptString)(this.text)}"`
            : this.substituteMablscriptVariable(this.text);
        return `${this.findAction.toMablscript()}.enter_text(${enterText})`;
    }
    getInputVariables() {
        return (0, MablAction_1.distinctStrings)([
            ...this.findAction.getInputVariables(),
            ...MablAction_1.MablAction.findUniqueVariableReferencesInValue(this.text),
        ]);
    }
}
exports.EnterTextStep = EnterTextStep;
EnterTextStep.mablScriptStepNames = ['enter_text'];
EnterTextStep.yamlMablScriptNames = ['EnterText'];
