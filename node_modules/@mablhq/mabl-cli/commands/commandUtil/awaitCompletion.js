"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwaitCompletion = exports.PollingOutcomeType = void 0;
var PollingOutcomeType;
(function (PollingOutcomeType) {
    PollingOutcomeType[PollingOutcomeType["Queued"] = 0] = "Queued";
    PollingOutcomeType[PollingOutcomeType["Running"] = 1] = "Running";
    PollingOutcomeType[PollingOutcomeType["Terminated"] = 2] = "Terminated";
    PollingOutcomeType[PollingOutcomeType["Complete"] = 3] = "Complete";
    PollingOutcomeType[PollingOutcomeType["Timeout"] = 4] = "Timeout";
})(PollingOutcomeType || (exports.PollingOutcomeType = PollingOutcomeType = {}));
const completeStates = Object.freeze([
    PollingOutcomeType.Complete,
    PollingOutcomeType.Timeout,
]);
class AwaitCompletion {
    constructor(apiClient, pollingTimeoutMilliseconds, pollingIntervalMilliseconds) {
        this.apiClient = apiClient;
        this.defaultPollingTimeoutMilliseconds = 10 * 60 * 1000;
        this.defaultPollingIntervalMilliseconds = 1000;
        this.pollingTimeoutMilliseconds =
            pollingTimeoutMilliseconds || this.defaultPollingTimeoutMilliseconds;
        this.pollingIntervalMilliseconds =
            pollingIntervalMilliseconds || this.defaultPollingIntervalMilliseconds;
        this.startedEpochMilliseconds = Date.now();
    }
    setPollingInterval(milliseconds) {
        this.pollingIntervalMilliseconds = milliseconds;
    }
    isComplete(status) {
        return completeStates.includes(status);
    }
    getElapsedMilliseconds() {
        return Date.now() - this.startedEpochMilliseconds;
    }
    isTimedOut() {
        const millisecondsElapsed = this.getElapsedMilliseconds();
        return millisecondsElapsed >= this.pollingTimeoutMilliseconds;
    }
    async awaitCompletion(seedId) {
        if (!seedId) {
            throw new Error('Seed is undefined');
        }
        const pollingResult = await this.pollingFunction(this.apiClient, undefined, seedId);
        this.statusPresenter(pollingResult.newEntity, pollingResult.status);
        if (this.isTimedOut()) {
            this.timeoutStatusPresenter(pollingResult.newEntity);
            return {
                newEntity: pollingResult.newEntity,
                status: PollingOutcomeType.Timeout,
            };
        }
        if (this.isComplete(pollingResult.status)) {
            this.completedStatusPresenter(pollingResult.newEntity);
            return {
                newEntity: pollingResult.newEntity,
                status: PollingOutcomeType.Complete,
            };
        }
        return new Promise((resolve, reject) => {
            setTimeout(() => this.awaitCompletion(seedId)
                .then((result) => resolve(result))
                .catch((error) => reject(error)), this.pollingIntervalMilliseconds);
        });
    }
}
exports.AwaitCompletion = AwaitCompletion;
