// All this code can be removed once we move to Playwright.
mablCheckActionability = (node, point) => {
  const autoClosingTags = new Set([
    'AREA',
    'BASE',
    'BR',
    'COL',
    'COMMAND',
    'EMBED',
    'HR',
    'IMG',
    'INPUT',
    'KEYGEN',
    'LINK',
    'MENUITEM',
    'META',
    'PARAM',
    'SOURCE',
    'TRACK',
    'WBR',
  ]);
  const booleanAttributes = new Set([
    'checked',
    'selected',
    'disabled',
    'readonly',
    'multiple',
  ]);

  const parentElementOrShadowHost = function(element) {
    if (element.parentElement) {
      return element.parentElement;
    }
    if (!element.parentNode) {
      return;
    }
    if (
      element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&
      element.parentNode.host
    ) {
      return element.parentNode.host;
    }

    return undefined;
  };

  const deepElementFromPoint = function(document, x, y) {
    let container = document;
    let element;
    while (container) {
      // elementFromPoint works incorrectly in Chromium (http://crbug.com/1188919),
      // so we use elementsFromPoint instead.
      const elements = container.elementsFromPoint(x, y);
      const innerElement = elements[0];
      if (!innerElement || element === innerElement) {
        break;
      }
      element = innerElement;
      container = element.shadowRoot;
    }
    return element;
  };

  const oneLine = function(s) {
    return s.replace(/\n/g, '↵').replace(/\t/g, '⇆');
  };

  const previewNode = function(node) {
    if (!node) {
      return '';
    }

    if (node.nodeType === Node.TEXT_NODE) {
      return oneLine(`#text=${node.nodeValue || ''}`);
    }
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return oneLine(`<${node.nodeName.toLowerCase()} />`);
    }
    const element = node;

    const attrs = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (let i = 0; i < element.attributes.length; i++) {
      const {name, value} = element.attributes[i];
      if (name === 'style') {
        continue;
      }
      if (!value && booleanAttributes.has(name)) {
        attrs.push(` ${name}`);
      } else {
        attrs.push(` ${name}="${value}"`);
      }
    }
    attrs.sort((a, b) => a.length - b.length);
    let attrText = attrs.join('');
    if (attrText.length > 50) {
      attrText = attrText.substring(0, 49) + '\u2026';
    }
    if (autoClosingTags.has(element.nodeName)) {
      return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);
    }

    const children = element.childNodes;
    let onlyText = false;
    if (children.length <= 5) {
      onlyText = true;
      // eslint-disable-next-line @typescript-eslint/prefer-for-of
      for (let i = 0; i < children.length; i++) {
        onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;
      }
    }
    let text = onlyText
      ? element.textContent || ''
      : children.length
      ? '\u2026'
      : '';
    if (text.length > 50) {
      text = text.substring(0, 49) + '\u2026';
    }
    return oneLine(
      `<${element.nodeName.toLowerCase()}${attrText}>${text}</${element.nodeName.toLowerCase()}>`,
    );
  };

  let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
  if (!element || !element.isConnected) {
    return 'error:notconnected';
  }
  element = element.closest('button, [role=button]') || element;
  let hitElement = deepElementFromPoint(document, point.x, point.y);
  const hitParents = [];
  while (hitElement && hitElement !== element) {
    hitParents.push(hitElement);
    hitElement = parentElementOrShadowHost(hitElement);
  }
  if (hitElement === element) {
    return 'done';
  }
  const actionabilityDescription = previewNode(hitParents[0]);
  // Root is the topmost element in the hitTarget's chain that is not in the
  // element's chain. For example, it might be a dialog element that overlays
  // the target.
  let rootActionabilityDescription;
  while (element) {
    const index = hitParents.indexOf(element);
    if (index !== -1) {
      if (index > 1) {
        rootActionabilityDescription = previewNode(hitParents[index - 1]);
      }
      break;
    }
    element = parentElementOrShadowHost(element);
  }
  if (rootActionabilityDescription) {
    return {
      actionabilityDescription: `${actionabilityDescription} from ${rootActionabilityDescription} subtree`,
    };
  }
  return {actionabilityDescription};
};
