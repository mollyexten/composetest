"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configKeyCommandArg = void 0;
const cliConfigProvider_1 = require("../../../providers/cliConfigProvider");
const mablApiClientFactory_1 = require("../../../api/mablApiClientFactory");
const list_1 = require("./list");
const loggingProvider_1 = require("../../../providers/logging/loggingProvider");
const configKeys_1 = require("./configKeys");
const types_1 = require("../../../api/types");
exports.configKeyCommandArg = 'config-key';
const configValue = 'config-value';
exports.command = `set <${exports.configKeyCommandArg}> <${configValue}>`;
exports.describe = 'Set a default configuration key';
exports.builder = (yargs) => {
    yargs
        .positional(exports.configKeyCommandArg, {
        describe: 'The configuration key to set',
        type: 'string',
        choices: configKeys_1.validConfigKeyChoices,
    })
        .positional(configValue, {
        describe: 'The value to configure for the config',
        type: 'string',
    });
};
exports.handler = setConfig;
async function setConfig(parsed) {
    const key = parsed['config-key'];
    const value = parsed['config-value'];
    switch (key) {
        case configKeys_1.configKeys.browserPath:
            await cliConfigProvider_1.CliConfigProvider.setConfigProperty(configKeys_1.configKeys.browserPath, value);
            break;
        case configKeys_1.configKeys.defaultWorkspaceId:
            const apiClient = await mablApiClientFactory_1.MablApiClientFactory.createApiClient();
            const workspace = await apiClient.getWorkspace(value);
            await cliConfigProvider_1.CliConfigProvider.setWorkspace(workspace);
            break;
        case configKeys_1.configKeys.enableSourceControlMetadataCollection:
        case configKeys_1.configKeys.sslVerify:
            if (!['true', 'false'].includes(value)) {
                throw new Error("Valid values are 'true' and 'false'");
            }
            const booleanValue = value === 'true';
            await cliConfigProvider_1.CliConfigProvider.setConfigProperty(key, booleanValue);
            break;
        case configKeys_1.configKeys.proxy:
            if (!isValidUrl(value)) {
                throw new Error(`Invalid URL specified. The value must be a fully specified URL with a valid protocol and domain: ${value}`);
            }
            await cliConfigProvider_1.CliConfigProvider.setConfigProperty(key, value);
            break;
        case configKeys_1.configKeys.proxyMode:
            if (!(0, configKeys_1.isValidProxyMode)(value)) {
                throw new Error(`Invalid proxy mode. The value must be one of ${JSON.stringify(configKeys_1.proxyModes)}`);
            }
            await cliConfigProvider_1.CliConfigProvider.setConfigProperty(key, value);
            break;
        case configKeys_1.configKeys.proxyType:
            if (!(0, types_1.isValidProxyType)(value)) {
                throw new Error(`Invalid proxy type. The value must be one of ${JSON.stringify(types_1.proxyTypes)}`);
            }
            await cliConfigProvider_1.CliConfigProvider.setConfigProperty(key, value);
            break;
        default:
            throw new Error(`<${exports.configKeyCommandArg}> value not one of supported types: ${JSON.stringify(configKeys_1.validConfigKeyChoices)}`);
    }
    loggingProvider_1.logger.info(`Configured [${key}] = [${value}]`);
    await (0, list_1.listConfig)();
    return key;
}
function isValidUrl(value) {
    try {
        const url = new URL(value);
        return (url.hostname.length > 0 &&
            ['http:', 'https:'].includes(url.protocol.toLowerCase()));
    }
    catch {
        return false;
    }
}
