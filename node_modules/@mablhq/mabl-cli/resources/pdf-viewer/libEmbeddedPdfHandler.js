var EmbeddedPdfHandler;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it declares 'EmbeddedPdfHandler' on top-level, which conflicts with the current library output.
(() => {
/*!***********************************!*\
  !*** ./src/EmbeddedPdfHandler.js ***!
  \***********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EmbeddedPdfHandler": () => (/* binding */ EmbeddedPdfHandler),
/* harmony export */   "MABL_PDF_DETECTOR_ANIMATION_NAME": () => (/* binding */ MABL_PDF_DETECTOR_ANIMATION_NAME),
/* harmony export */   "MABL_PDF_DETECTOR_STYLE_ID": () => (/* binding */ MABL_PDF_DETECTOR_STYLE_ID),
/* harmony export */   "MABL_PROCESSED_PDF_ATTRIBUTE": () => (/* binding */ MABL_PROCESSED_PDF_ATTRIBUTE),
/* harmony export */   "PDFEventType": () => (/* binding */ PDFEventType)
/* harmony export */ });
var MABL_PROCESSED_PDF_ATTRIBUTE = '__mabl-processed-pdf';
var MABL_PDF_DETECTOR_STYLE_ID = '__mabl-pdf-detector';
var MABL_PDF_DETECTOR_ANIMATION_NAME = '__mabl-trainer-object-embed-detector';
var MABL_PDF_SRC_ATTRIBUTE = 'data-mabl-pdf-src';
var PDFEventType = 'animationstart';
class EmbeddedPdfHandler {
  constructor(PDFEmbeddedViewerBaseUrl, createElement, shouldHandlePredicate, cMapUrl) {
    this.PDFEmbeddedViewerBaseUrl = PDFEmbeddedViewerBaseUrl;
    this.createElement = createElement || document.createElement;

    this.shouldHandle = shouldHandlePredicate || (() => true);

    this.cMapUrl = cMapUrl;
    this.handle = this.handle.bind(this);
    this.register = this.register.bind(this);
    this.updateElement = this.updateElement.bind(this);
    this.createViewerElement = this.createViewerElement.bind(this);
    this.checkUrlProtocol = this.checkUrlProtocol.bind(this);
  }

  register() {
    if (document.doctype && document.doctype.name && document.doctype.name.indexOf('html') === -1) {
      // don't inject on non-HTML pages, such as XML, which causes the style to be visible
      // e.g. http://storage.googleapis.com/mabl-dev-pdf/not-a-page.html
      return;
    }

    if (!document.getElementById(MABL_PDF_DETECTOR_STYLE_ID)) {
      var pdfDetectorStyleElem = this.createElement.call(document, 'style');
      pdfDetectorStyleElem.innerHTML = "\n      @keyframes ".concat(MABL_PDF_DETECTOR_ANIMATION_NAME, " { from {} }\n      object, embed {\n        animation-delay: 0s !important;\n        animation-name: ").concat(MABL_PDF_DETECTOR_ANIMATION_NAME, " !important;\n        animation-play-state: running !important;\n      }");
      pdfDetectorStyleElem.id = MABL_PDF_DETECTOR_STYLE_ID;
      this.pdfDetectorStyleElem = pdfDetectorStyleElem;

      if (document.head) {
        // the default PDF page in Chrome doesn't have a head, and the browser doesn't insert one
        document.head.appendChild(pdfDetectorStyleElem);
      } else if (document.body) {
        document.body.appendChild(pdfDetectorStyleElem);
      } else {
        // treat this as not an HTML document
        return;
      }
    }

    window.addEventListener(PDFEventType, this.handle, true);
  }

  unregister() {
    window.removeEventListener(PDFEventType, this.handle, true);

    if (this.pdfDetectorStyleElem && this.pdfDetectorStyleElem.parentNode) {
      this.pdfDetectorStyleElem.parentNode.removeChild(this.pdfDetectorStyleElem);
    }
  }

  handle(event) {
    if (!this.canHandleEvent(event)) {
      return;
    }

    var pdfElement = event.target;
    this.updateElement(pdfElement);
  }

  checkAnimationEvent(event) {
    return event.animationName === MABL_PDF_DETECTOR_ANIMATION_NAME;
  }

  checkElement(element) {
    return element.tagName === 'EMBED' || element.tagName === 'OBJECT';
  }

  checkMimeType(element) {
    var mimeType = element.type;
    var path = this.getPdfUrlFromElement(element);
    var isAPdf = mimeType && mimeType.toLowerCase() === 'application/pdf' || // mime type is PDF
    !mimeType && path && /\.pdf($|[?#])/i.test(path) || // or if we don't have a mime type test the path up to query or hash
    !!element[MABL_PROCESSED_PDF_ATTRIBUTE]; // it's an element we've already identified

    return isAPdf;
  }
  /**
   * Checks that the URL embedding the PDF leads to a valid location and/or
   * has a valid protocol
   * @param {HTMLElement} element The element on the page whose URL to check
   * @returns {boolean} Whether or not the element is valid
   */


  checkUrlProtocol(element) {
    if (element.src === 'about:blank') {
      // this is likely the chrome viewer for a POST
      // don't do anything, we might get a manual update later
      // if the trainer finds a PDF
      return false;
    } // Validate that the URL is an allowed protocol to prevent XSS, see IST-561


    var pdfUrlString = this.getPdfUrlFromElement(element);

    try {
      var _pdfUrl$href;

      var pdfUrl = new URL(pdfUrlString); // data: is allowed to support embedding the PDF inline using a data URI scheme

      var allowedProtocols = ['http:', 'https:', 'data:'];

      if (!allowedProtocols.includes(pdfUrl === null || pdfUrl === void 0 ? void 0 : pdfUrl.protocol)) {
        console.warn("PDF Handler ignoring element with URL ".concat(pdfUrlString, " because protocol ").concat(pdfUrl === null || pdfUrl === void 0 ? void 0 : pdfUrl.protocol, " does not match one of the allowed protocols ").concat(allowedProtocols));
        return false;
      } else if ((pdfUrl === null || pdfUrl === void 0 ? void 0 : pdfUrl.protocol) === 'data:' && !/^data:application\/pdf[,;]/.test((_pdfUrl$href = pdfUrl === null || pdfUrl === void 0 ? void 0 : pdfUrl.href) !== null && _pdfUrl$href !== void 0 ? _pdfUrl$href : '') // starts with data:application/pdf and either , or ; separator
      ) {
        console.warn("PDF Handler ignoring element with URL ".concat(pdfUrlString, " because it does not use application/pdf MIME type"));
        return false;
      }
    } catch (e) {
      console.warn("PDF Handler ignoring element with URL ".concat(pdfUrlString, "; error ").concat(e, " was thrown while converting to URL"));
      return false;
    }

    return true;
  }

  canHandleEvent(event) {
    var element = event.target;
    return this.shouldHandle(event) && this.checkAnimationEvent(event) && this.checkElement(element) && this.checkMimeType(element) && this.checkUrlProtocol(element);
  } // adapted from PDF.js
  // Display the PDF Viewer in an <embed>.


  updateElement(elem) {
    if (elem.type === 'text/html' && elem.src.lastIndexOf(this.PDFEmbeddedViewerBaseUrl, 0) === 0) {
      // The viewer is already shown.
      return;
    } // The <embed> or <object> tag needs to be removed and replaced with our element


    var parentNode = elem.parentNode;
    var nextSibling = elem.nextSibling;
    var viewerElem = this.createViewerElement(elem);

    if (parentNode) {
      parentNode.removeChild(elem);
      parentNode.insertBefore(viewerElem, nextSibling);
    }
  }
  /**
   * Returns the URL string of the element which should in some way be embedding a PDF.
   * @param {HTMLElement} originalPdfElement The element embedding the PDF, should have embed tag, object tag,
   *                    or have the mabl-pdf-url attribute
   * @returns {(string|undefined)} The URL which should host the PDF, or undefined if none was found
   */


  getPdfUrlFromElement(originalPdfElement) {
    var pdfUrl = originalPdfElement.src || originalPdfElement.data || // embed has @src, object has @data
    originalPdfElement.getAttribute('mabl-pdf-url') || // special case for embedded blob urls
    undefined; // getAttribute can return null or '', would prefer to return undefined

    if (pdfUrl === 'about:blank') {
      // we're likely in the chrome viewer, so window.location actually has
      // the right URL
      pdfUrl = window.location.href;
    }

    return pdfUrl;
  }

  createViewerElement(originalPdfElement) {
    var viewerElem = this.createElement.call(document, 'iframe');
    var pdfUrl = this.getPdfUrlFromElement(originalPdfElement); // Firefox does not always get the correct offsetHeight and offsetWidth
    // so if the value returned is 0, then just leave the size to the default size

    if (originalPdfElement.offsetHeight && originalPdfElement.offsetWidth) {
      viewerElem.height = originalPdfElement.offsetHeight;
      viewerElem.width = originalPdfElement.offsetWidth;
    } else if (originalPdfElement.height && originalPdfElement.width) {
      // Default to height and width of original if available
      viewerElem.height = originalPdfElement.height;
      viewerElem.width = originalPdfElement.width;
    }

    viewerElem.id = '__mabl_pdf_viewer_' + this.idSanitize(this.getPdfFilenameFromUrl(pdfUrl));
    viewerElem.src = this.getEmbeddedViewerURL(pdfUrl);
    viewerElem.setAttribute(MABL_PROCESSED_PDF_ATTRIBUTE, 'true');
    viewerElem.setAttribute(MABL_PDF_SRC_ATTRIBUTE, pdfUrl);
    return viewerElem;
  }

  getEmbeddedViewerURL(path) {
    var fragment = /^([^#]*)(#.*)?$/.exec(path);
    path = fragment[1];
    fragment = fragment[2] || ''; // Resolve relative path to document.

    var a = document.createElement('a');
    a.href = document.baseURI;
    a.href = path;
    path = a.href;
    return this.getViewerURL(path) + fragment;
  }

  getPdfFilenameFromUrl(pdfUrl) {
    var parsedUrl = new URL(pdfUrl);
    var pdfFileName = parsedUrl.pathname.split('/').slice(-1)[0] || 'mablPdf';

    if (pdfUrl.startsWith('blob:')) {
      pdfFileName = 'blob_pdf';
    }

    return pdfFileName;
  }

  getViewerURL(pdfUrl) {
    var pdfFileName = this.getPdfFilenameFromUrl(pdfUrl);
    return this.PDFEmbeddedViewerBaseUrl + '?file=' + encodeURIComponent(pdfUrl) + '&name=' + pdfFileName;
  }

  idSanitize(originalId) {
    // TODO: make sure this is sufficient to create valid IDs
    return originalId && originalId.replace(/[^a-zA-Z0-9.-]/g, '_');
  }

}
})();

EmbeddedPdfHandler = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=libEmbeddedPdfHandler.js.map