"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.diffFlows = exports.diffTests = exports.convertDiffingFormatIntoDiffingSteps = exports.flattenTestFlowsIntoLineDiffingFormat = exports.constructTestFlowsFromSteps = exports.flattenTestFlowsIntoSteps = exports.convertStepListToFlow = exports.convertFlowToStepList = exports.lineModeDiff = exports.DiffOperation = void 0;
const mablApi_1 = require("../../mablApi");
const importer_1 = require("../importer");
const EvaluateFlowStep_1 = require("../steps/EvaluateFlowStep");
const diffPatchMatch_1 = __importDefault(require("./diffPatchMatch"));
const fast_json_stable_stringify_1 = __importDefault(require("fast-json-stable-stringify"));
var DiffOperation;
(function (DiffOperation) {
    DiffOperation["DELETE"] = "DELETE";
    DiffOperation["EQUAL"] = "EQUAL";
    DiffOperation["INSERT"] = "INSERT";
})(DiffOperation || (exports.DiffOperation = DiffOperation = {}));
function lineModeDiff(text1, text2) {
    const dmp = new diffPatchMatch_1.default();
    const lineToCharDiff = dmp.diff_linesToChars(text1, text2);
    const lineText1 = lineToCharDiff.chars1;
    const lineText2 = lineToCharDiff.chars2;
    const lineArray = lineToCharDiff.lineArray;
    const diffs = dmp.diff_main(lineText1, lineText2, false);
    dmp.diff_charsToLines(diffs, lineArray);
    const typedDiff = diffs.map((diff) => ({
        operation: convertOperationValue(diff[0]),
        text: diff[1],
    }));
    return typedDiff;
}
exports.lineModeDiff = lineModeDiff;
function convertOperationValue(op) {
    switch (op) {
        case -1:
            return DiffOperation.DELETE;
        case 0:
            return DiffOperation.EQUAL;
        case 1:
            return DiffOperation.INSERT;
        default:
            return DiffOperation.EQUAL;
    }
}
function parseFlowIntoStepList(flow) {
    if (flow.flow_type === mablApi_1.FlowTypeEnum.Mobile) {
        return (0, importer_1.interpretStepsFromObjectsInFlow)(flow, true);
    }
    return (0, importer_1.parseMablScriptIntoSteps)(flow);
}
function convertFlowToStepList(flow, flowConfig) {
    if (!flow.reusable &&
        (flow.flow_type === mablApi_1.FlowTypeEnum.Mablscript ||
            flow.flow_type === mablApi_1.FlowTypeEnum.Mobile)) {
        return parseFlowIntoStepList(flow);
    }
    const evaluateFlowStep = new EvaluateFlowStep_1.EvaluateFlowStep(EvaluateFlowStep_1.EvaluateFlowStep.mablScriptStepNames[0], [{ invariant_id: flow === null || flow === void 0 ? void 0 : flow.invariant_id }, flowConfig], []);
    if (flow.description) {
        evaluateFlowStep.setDescription(flow.description);
    }
    return [evaluateFlowStep];
}
exports.convertFlowToStepList = convertFlowToStepList;
function convertStepListToFlow(steps, flowType = mablApi_1.FlowTypeEnum.Mablscript) {
    if (steps.length > 1 && steps.some((step) => (0, EvaluateFlowStep_1.isEvaluateFlowStep)(step))) {
        throw new Error('EvaluateFlow step(s) cannot be combined with other steps in a flow');
    }
    if ((0, EvaluateFlowStep_1.isEvaluateFlowStep)(steps[0])) {
        const evaluateFlowStep = steps[0];
        const { flowDescriptor, config: flowConfig } = evaluateFlowStep;
        const description = evaluateFlowStep.getDescription();
        const flow = { ...flowDescriptor };
        if (description) {
            flow.description = description;
        }
        return { flow, flowConfig };
    }
    const stepAnnotations = steps.reduce((annotations, step, index) => {
        const annotation = step.getAnnotation();
        if (annotation) {
            const key = Number(index).toString();
            annotations[key] = annotation;
        }
        return annotations;
    }, {});
    const flow = {
        json_steps: flowType === mablApi_1.FlowTypeEnum.Mobile
            ? { steps: steps.map((step) => step.getFormattedStep(true)) }
            : undefined,
        script: flowType === mablApi_1.FlowTypeEnum.Mablscript
            ? addTrailingNewline((0, importer_1.mablscriptTheLoadedSteps)(steps))
            : undefined,
        script_description: steps.map(getStepDescription).join('\n'),
        step_annotations: stepAnnotations,
    };
    return { flow };
}
exports.convertStepListToFlow = convertStepListToFlow;
function getStepDescription(step) {
    var _a;
    if (step.getStepVersion() === 2) {
        return step.stepDescription();
    }
    return (_a = step.getDescription()) !== null && _a !== void 0 ? _a : '';
}
function flattenTestFlowsIntoSteps(flows, flowConfigs) {
    return flows.flatMap((flow, index) => convertFlowToStepList(flow, flowConfigs === null || flowConfigs === void 0 ? void 0 : flowConfigs[index]));
}
exports.flattenTestFlowsIntoSteps = flattenTestFlowsIntoSteps;
function constructTestFlowsFromSteps(steps, flowType = mablApi_1.FlowTypeEnum.Mablscript) {
    const flowSteps = [];
    let chunk = [];
    for (const step of steps) {
        if ((0, EvaluateFlowStep_1.isEvaluateFlowStep)(step)) {
            if (chunk.length > 0) {
                flowSteps.push(chunk);
                flowSteps.push([step]);
                chunk = [];
            }
            else {
                flowSteps.push([step]);
            }
        }
        else {
            chunk.push(step);
        }
    }
    if (chunk.length > 0) {
        flowSteps.push(chunk);
    }
    const output = {
        flows: [],
        flowConfigs: {},
    };
    flowSteps.reduce((output, chunk, index) => {
        const { flow, flowConfig } = convertStepListToFlow(chunk, flowType);
        output.flows.push(flow);
        if (flowConfig) {
            const key = Number(index).toString();
            output.flowConfigs[key] = flowConfig;
        }
        return output;
    }, output);
    return output;
}
exports.constructTestFlowsFromSteps = constructTestFlowsFromSteps;
function flattenTestFlowsIntoLineDiffingFormat(flows, flowConfig) {
    const flattenedSteps = flattenTestFlowsIntoSteps(flows, flowConfig);
    const diffingFormat = addTrailingNewline(flattenedSteps.map((step) => step.toLineDiffFormat()).join('\n'));
    return { flattenedSteps, diffingFormat };
}
exports.flattenTestFlowsIntoLineDiffingFormat = flattenTestFlowsIntoLineDiffingFormat;
function convertDiffingFormatIntoDiffingSteps(diffs, sourceSteps, targetSteps) {
    const leftSteps = [...sourceSteps];
    const rightSteps = [...targetSteps];
    leftSteps.forEach((step) => {
        step.setStepSourceIndexInFlow(0);
    });
    rightSteps.forEach((step) => {
        step.setStepSourceIndexInFlow(0);
    });
    const stepDiffs = diffs.map((diff) => {
        const lineDiffs = diff.text.trim().split('\n');
        const stepDiffCount = lineDiffs.length;
        let steps = [];
        switch (diff.operation) {
            case DiffOperation.EQUAL:
                steps = leftSteps.splice(0, stepDiffCount);
                rightSteps.splice(0, stepDiffCount);
                break;
            case DiffOperation.INSERT:
                steps = rightSteps.splice(0, stepDiffCount);
                break;
            case DiffOperation.DELETE:
                steps = leftSteps.splice(0, stepDiffCount);
                break;
        }
        return {
            operation: diff.operation,
            steps,
        };
    });
    return stepDiffs;
}
exports.convertDiffingFormatIntoDiffingSteps = convertDiffingFormatIntoDiffingSteps;
function diffTests(test1Flows, test1FlowConfig, test2Flows, test2FlowConfig) {
    const { flattenedSteps: flattenedTest1Steps, diffingFormat: test1DiffingFormat, } = flattenTestFlowsIntoLineDiffingFormat(test1Flows, test1FlowConfig);
    const { flattenedSteps: flattenedTest2Steps, diffingFormat: test2DiffingFormat, } = flattenTestFlowsIntoLineDiffingFormat(test2Flows, test2FlowConfig);
    const diffs = lineModeDiff(test1DiffingFormat, test2DiffingFormat);
    return convertDiffingFormatIntoDiffingSteps(diffs, flattenedTest1Steps, flattenedTest2Steps);
}
exports.diffTests = diffTests;
function diffFlows(flow1, flow2) {
    var _a, _b;
    const flow1Steps = parseFlowIntoStepList(flow1);
    const formattedFlow1Steps = addTrailingNewline(flow1Steps.map((step) => step.toLineDiffFormat()).join('\n'));
    const flow2Steps = parseFlowIntoStepList(flow2);
    const formattedFlow2Steps = addTrailingNewline(flow2Steps.map((step) => step.toLineDiffFormat()).join('\n'));
    const flattenedDiffs = lineModeDiff(formattedFlow1Steps, formattedFlow2Steps);
    const stepDiffs = convertDiffingFormatIntoDiffingSteps(flattenedDiffs, flow1Steps, flow2Steps);
    const parametersDiff = diffFlowVariables(flow1.parameters, flow2.parameters);
    const inputVariablesDiff = diffFlowVariables((_a = flow1.variables) === null || _a === void 0 ? void 0 : _a.inputs, (_b = flow2.variables) === null || _b === void 0 ? void 0 : _b.inputs);
    return { stepDiff: stepDiffs, parametersDiff, inputVariablesDiff };
}
exports.diffFlows = diffFlows;
function diffFlowVariables(flow1Variables, flow2Variables) {
    const flow1VariablesFlattened = flattenFlowVariables(flow1Variables);
    const flow2VariablesFlattened = flattenFlowVariables(flow2Variables);
    const diffs = lineModeDiff(flow1VariablesFlattened, flow2VariablesFlattened);
    const flowVariablesDiff = diffs.map((diff) => {
        const variablesStringified = diff.text.trim().split('\n');
        const reassembledVariables = variablesStringified.map((variablesText) => JSON.parse(variablesText));
        return {
            operation: diff.operation,
            variables: reassembledVariables,
        };
    });
    return flowVariablesDiff;
}
function flattenFlowVariables(flowVariables) {
    var _a;
    return ((_a = flowVariables === null || flowVariables === void 0 ? void 0 : flowVariables.sort((a, b) => a.name.localeCompare(b.name)).map((parameter) => (0, fast_json_stable_stringify_1.default)(parameter)).join('\n')) !== null && _a !== void 0 ? _a : '');
}
function addTrailingNewline(text) {
    if (!text) {
        return text;
    }
    return text + '\n';
}
