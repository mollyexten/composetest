"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScmContextProvider = void 0;
const scmContextInterfaces_1 = require("./scmContextInterfaces");
const loggingProvider_1 = require("./logging/loggingProvider");
const getRepoInfo = require('git-repo-info');
const { exec } = require('child_process');
function processBuildEnv(envVariables, mapper) {
    const results = {};
    envVariables.forEach((value, key) => {
        mapper(key, value, results);
    });
    if (results.isCorrectType) {
        return results;
    }
    return;
}
class ScmContextProvider {
    constructor(processRef) {
        this.envVariables = this.extractEnvVariables(processRef);
    }
    async extractScmAndBuildInfo() {
        try {
            return this.innerExtractScmAndBuildInfo();
        }
        catch (error) {
            loggingProvider_1.logger.error('Error collecting build information. Using defaults.');
            return;
        }
    }
    async innerExtractScmAndBuildInfo() {
        const maybeBuildInfo = this.attemptExtractBuildInfo();
        let scmIfo = await this.attemptGitChildProcessCall();
        if (!scmIfo) {
            scmIfo = this.attemptGitSoftInterrogation();
        }
        return {
            buildInfo: maybeBuildInfo,
            scmInfo: scmIfo,
        };
    }
    attemptExtractBuildInfo() {
        const processors = [
            () => this.getForCircleCi(),
            () => this.getForCloudBuild(),
            () => this.getForCodeship(),
            () => this.getForJenkins(),
            () => this.getForTravis(),
        ];
        let buildResultHolder;
        processors.some((processor) => {
            buildResultHolder = processor();
            return buildResultHolder;
        });
        return buildResultHolder;
    }
    extractEnvVariables(processRef) {
        const result = new Map();
        Object.entries(processRef).forEach(([key, value]) => {
            if (value && value !== '') {
                result.set(key, value);
            }
        });
        return result;
    }
    getForCloudBuild() {
        function mapper(key, value, results) {
            switch (key) {
                case '_HEAD_BRANCH':
                    results.pullRequestHeadBranch = value;
                    break;
                case '_BASE_BRANCH':
                    results.pullRequestBaseBranch = value;
                    break;
                case '_HEAD_REPO_URL':
                    results.pullRequestHeadRepo = value;
                    break;
                case '_PR_NUMBER':
                    results.pullRequestId = value;
                    break;
                case 'PROJECT_ID':
                    results.projectId = value;
                    break;
                case 'BUILD_ID':
                    results.buildId = value;
                    break;
                case 'COMMIT_SHA':
                    results.commitSha = value;
                    break;
                case 'SHORT_SHA':
                    results.shortSha = value;
                    results.isCorrectType = true;
                    results.buildType = scmContextInterfaces_1.BuildTypes.CloudBuild;
                    break;
                case 'REPO_NAME':
                    results.repoName = value;
                    break;
                case 'BRANCH_NAME':
                    results.branchName = value;
                    break;
                case 'TAG_NAME':
                    results.tagName = value;
                    break;
                case 'REVISION_ID':
                    results.revisionId = value;
                    break;
                default:
            }
        }
        return processBuildEnv(this.envVariables, mapper);
    }
    getForCircleCi() {
        function mapper(key, value, results) {
            switch (key) {
                case 'CIRCLE_PR_NUMBER':
                    results.pullRequestId = value;
                    break;
                case 'CIRCLE_PR_USERNAME':
                    results.pullRequestUsername = value;
                    break;
                case 'CIRCLE_WORKFLOW_ID':
                    results.workflowId = value;
                    break;
                case 'CIRCLECI':
                    results.isCorrectType = value === 'true';
                    results.buildType = scmContextInterfaces_1.BuildTypes.CircleCi;
                    break;
                case 'CIRCLE_SHA1':
                    results.commitSha = value;
                    results.revisionId = value;
                    break;
                case 'CIRCLE_USERNAME':
                    results.commitSha = value;
                    break;
                case 'CIRCLE_TAG':
                    results.tagName = value;
                    break;
                case 'CIRCLE_PR_REPONAME':
                    results.pullRequestRepo = value;
                    break;
                case 'CIRCLE_PROJECT_REPONAME':
                    results.repoName = value;
                    break;
                case 'CIRCLE_PROJECT_USERNAME':
                    results.projectUsername = value;
                    break;
                case 'CIRCLE_REPOSITORY_URL':
                    results.repoUrl = value;
                    break;
                case 'CIRCLE_BRANCH':
                    results.branchName = value;
                    break;
                case 'CIRCLE_BUILD_NUM':
                    results.buildId = value;
                    break;
                case 'CIRCLE_BUILD_URL':
                    results.buildUrl = value;
                    break;
                case 'CIRCLE_JOB':
                    results.jobName = value;
                    break;
                default:
            }
        }
        return processBuildEnv(this.envVariables, mapper);
    }
    getForTravis() {
        function mapper(key, value, results) {
            switch (key) {
                case 'TRAVIS_PULL_REQUEST':
                    if (value !== 'false') {
                        results.pullRequestId = value;
                    }
                    break;
                case 'TRAVIS_PULL_REQUEST_BRANCH':
                    results.pullRequestBranch = value;
                    break;
                case 'TRAVIS_REPO_SLUG':
                    const parts = value.split('/');
                    if (parts.length === 2) {
                        results.repoOwner = parts[0];
                        results.repoName = parts[1];
                    }
                    break;
                case 'TRAVIS':
                    results.isCorrectType = value === 'true';
                    results.buildType = scmContextInterfaces_1.BuildTypes.Travis;
                    break;
                case 'TRAVIS_COMMIT':
                    results.commitSha = value;
                    results.revisionId = value;
                    break;
                case 'TRAVIS_TAG':
                    results.tagName = value;
                    break;
                case 'TRAVIS_BRANCH':
                    results.branchName = value;
                    break;
                case 'TRAVIS_BUILD_NUMBER':
                    results.buildId = value;
                    break;
                case 'TRAVIS_BUILD_WEB_URL':
                    results.buildUrl = value;
                    break;
                case 'TRAVIS_JOB_NAME':
                    results.jobName = value;
                    break;
                default:
            }
        }
        return processBuildEnv(this.envVariables, mapper);
    }
    getForCodeship() {
        function mapper(key, value, results) {
            switch (key) {
                case 'CI_PR_NUMBER':
                    results.pullRequestId = value;
                    break;
                case 'CI_PULL_REQUEST':
                    results.pullRequestUrl = value;
                    break;
                case 'CI_REPO_NAME':
                    results.repoName = value;
                    break;
                case 'CI_NAME':
                    results.isCorrectType = value === 'codeship';
                    results.buildType = scmContextInterfaces_1.BuildTypes.Codeship;
                    break;
                case 'CI_COMMIT_ID':
                    results.commitSha = value;
                    results.revisionId = value;
                    break;
                case 'CI_BRANCH':
                    results.branchName = value;
                    break;
                case 'CI_BUILD_ID':
                    results.buildId = value;
                    break;
                default:
            }
        }
        return processBuildEnv(this.envVariables, mapper);
    }
    getForJenkins() {
        function mapper(key, value, results) {
            switch (key) {
                case 'GIT_URL':
                    results.repoUrl = value;
                    break;
                case 'GIT_COMMIT':
                    results.commitSha = value;
                    results.revisionId = value;
                    break;
                case 'SVN_REVISION':
                    results.revisionId = value;
                    break;
                case 'GIT_BRANCH':
                case 'CVS_BRANCH':
                    results.branchName = value;
                    break;
                case 'BUILD_URL':
                    results.buildUrl = value;
                    break;
                case 'JOB_NAME':
                    results.jobName = value;
                    break;
                case 'BUILD_TAG':
                    results.isCorrectType = value.startsWith('jenkins');
                    results.jobTag = value;
                    results.buildType = scmContextInterfaces_1.BuildTypes.Jenkins;
                    break;
                case 'BUILD_NUMBER':
                    results.buildId = value;
                    break;
                default:
            }
        }
        return processBuildEnv(this.envVariables, mapper);
    }
    attemptGitSoftInterrogation() {
        const gitInfo = getRepoInfo();
        if (gitInfo) {
            return {
                commitSha: gitInfo.sha,
                revisionId: gitInfo.sha,
                branchName: gitInfo.branch,
                tagName: gitInfo.tag,
            };
        }
        return;
    }
    async attemptGitChildProcessCall() {
        const repoUrlMatcher = /^origin\s+(\S+)\s+\(fetch\)/;
        const repoBranchMatcher = /^(\S{1,256})/;
        const repoShaMatch = /^([a-f0-9]{40})+/;
        const showRepoRemoteCommand = 'git remote -v';
        const showRepoBranchCommand = 'git rev-parse --abbrev-ref HEAD';
        const showRepoShaCommand = 'git rev-parse HEAD';
        const maybeRepoUrl = await this.executeGetRepoUrl(showRepoRemoteCommand, repoUrlMatcher);
        if (!maybeRepoUrl) {
            return;
        }
        const maybeRepoBranch = await this.executeGetRepoUrl(showRepoBranchCommand, repoBranchMatcher);
        if (!maybeRepoBranch) {
            return;
        }
        const maybeRepoSha = await this.executeGetRepoUrl(showRepoShaCommand, repoShaMatch);
        if (!maybeRepoSha) {
            return;
        }
        return {
            branchName: maybeRepoBranch,
            repoUrl: maybeRepoUrl,
            revisionId: maybeRepoSha,
            commitSha: maybeRepoSha,
        };
    }
    executeGetRepoUrl(command, matcher) {
        return new Promise((resolve, reject) => {
            exec(command, (error, stdout) => {
                if (error) {
                    return reject(error);
                }
                if (matcher.test(stdout)) {
                    const matchParts = stdout.match(matcher);
                    if (matchParts && matchParts.length >= 1) {
                        return resolve(matchParts[1]);
                    }
                }
                resolve(undefined);
            });
        });
    }
}
exports.ScmContextProvider = ScmContextProvider;
