"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MablApiClient = void 0;
const ApiError_1 = require("./ApiError");
const env_1 = require("../env/env");
const mablApi_1 = require("../mablApi");
const cliConfigProvider_1 = require("../providers/cliConfigProvider");
const basicApiClient_1 = require("./basicApiClient");
const query_string_1 = __importDefault(require("query-string"));
const featureSet_1 = require("./featureSet");
const GENAI_RETRY_OPTIONS = {
    retryCount: 10,
    minRetryIntervalMillis: 10000,
    maxRetryIntervalMillis: 60000,
    maxRetryTimeMillis: 180000,
};
class MablApiClient extends basicApiClient_1.BasicApiClient {
    constructor(options) {
        var _a, _b;
        super(options);
        this.baseApiUrl =
            (_b = (_a = options.apiUrl) !== null && _a !== void 0 ? _a : process.env.MABL_API_URL) !== null && _b !== void 0 ? _b : env_1.BASE_API_URL;
    }
    async getPlan(planId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/schedule/runPolicy/${planId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get plan (${planId})`, error);
        }
    }
    async getPlans(options) {
        var _a, _b;
        try {
            const queryArg = query_string_1.default.stringify(options);
            const plans = await this.makeGetRequest(`${this.baseApiUrl}/schedule/runPolicy/?${queryArg}`);
            sortTemporallyAscending((_a = plans.run_policies) !== null && _a !== void 0 ? _a : []);
            return (_b = plans.run_policies) !== null && _b !== void 0 ? _b : [];
        }
        catch (error) {
            throw toApiError(`Failed to get plans (workspace: ${options.organization_id})`, error);
        }
    }
    async getApplication(applicationId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/v1/applications/${applicationId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get application (${applicationId})`, error);
        }
    }
    async getApplications(workspaceId, limit) {
        try {
            const applicationQueryString = query_string_1.default.stringify({
                organization_id: workspaceId,
                limit,
            });
            const applications = await this.makeGetRequest(`${this.baseApiUrl}/applications?${applicationQueryString}`).then((result) => { var _a; return (_a = result.applications) !== null && _a !== void 0 ? _a : []; });
            sortTemporallyAscending(applications);
            return applications;
        }
        catch (error) {
            throw toApiError(`Failed to get applications`, error);
        }
    }
    async getEnvironment(environmentId, decryptVariables) {
        try {
            const queryStringArgs = {
                decrypt: decryptVariables,
            };
            const envQueryString = query_string_1.default.stringify(queryStringArgs);
            return await this.makeGetRequest(`${this.baseApiUrl}/v1/environments/${environmentId}?${envQueryString}`);
        }
        catch (error) {
            throw toApiError(`Failed to get environment (${environmentId})`, error);
        }
    }
    async deleteEnvironment(id) {
        try {
            return await this.makeDeleteRequest(`${this.baseApiUrl}/environments/${id}`);
        }
        catch (error) {
            throw toApiError(`Failed to delete environment`, error);
        }
    }
    async createEnvironment(environment) {
        try {
            return await this.makePostRequest(`${this.baseApiUrl}/environments`, environment);
        }
        catch (error) {
            throw toApiError(`Failed to create environment`, error);
        }
    }
    async updateEnvironment(id, environment) {
        try {
            return await this.makePatchRequest(`${this.baseApiUrl}/environments/${id}`, environment);
        }
        catch (error) {
            throw toApiError(`Failed to update environment`, error);
        }
    }
    async getEnvironments(workspaceId, limit) {
        try {
            const environmentQueryString = query_string_1.default.stringify({
                organization_id: workspaceId,
                limit,
            });
            const environments = await this.makeGetRequest(`${this.baseApiUrl}/v1/environments/?${environmentQueryString}`).then((result) => { var _a; return (_a = result.environments) !== null && _a !== void 0 ? _a : []; });
            sortTemporallyAscending(environments);
            return environments;
        }
        catch (error) {
            throw toApiError(`Failed to get environments`, error);
        }
    }
    async createDeployment(deployment) {
        try {
            return await this.makePostRequest(`${this.baseApiUrl}/deployments`, deployment);
        }
        catch (error) {
            throw toApiError(`Failed to create deployment`, error);
        }
    }
    async updateDeployment(id, deployment) {
        try {
            return await this.makePatchRequest(`${this.baseApiUrl}/deployments/${id}`, deployment);
        }
        catch (error) {
            throw toApiError(`Failed to update environment`, error);
        }
    }
    async selectLinkServers(workspaceId, labels) {
        try {
            const queryParams = query_string_1.default.stringify({
                workspace_id: workspaceId,
                labels,
            }, { arrayFormat: 'comma' });
            return (await this.makeGetRequest(`${this.baseApiUrl}/link/servers/select-multiple?${queryParams}`)).link_servers;
        }
        catch (error) {
            throw toApiError(`Failed to get selected link server`, error);
        }
    }
    async deleteLinkLabel(workspaceId, linkLabel) {
        try {
            return await this.makeDeleteRequest(`${this.baseApiUrl}/link/${workspaceId}/label/${linkLabel}`);
        }
        catch (error) {
            throw toApiError(`Failed to delete link label`, error);
        }
    }
    async getLinkAgentsWithRecentHeartbeats(workspaceId, limit, maxHeartbeatAgeSeconds) {
        var _a;
        try {
            return ((_a = (await this.makeGetRequest(`${env_1.BASE_API_URL}/link/agents?workspace_id=${workspaceId}&limit=${limit}&max_heartbeat_age_sec=${maxHeartbeatAgeSeconds}`)).link_agents) !== null && _a !== void 0 ? _a : []);
        }
        catch (error) {
            throw toApiError(`Failed to get active link agents`, error);
        }
    }
    async terminateLinkAgent(id) {
        try {
            await this.makePostRequest(`${env_1.BASE_API_URL}/link/agents/${id}/terminate`);
        }
        catch (error) {
            throw toApiError(`Failed to terminate link agent`, error);
        }
    }
    async getExportRequest(id) {
        return this.getEntity(id, 'exports', 'ExportRequest');
    }
    async getEntity(id, path, entityName = 'Entity') {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/v1/${path}/${id}`);
        }
        catch (error) {
            throw toApiError(`Failed to get ${entityName} (${id})`, error);
        }
    }
    async getCredentials(workspaceId, limit) {
        try {
            const credentialsQueryString = query_string_1.default.stringify({
                organization_id: workspaceId,
                limit,
            });
            return await this.makeGetRequest(`${this.baseApiUrl}/credentials?${credentialsQueryString}`).then((result) => { var _a; return (_a = result.credentials) !== null && _a !== void 0 ? _a : []; });
        }
        catch (error) {
            throw toApiError(`Failed to get credentials`, error);
        }
    }
    async getDatabaseConnections(workspaceId, limit) {
        try {
            const query = query_string_1.default.stringify({
                organization_id: workspaceId,
                limit,
            });
            return await this.makeGetRequest(`${this.baseApiUrl}/database/connections?${query}`).then((result) => { var _a; return (_a = result.database_connections) !== null && _a !== void 0 ? _a : []; });
        }
        catch (error) {
            throw toApiError(`Failed to get database connections`, error);
        }
    }
    async getCredential(credentialId, withSecrets, withComputedTotpCount) {
        const queryStringParams = query_string_1.default.stringify({
            with_secrets: withSecrets,
            with_computed_totp_count: withComputedTotpCount,
        });
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/credentials/${credentialId}?${queryStringParams}`);
        }
        catch (error) {
            throw toApiError(`Failed to get credential`, error);
        }
    }
    async getDeploymentEvents(workspaceId, limit) {
        try {
            const deploymentQueryString = query_string_1.default.stringify({
                workspace_id: workspaceId,
                limit,
            });
            return await this.makeGetRequest(`${this.baseApiUrl}/events/deployment?${deploymentQueryString}`).then((result) => { var _a; return (_a = result.deployments) !== null && _a !== void 0 ? _a : []; });
        }
        catch (error) {
            throw toApiError(`Failed to get deployment events`, error);
        }
    }
    async getDeploymentEvent(deploymentId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/events/deployment/${deploymentId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get deployment event`, error);
        }
    }
    async getDeploymentEntity(deploymentId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/deployments/${deploymentId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get deployment entity`, error);
        }
    }
    async queryDeploymentEntities(workspaceId, environmentId, applicationId, limit = 50) {
        try {
            const queryStringParams = query_string_1.default.stringify({
                organization_id: workspaceId,
                environment_id: environmentId,
                application_id: applicationId,
                limit,
            });
            const query = `${this.baseApiUrl}/deployments?${queryStringParams}`;
            return await this.makeGetRequest(query);
        }
        catch (error) {
            throw toApiError(`Failed to query url entities`, error);
        }
    }
    async getDeploymentResults(deploymentEventId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/execution/result/event/${deploymentEventId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get deployment results`, error);
        }
    }
    async evaluateFindAttributes(workspaceId, evaluateAttributes) {
        try {
            return await this.makePostRequest(`${this.baseApiUrl}/find/${workspaceId}/evaluate/attributes`, evaluateAttributes);
        }
        catch (error) {
            return undefined;
        }
    }
    async evaluateFindCandidatesText(workspaceId, request) {
        try {
            return await this.makePostRequest(`${this.baseApiUrl}/find/${workspaceId}/evaluate/textSimilarity`, request);
        }
        catch (error) {
            return undefined;
        }
    }
    async getTestFindSummaries(testId, environmentId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/findSummary?journey_id=${testId}&environment_id=${environmentId}`).then((result) => { var _a; return (_a = result.findsummaries) !== null && _a !== void 0 ? _a : []; });
        }
        catch (error) {
            throw toApiError(`Failed to get test find summaries results`, error);
        }
    }
    async getTestFindModels(testId, environmentId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/findModel/test/${testId}?environment_id=${environmentId}`).then((result) => { var _a; return (_a = result.findModels) !== null && _a !== void 0 ? _a : []; });
        }
        catch (error) {
            throw toApiError(`Failed to get test find model results`, error);
        }
    }
    async getTestOverrides(testId, environmentId, selectorOverrideLimit = 10) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/tests/testScripts/${testId}/overrides?environment_id=${environmentId}&selector_override_limit=${selectorOverrideLimit}`).then((result) => { var _a; return (_a = result.overrides) !== null && _a !== void 0 ? _a : []; });
        }
        catch (error) {
            throw toApiError(`Failed to get selector overrides`, error);
        }
    }
    async getTestRun(testRunId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/journeyRuns/${testRunId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get test run info`, error);
        }
    }
    async getPlanRun(planRunId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/planRuns/${planRunId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get plan run info`, error);
        }
    }
    async getWorkspaces(limit) {
        var _a, _b;
        try {
            const userInfo = await this.getSelf();
            const requests = (_b = (_a = userInfo.roles) === null || _a === void 0 ? void 0 : _a.slice(0, limit).map((role) => this.getWorkspace(role.organization_id))) !== null && _b !== void 0 ? _b : [];
            const workspaces = await Promise.all(requests);
            sortTemporallyAscending(workspaces);
            return workspaces;
        }
        catch (error) {
            throw toApiError(`Failed to get workspaces`, error);
        }
    }
    async getWorkspace(workspaceId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/organizations/${workspaceId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get workspace`, error);
        }
    }
    async getAccount(accountId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/accounts/${accountId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get account`, error);
        }
    }
    async getAccountByWorkspaceId(workspaceId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/organizations/${workspaceId}/account`);
        }
        catch (error) {
            throw toApiError(`Failed to get account from workspace id`, error);
        }
    }
    async getApiKeyDetails() {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/apiKeys/self`);
        }
        catch (error) {
            throw toApiError(`Failed to validate API Key`, error);
        }
    }
    async getSelf() {
        var _a, _b;
        try {
            const selfInfo = await this.makeGetRequest(`${this.baseApiUrl}/self`);
            if (((_a = selfInfo.preferences) === null || _a === void 0 ? void 0 : _a.default_workspace_id) &&
                !(await cliConfigProvider_1.CliConfigProvider.getWorkspace())) {
                const workspace = await this.getWorkspace(selfInfo.preferences.default_workspace_id);
                await cliConfigProvider_1.CliConfigProvider.setWorkspace(workspace);
            }
            else if (((_b = selfInfo.roles) === null || _b === void 0 ? void 0 : _b.length) === 1) {
                const workspace = await this.getWorkspace(selfInfo.roles[0].organization_id);
                await cliConfigProvider_1.CliConfigProvider.setWorkspace(workspace);
            }
            return selfInfo;
        }
        catch (error) {
            throw toApiError(`Failed to validate user`, error);
        }
    }
    async getJourney(journeyId, branchName = 'none', forExportFormat = 'none') {
        try {
            const queryStringArgs = {
                cliExport: forExportFormat,
                sourceControlTag: branchName,
            };
            const journeyQueryString = query_string_1.default.stringify(queryStringArgs);
            return await this.makeGetRequest(`${this.baseApiUrl}/test/journey/${journeyId}?${journeyQueryString}`);
        }
        catch (error) {
            throw toApiError(`Failed to get Test [${journeyId}]`, error);
        }
    }
    async getJourneys(options) {
        var _a;
        try {
            const queryArg = query_string_1.default.stringify(options);
            const journeys = (_a = (await this.makeGetRequest(`${this.baseApiUrl}/test/journeys?${queryArg}`)).journeys) !== null && _a !== void 0 ? _a : [];
            sortTemporallyAscending(journeys);
            return journeys;
        }
        catch (error) {
            throw toApiError(`Failed to get Tests`, error);
        }
    }
    async getFlow(flowId, branchName) {
        try {
            const queryStringArgs = {
                sourceControlTag: branchName,
            };
            const flowQueryString = query_string_1.default.stringify(queryStringArgs);
            return await this.makeGetRequest(`${this.baseApiUrl}/flows/${flowId}?${flowQueryString}`);
        }
        catch (error) {
            throw toApiError(`Failed to get Flow [${flowId}]`, error);
        }
    }
    async getFlows(options) {
        var _a;
        try {
            const queryArg = query_string_1.default.stringify(options);
            const flows = (_a = (await this.makeGetRequest(`${this.baseApiUrl}/flows?${queryArg}`)).flows) !== null && _a !== void 0 ? _a : [];
            sortTemporallyAscending(flows);
            return flows;
        }
        catch (error) {
            throw toApiError(`Failed to get Flows`, error);
        }
    }
    async getSnippet(snippetId, isQuery, preferLatestIfReusable, workspaceId) {
        const entity = isQuery ? 'query' : 'snippet';
        try {
            const queryParameter = typeof preferLatestIfReusable === 'boolean'
                ? `?=preferLatestIfReusable=${preferLatestIfReusable}`
                : '';
            return await this.makeGetRequest(`${this.baseApiUrl}/snippets/${snippetId}${queryParameter}`);
        }
        catch (error) {
            throw toApiError(`Failed to get ${entity} [${snippetId}]. ${workspaceId
                ? `The ${entity} was likely deleted. To recover this ${entity}, visit the activity feed [workspaces/${workspaceId}/settings/activity-log?activityLogEntity=${entity}&activityLogEvent=delete]`
                : `The ${entity} was likely deleted. To recover this ${entity}, visit the activity feed.`}`, error);
        }
    }
    async getBranchById(branchId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/branch/${branchId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get Branch [${branchId}] by id`, error);
        }
    }
    async getBranchByName(workspaceId, branchName) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/branch/${workspaceId}/${branchName}`);
        }
        catch (error) {
            throw toApiError(`Failed to get Branch [${branchName}] by name`, error);
        }
    }
    async getBranches(workspaceId, limit, statusFilter) {
        try {
            const branchQueryString = query_string_1.default.stringify({
                workspace_id: workspaceId,
                limit,
                status: statusFilter,
            });
            return await this.makeGetRequest(`${this.baseApiUrl}/branch?${branchQueryString}`).then((result) => { var _a; return (_a = result.branches) !== null && _a !== void 0 ? _a : []; });
        }
        catch (error) {
            throw toApiError(`Failed to get Branches`, error);
        }
    }
    async getFileUploadUrl(fileId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/files/fileUpload/url/${fileId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get File Upload URL`, error);
        }
    }
    async queryDataTables(workspaceId, limit, cursor) {
        try {
            const dataTablesQueryString = query_string_1.default.stringify({
                workspace_id: workspaceId,
                limit,
                cursor,
            });
            return await this.makeGetRequest(`${this.baseApiUrl}/dataTables?${dataTablesQueryString}`).then((result) => result);
        }
        catch (error) {
            throw toApiError(`Failed to retrieve DataTables`, error);
        }
    }
    async getDataTable(dataTableId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/dataTables/${dataTableId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get DataTable`, error);
        }
    }
    async createDataTable(dataTableCreateRequest) {
        try {
            return await this.makePostRequest(`${this.baseApiUrl}/dataTables`, dataTableCreateRequest);
        }
        catch (error) {
            throw toApiError(`Failed to create DataTable`, error);
        }
    }
    async queryScenarios(dataTableId, limit, cursor) {
        try {
            const scenariosQueryString = query_string_1.default.stringify({
                data_table_id: dataTableId,
                limit,
                cursor,
            });
            return await this.makeGetRequest(`${this.baseApiUrl}/dataTables/scenarios?${scenariosQueryString}`);
        }
        catch (error) {
            throw toApiError(`Failed to get Scenarios`, error);
        }
    }
    async getScenario(scenarioId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/dataTables/scenarios/${scenarioId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get Scenario`, error);
        }
    }
    async updateDataTable(tableId, updateRequest) {
        try {
            return await this.makePatchRequest(`${this.baseApiUrl}/variables/tables/${tableId}`, updateRequest);
        }
        catch (error) {
            throw toApiError(`Failed to create DataTable`, error);
        }
    }
    async getSessionEmails(sessionId) {
        try {
            const emailQueryString = query_string_1.default.stringify({
                context_id: sessionId === null || sessionId === void 0 ? void 0 : sessionId.slice(0, 8),
            });
            return await this.makeGetRequest(`${this.baseApiUrl}/execution/inputs?${emailQueryString}`);
        }
        catch (error) {
            throw toApiError(`Failed to get emails for session ID ${sessionId} with error`, error);
        }
    }
    async getEmailsToPermanentAddress(address, earliestReceivedTime, lookbackMilliseconds) {
        try {
            const emailQueryString = query_string_1.default.stringify({
                email_address: address,
                earliest_received_time: earliestReceivedTime,
                lookback_millis: lookbackMilliseconds,
            });
            return await this.makeGetRequest(`${this.baseApiUrl}/execution/inputs?${emailQueryString}`);
        }
        catch (error) {
            throw toApiError(`Failed to get emails for permanent address ${address} with error`, error);
        }
    }
    async createMailboxAddress(workspaceId, sessionId) {
        const contextId = sessionId === null || sessionId === void 0 ? void 0 : sessionId.slice(0, 8);
        try {
            const body = {
                context_id: contextId,
                workspace_id: workspaceId,
            };
            return await this.makePostRequestWithRetries(`${this.baseApiUrl}/mailbox/address`, body);
        }
        catch (error) {
            throw toApiError('Failed to create mailbox email address', error);
        }
    }
    async getMailboxAddress(emailAddressOrId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/mailbox/address/${emailAddressOrId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get mailbox ${emailAddressOrId} with error`, error);
        }
    }
    async updateMailboxStatus(mailboxId, status) {
        try {
            const body = { status };
            return await this.makePatchRequest(`${this.baseApiUrl}/mailbox/address/${mailboxId}/status`, body);
        }
        catch (error) {
            throw toApiError(`Failed to update mailbox ${mailboxId} with error`, error);
        }
    }
    async generateSteps(workspaceId, intent, context) {
        const body = {
            intent,
            context,
        };
        try {
            return await this.makePostRequestWithRetries(`${this.baseApiUrl}/generate/steps?workspaceId=${workspaceId}`, body, GENAI_RETRY_OPTIONS);
        }
        catch (error) {
            throw toApiError('Failed to generate steps', error);
        }
    }
    async evaluateAiAssertion(workspaceId, testRunId, screenshot, userPrompt, metaPrompt, criteria, test, variables) {
        const requestUrl = `${this.baseApiUrl}/analysis/${workspaceId}/assertion/evaluate`;
        return this.evaluateAiAssertionInternal(requestUrl, testRunId, screenshot, userPrompt, metaPrompt, criteria, test, variables);
    }
    async externalToolsAiAssertion(workspaceId, testRunId, screenshot, userPrompt, criteria, test, variables) {
        const requestUrl = `${this.baseApiUrl}/externalTools/${workspaceId}/assertion/evaluate`;
        return this.evaluateAiAssertionInternal(requestUrl, testRunId, screenshot, userPrompt, undefined, criteria, test, variables);
    }
    async evaluateAiAssertionInternal(requestUrl, testRunId, screenshot, userPrompt, metaPrompt, criteria, test, variables) {
        try {
            const body = {
                test_run_id: testRunId,
                assertion_prompt: userPrompt,
                assertion_criteria: criteria,
                screenshot: Buffer.from(screenshot).toString('base64'),
                test_invariant_id: test === null || test === void 0 ? void 0 : test.invariant_id,
                test_type: test === null || test === void 0 ? void 0 : test.test_type,
                variables,
            };
            if (metaPrompt !== undefined) {
                body.override = {
                    meta_prompt: metaPrompt,
                };
            }
            return await this.makePostRequestWithRetries(requestUrl, body, GENAI_RETRY_OPTIONS);
        }
        catch (error) {
            throw toApiError('Failed to evaluate the AI assertion', error);
        }
    }
    async createBranch(workspaceId, branchName) {
        try {
            const body = {
                workspace_id: workspaceId,
                name: branchName,
            };
            return await this.makePostRequest(`${this.baseApiUrl}/branch`, body);
        }
        catch (error) {
            throw toApiError(`Failed to create Branch [${branchName}]`, error);
        }
    }
    async mergeBranch(workspaceId, fromBranchName, toBranchName) {
        try {
            const queryStringArgs = {
                from: fromBranchName,
                to: toBranchName,
            };
            const mergeQueryString = query_string_1.default.stringify(queryStringArgs);
            const url = `${this.baseApiUrl}/branch/${workspaceId}/merge?${mergeQueryString}`;
            return await this.makePostRequest(url, {});
        }
        catch (error) {
            throw toApiError(`Failed to merge from branch [${fromBranchName}] to branch [${toBranchName}]`, error);
        }
    }
    async createExportRequest(journeyRunId, targetContent) {
        try {
            const body = {
                target_content: targetContent,
                target_entity_id: journeyRunId,
            };
            return await this.makePostRequest(`${this.baseApiUrl}/exports/journeyRuns/${journeyRunId}`, body);
        }
        catch (error) {
            throw toApiError(`Failed to create export`, error);
        }
    }
    async postDeploymentEvent(options) {
        try {
            const requestBody = this.buildDeploymentRequestBody(options);
            return await this.makePostRequestWithRetries(`${this.baseApiUrl}/events/deployment/`, requestBody);
        }
        catch (error) {
            throw toApiError(`Failed to create deployment`, error);
        }
    }
    buildDeploymentRequestBody(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const requestBody = { properties: {} };
        if (options.environmentId) {
            requestBody.environment_id = options.environmentId;
        }
        if (options.applicationId) {
            requestBody.application_id = options.applicationId;
        }
        requestBody.revision = (_a = options.sourceControlMetadata) === null || _a === void 0 ? void 0 : _a.revision;
        if (options.mablBranch) {
            requestBody.source_control_tag = options.mablBranch;
        }
        requestBody.properties.repository_branch_name =
            (_b = options.sourceControlMetadata) === null || _b === void 0 ? void 0 : _b.branchName;
        requestBody.properties.repository_tag_name =
            (_c = options.sourceControlMetadata) === null || _c === void 0 ? void 0 : _c.branchName;
        requestBody.properties.repository_url =
            (_d = options.sourceControlMetadata) === null || _d === void 0 ? void 0 : _d.repoUrl;
        requestBody.properties.repository_name =
            (_e = options.sourceControlMetadata) === null || _e === void 0 ? void 0 : _e.repoName;
        requestBody.properties.build_info_url =
            (_f = options.sourceControlMetadata) === null || _f === void 0 ? void 0 : _f.buildInfoUrl;
        requestBody.properties.deployment_origin = ((_g = options.sourceControlMetadata) === null || _g === void 0 ? void 0 : _g.integrationType)
            ?
                `mabl-${options.sourceControlMetadata.integrationType}`
            : undefined;
        requestBody.properties.build_id = (_h = options.sourceControlMetadata) === null || _h === void 0 ? void 0 : _h.buildId;
        const planOverrides = {};
        if ((_j = options.browserTypes) === null || _j === void 0 ? void 0 : _j.length) {
            planOverrides.browser_types = options.browserTypes;
        }
        if ((_k = options.labels) === null || _k === void 0 ? void 0 : _k.length) {
            requestBody.plan_labels = options.labels;
        }
        if (options.uri) {
            planOverrides.uri = options.uri;
        }
        if (options.appUrl) {
            planOverrides.web_url = options.appUrl;
        }
        if (options.apiUrl) {
            planOverrides.api_url = options.apiUrl;
        }
        if (options.deploymentIds) {
            planOverrides.deployment_ids = options.deploymentIds;
        }
        if (options.androidMobileAppFileId) {
            planOverrides.mobile_app_file_ids = {
                ...planOverrides.mobile_app_file_ids,
                [mablApi_1.MobilePlatformEnum.Android]: options.androidMobileAppFileId,
            };
        }
        if (options.iOSMobileAppFileId) {
            planOverrides.mobile_app_file_ids = {
                ...planOverrides.mobile_app_file_ids,
                [mablApi_1.MobilePlatformEnum.Ios]: options.iOSMobileAppFileId,
            };
        }
        if ((_l = options.httpHeaders) === null || _l === void 0 ? void 0 : _l.length) {
            planOverrides.http_headers = options.httpHeaders.map((header) => {
                const parts = header.split(':', 2);
                return {
                    name: parts[0],
                    value: parts[1],
                    log_header_value: false,
                };
            });
            planOverrides.http_headers_required = true;
        }
        requestBody.plan_overrides = planOverrides;
        const actions = {};
        if (options.rebaselineImages) {
            actions.rebaseline_images = options.rebaselineImages;
        }
        if (options.setStaticBaseline) {
            actions.set_static_baseline = options.setStaticBaseline;
        }
        if (options.snapshotFromBranch) {
            actions.snapshot = { from: options.snapshotFromBranch };
        }
        if (options.targetRuntimeVersion) {
            requestBody.target_runtime_version = options.targetRuntimeVersion;
        }
        requestBody.actions = actions;
        return requestBody;
    }
    async getTestRunsForPlan(planRunId) {
        try {
            return this.makeGetRequest(`${this.baseApiUrl}/journeyRuns/planRun/${planRunId}`);
        }
        catch (error) {
            throw toApiError(`Failed to retrieve tests for plan`, error);
        }
    }
    async postPlanRun(organizationId, testId, branchName, browserTypes, appUrl, apiUrl, deploymentId, credentialsId, deploymentIds, basicAuthCredentialsId, localizationOptions) {
        try {
            const requestBody = this.buildAdHocPlanRunRequestBody(organizationId, testId, browserTypes, branchName, appUrl, apiUrl, deploymentId, credentialsId, deploymentIds, basicAuthCredentialsId, localizationOptions);
            return await this.makePostRequest(`${this.baseApiUrl}/planRuns/`, requestBody);
        }
        catch (error) {
            throw toApiError(`Failed to create planRun`, error);
        }
    }
    buildAdHocPlanRunRequestBody(organizationId, testId, browserTypes, branchName, appUrl, apiUrl, deploymentId, credentialsId, deploymentIds, basicAuthCredentialsId, localizationOptions) {
        const requestBody = {
            ad_hoc_run_info: {
                is_ad_hoc_run: true,
            },
        };
        const planOverrides = {};
        if (organizationId) {
            planOverrides.organization_id = organizationId;
        }
        if (deploymentId) {
            planOverrides.deployment_id = deploymentId;
        }
        if (browserTypes === null || browserTypes === void 0 ? void 0 : browserTypes.length) {
            planOverrides.browser_types = browserTypes;
        }
        if (appUrl) {
            planOverrides.web_url = appUrl;
        }
        if (apiUrl) {
            planOverrides.api_url = apiUrl;
        }
        if (credentialsId) {
            planOverrides.credentials_id = credentialsId;
            planOverrides.credentials_required = true;
        }
        if (basicAuthCredentialsId) {
            planOverrides.http_auth_credentials_id = basicAuthCredentialsId;
            planOverrides.http_auth_credentials_required = true;
        }
        if (localizationOptions) {
            planOverrides.localization_options = [localizationOptions];
        }
        if (testId) {
            planOverrides.journeys = [{ journey_id: testId }];
            planOverrides.execution_stages = [
                {
                    concurrency: mablApi_1.ExecutionStage.ConcurrencyEnum.Parallel,
                    journeys: [
                        {
                            journey_id: testId,
                        },
                    ],
                },
            ];
        }
        if (deploymentIds) {
            planOverrides.deployment_ids = deploymentIds;
        }
        requestBody.plan_overrides = planOverrides;
        if (branchName) {
            requestBody.source_control_tag_override = branchName;
        }
        return requestBody;
    }
    async createFlow(prototype) {
        try {
            return await this.makePostRequest(`${this.baseApiUrl}/flows`, prototype);
        }
        catch (error) {
            throw toApiError(`Failed to create flow`, error);
        }
    }
    async createJourney(prototype) {
        try {
            return await this.makePostRequest(`${this.baseApiUrl}/test/journeys`, prototype);
        }
        catch (error) {
            throw toApiError(`Failed to create journey`, error);
        }
    }
    async getJourneyRun(journeyRunId) {
        try {
            return await this.makeGetRequestWithETag(`${this.baseApiUrl}/journeyRuns/${journeyRunId}`);
        }
        catch (error) {
            throw toApiError(`Failed to get journey run info`, error);
        }
    }
    async updateJourneyRun(journeyRunId, journeyRunUpdate, ifMatch, retry) {
        try {
            const response = retry
                ? await this.makePatchRequestWithRetries(`${this.baseApiUrl}/journeyRuns/${journeyRunId}`, journeyRunUpdate, ifMatch)
                : await this.makePatchRequest(`${this.baseApiUrl}/journeyRuns/${journeyRunId}`, journeyRunUpdate, ifMatch);
            return response;
        }
        catch (error) {
            throw toApiError(`Failed to update journey run ${journeyRunId}`, error);
        }
    }
    async failJourneyRun(journeyRunId, cause) {
        try {
            const response = await this.makePatchRequest(`${this.baseApiUrl}/journeyRuns/${journeyRunId}`, {
                functionally_completed: false,
                status: mablApi_1.TestRun.StatusEnum.Failed,
                status_cause: cause,
            });
            return response;
        }
        catch (error) {
            throw toApiError(`Failed to update journey run ${journeyRunId}`, error);
        }
    }
    async terminateJourneyRun(journeyRunId, terminationReason) {
        const terminateParams = query_string_1.default.stringify({
            terminationReason: terminationReason.toString(),
        });
        try {
            const response = await this.makePostRequestWithRetries(`${this.baseApiUrl}/journeyRun/${journeyRunId}/terminate?${terminateParams}`);
            return response;
        }
        catch (error) {
            throw toApiError(`Failed to terminate journey run ${journeyRunId}`, error);
        }
    }
    async copyWorkspace(sourceWorkspaceId, destinationWorkspaceId, includeDefaults, includedTests, excludedTests) {
        const requestBody = {
            source_workspace_id: sourceWorkspaceId,
            destination_workspace_id: destinationWorkspaceId,
            include_defaults: includeDefaults,
            included_tests: includedTests,
            excluded_tests: excludedTests,
        };
        return this.makePostRequest(`${this.baseApiUrl}/copy/workspaces`, requestBody, {
            timeout: 3600000,
        });
    }
    async getEnabledAccountFeaturesByWorkspaceId(workspaceId) {
        var _a;
        try {
            const account = await this.getAccountByWorkspaceId(workspaceId);
            return new featureSet_1.FeatureSet(new Set((_a = account.effective_features) !== null && _a !== void 0 ? _a : []));
        }
        catch (error) {
            throw toApiError(`Failed to get effective account features for workspace ${workspaceId}`, error);
        }
    }
    async getEnabledLabsFeaturesForWorkspace(workspaceId) {
        var _a;
        try {
            const workspace = await this.getWorkspace(workspaceId);
            return new featureSet_1.FeatureSet(new Set((_a = workspace.labs_features) !== null && _a !== void 0 ? _a : []));
        }
        catch (error) {
            throw toApiError(`Failed to get labs features for workspace ${workspaceId}`, error);
        }
    }
    async getUsers(workspaceId, limit) {
        try {
            const userQueryString = query_string_1.default.stringify({
                organization_id: workspaceId,
                limit,
            });
            const users = await this.makeGetRequest(`${this.baseApiUrl}/users/?${userQueryString}`).then((result) => { var _a; return (_a = result.users) !== null && _a !== void 0 ? _a : []; });
            sortTemporallyAscending(users);
            return users;
        }
        catch (error) {
            throw toApiError(`Failed to get users`, error);
        }
    }
    async getStepIdsInJourneyByFlow(journeyInvariantId, flowIds) {
        try {
            const stepIdsQueryString = query_string_1.default.stringify({
                flow_variant_ids: [flowIds],
            });
            return await this.makeGetRequest(`${this.baseApiUrl}/test/journey/${journeyInvariantId}/stepIdsByFlow?${stepIdsQueryString}`).then((result) => result !== null && result !== void 0 ? result : []);
        }
        catch (error) {
            throw toApiError(`Failed to get step ids in journey by flow`, error);
        }
    }
    async recordTimeSeriesMetricMeasurement(type, value, options) {
        try {
            return this.makePostRequest(`${this.baseApiUrl}/metrics/timeSeries`, createTimeSeriesMetricMeasurement(type, value, options));
        }
        catch (error) {
            throw toApiError('Failed to record time series metric measurement', error);
        }
    }
    async recordWorkspaceTimeSeriesMetricMeasurement(type, value, workspaceId, options) {
        const labels = { ...options === null || options === void 0 ? void 0 : options.labels, workspaceId };
        return this.recordTimeSeriesMetricMeasurement(type, value, {
            ...options,
            labels,
        });
    }
    async getMobileAppFile(id, sign = false) {
        let url = `${this.baseApiUrl}/mobile/apps/files/${id}`;
        if (sign) {
            url += '?sign=true';
        }
        try {
            return await this.makeGetRequest(url);
        }
        catch (error) {
            throw toApiError(`Failed to get mobile app file ${id}`, error);
        }
    }
    async getMobileAppFiles(workspaceId, limit) {
        try {
            const query = query_string_1.default.stringify({
                workspace_id: workspaceId,
                limit,
            });
            const mobileAppFiles = await this.makePostRequest(`${this.baseApiUrl}/mobile/apps/files/queryFiles?${query}`, {
                filter_conditions: [],
                sort_columns: [
                    {
                        column_name: 'created_time',
                        sort_direction: 'DESC',
                    },
                ],
            }).then((result) => { var _a; return (_a = result.mobile_app_files) !== null && _a !== void 0 ? _a : []; });
            sortTemporallyDescending(mobileAppFiles);
            return mobileAppFiles;
        }
        catch (error) {
            throw toApiError(`Failed to get mobile app files`, error);
        }
    }
    async deleteMobileAppFile(id) {
        try {
            const response = await this.makeDeleteRequest(`${this.baseApiUrl}/mobile/apps/files/${id}`);
            return response;
        }
        catch (error) {
            throw toApiError(`Failed to delete mobile app file ${id}`, error);
        }
    }
    async createMobileTrainingSession(prototype) {
        try {
            return await this.makePostRequest(`${this.baseApiUrl}/mobile/training/sessions`, prototype);
        }
        catch (error) {
            throw toApiError(`Failed to create mobile training session`, error);
        }
    }
    async getMobileTrainingSession(id) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/mobile/training/session/${id}`);
        }
        catch (error) {
            throw toApiError(`Failed to get mobile training session ${id}`, error);
        }
    }
    async runDatabaseQuery(queryExecution) {
        try {
            return await this.makePostRequest(`${this.baseApiUrl}/database/queryExecution`, queryExecution);
        }
        catch (error) {
            throw toApiError(`Failed to schedule database query execution`, error);
        }
    }
    async getDatabaseQueryExecution(executionId) {
        try {
            return await this.makeGetRequest(`${this.baseApiUrl}/database/queryExecution/${executionId}`);
        }
        catch (error) {
            throw toApiError(`Failed to schedule database query execution`, error);
        }
    }
    async terminateMobileTrainingSession(id, reason) {
        try {
            return await this.makePostRequest(`${this.baseApiUrl}/mobile/training/session/${id}/terminate`, { termination_reason: reason });
        }
        catch (error) {
            throw toApiError(`Failed to terminate mobile training session ${id}`, error);
        }
    }
}
exports.MablApiClient = MablApiClient;
function sortTemporallyAscending(entities) {
    entities.sort((a, b) => a.created_time - b.created_time);
}
function sortTemporallyDescending(entities) {
    entities.sort((a, b) => b.created_time - a.created_time);
}
function toApiError(summary, cause) {
    const errorResponse = cause === null || cause === void 0 ? void 0 : cause.response;
    const code = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.status;
    const mablError = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.data;
    const message = `${summary}: ${mablError
        ? `${mablError.code}: ${mablError.message} (${mablError.id})`
        : cause.toString()}`;
    return new ApiError_1.ApiError(message, code, cause);
}
function createTimeSeriesMetricMeasurement(type, numberValue, options) {
    return {
        labels: options === null || options === void 0 ? void 0 : options.labels,
        event_time: options === null || options === void 0 ? void 0 : options.event_time,
        type,
        value: Number.isInteger(numberValue)
            ? { int64_value: numberValue }
            : { double_value: numberValue },
    };
}
