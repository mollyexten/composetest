"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildUpdateRequest = void 0;
const mablApiClientFactory_1 = require("../../../api/mablApiClientFactory");
const util_1 = require("../../commandUtil/util");
const constants_1 = require("../../constants");
const pureUtil_1 = require("../../../util/pureUtil");
const utils_1 = require("../utils");
const domUtil_1 = require("../../../domUtil");
exports.command = `update <${constants_1.CommandArgId}> <${constants_1.CommandArgInput}>`;
exports.describe = 'Update a mabl DataTable';
exports.builder = (yargs) => {
    yargs
        .positional(constants_1.CommandArgId, {
        describe: 'ID of DataTable to update',
        type: 'string',
    })
        .positional(constants_1.CommandArgInput, {
        alias: 'file',
        describe: 'Relative path file to create DataTable from',
    })
        .option(constants_1.CommandArgWorkspaceId, {
        alias: constants_1.CommandArgAliases.WorkspaceId,
        describe: `Workspace your DataTable is exists in`,
        type: 'string',
    })
        .option(constants_1.CommandArgFormat, {
        alias: 'fmt',
        demandOption: false,
        describe: `Specify the format of your input file (checks file extension type by default)`,
        choices: [constants_1.OutputFormats.Json, constants_1.OutputFormats.Csv],
    });
};
exports.handler = (0, util_1.failWrapper)(updateDataTable);
async function updateDataTable(parsed) {
    var _a;
    const { id: dataTableId, input } = parsed;
    const format = (_a = parsed.format) !== null && _a !== void 0 ? _a : (0, utils_1.inferFileFormat)(input);
    const apiClient = await mablApiClientFactory_1.MablApiClientFactory.createApiClient();
    const dataTable = await apiClient.getDataTable(dataTableId);
    let scenarios;
    switch (format) {
        case constants_1.OutputFormats.Json:
            scenarios = (0, utils_1.parseJsonScenarios)(input);
            break;
        case constants_1.OutputFormats.Csv:
            scenarios = await (0, utils_1.parseCsvScenarios)(input);
            break;
        default:
            throw Error(`${format} is not a valid option.`);
    }
    const request = buildUpdateRequest(scenarios, dataTable);
    await apiClient.updateDataTable(dataTableId, request);
}
function buildUpdateRequest(scenarios, dataTable) {
    var _a, _b, _c;
    if (scenarios.length === 0 || !scenarios) {
        throw Error('Must have at least 1 scenario in DataTable.');
    }
    const validationVariables = scenarios[0].variables;
    scenarios.forEach((scenario) => {
        var _a, _b, _c;
        if (scenario.id && !((_a = dataTable.scenario_ids) === null || _a === void 0 ? void 0 : _a.includes(scenario.id))) {
            throw Error(`Scenario in input with ID ${scenario.id} does not exist in DataTable scenario_ids.`);
        }
        if (((_b = scenario.variables) === null || _b === void 0 ? void 0 : _b.length) === 0 || !scenario.variables) {
            throw Error('Must have at least 1 variable in a scenario.');
        }
        if (scenario.variables.length !== (validationVariables === null || validationVariables === void 0 ? void 0 : validationVariables.length)) {
            throw Error('All scenarios must have the same number of variables.');
        }
        (_c = scenario.variables) === null || _c === void 0 ? void 0 : _c.forEach((variable, index) => {
            if (!(0, domUtil_1.isValidUserVariableName)(variable.name)) {
                throw Error(`Invalid variable name: ${variable.name}. Variable names must start with a letter or underscore (_) followed by letters, numbers, and underscores and cannot be "user", "web", or "mail"`);
            }
            if (variable.name !== validationVariables[index].name) {
                throw Error('All scenarios must have the same variable names and be in the same order.');
            }
        });
    });
    const parsedScenarioMap = scenarios
        .filter((scenario) => scenario.id !== undefined)
        .reduce((acc, scenario) => {
        acc[scenario.id] = scenario;
        return acc;
    }, {});
    const updatedRows = ((_a = dataTable.scenario_ids) === null || _a === void 0 ? void 0 : _a.filter((id) => parsedScenarioMap[id] !== undefined).map((id) => {
        const variableRow = (0, utils_1.scenarioAsVariableRow)(parsedScenarioMap[id]);
        return {
            id: variableRow.id || '',
            scenario_id: variableRow.scenario_id || '',
            row: variableRow.row || [],
        };
    }).filter(pureUtil_1.isDefined)) || [];
    const updatedRowIds = updatedRows
        .map((row) => row.id)
        .filter(pureUtil_1.isDefined);
    const addedRows = scenarios
        .filter((row) => row.id === undefined)
        .map((scenario) => {
        const variableRow = (0, utils_1.scenarioAsVariableRow)(scenario);
        return {
            id: variableRow.id,
            scenario_id: variableRow.scenario_id,
            row: variableRow.row,
        };
    });
    const deletedRowIds = (_c = (_b = dataTable.scenario_ids) === null || _b === void 0 ? void 0 : _b.filter((id) => !updatedRowIds.includes(id))) !== null && _c !== void 0 ? _c : [];
    const prototype = {
        ...(0, utils_1.dataTableAsVariableTable)(dataTable),
        row_ids: updatedRows.map((row) => row.id).filter(pureUtil_1.isDefined),
    };
    return {
        prototype,
        updatedRows,
        deletedRowIds,
        addedRows,
    };
}
exports.buildUpdateRequest = buildUpdateRequest;
