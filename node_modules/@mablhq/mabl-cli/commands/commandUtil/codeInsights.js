"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maybeOutputToBitbucket = exports.putCodeReportAndAnnotations = exports.generateCodeAnnotationsForReport = exports.generateCodeReportForCommit = void 0;
const CodeReport_1 = require("../../api/atlassian/entities/CodeReport");
const moment = require("moment");
const bitBucketApiClient_1 = require("../../api/atlassian/bitBucketApiClient");
const CodeAnnotation_1 = require("../../api/atlassian/entities/CodeAnnotation");
const loggingProvider_1 = require("../../providers/logging/loggingProvider");
const logUtils_1 = require("../../util/logUtils");
const pureUtil_1 = require("../../util/pureUtil");
const chalk = require('chalk');
const bitbucketUserKey = 'MABL_BITBUCKET_USER';
const bitbucketAppToken = 'MABL_BITBUCKET_APP_TOKEN';
function generateCodeReportForCommit(executionEventId, outputLink, executionResult) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const codeReport = {
        report_type: CodeReport_1.CodeReportType.TEST,
        external_id: `${executionEventId}-cr`,
        title: `mabl tests`,
        details: `mabl tests for mabl deployment ${executionEventId}`,
        result: ((_a = executionResult.event_status) === null || _a === void 0 ? void 0 : _a.succeeded)
            ? CodeReport_1.CodeInsightsResult.PASSED
            : CodeReport_1.CodeInsightsResult.FAILED,
        reporter: `mabl`,
        link: outputLink,
        logo_url: 'https://storage.cloud.google.com/mabl-email-static-assets/mabl_logo.png',
        created_on: moment().toISOString(),
    };
    codeReport.data = [
        {
            title: 'mabl App',
            type: 'LINK',
            value: {
                text: 'View results',
                href: outputLink,
            },
        },
        {
            title: 'Plans run',
            type: 'NUMBER',
            value: (_b = executionResult.plan_execution_metrics) === null || _b === void 0 ? void 0 : _b.total,
        },
        {
            title: 'Plans failed',
            type: 'NUMBER',
            value: (_c = executionResult.plan_execution_metrics) === null || _c === void 0 ? void 0 : _c.failed,
        },
        {
            title: 'Tests run',
            type: 'NUMBER',
            value: (_d = executionResult.journey_execution_metrics) === null || _d === void 0 ? void 0 : _d.total,
        },
        {
            title: 'Tests failed',
            type: 'NUMBER',
            value: (_e = executionResult.journey_execution_metrics) === null || _e === void 0 ? void 0 : _e.failed,
        },
    ];
    if ((_g = (_f = executionResult.journey_execution_metrics) === null || _f === void 0 ? void 0 : _f.total) !== null && _g !== void 0 ? _g : 0 > 0) {
        const percentPassing = parseFloat(((((_j = (_h = executionResult.journey_execution_metrics) === null || _h === void 0 ? void 0 : _h.passed) !== null && _j !== void 0 ? _j : 0) /
            ((_l = (_k = executionResult.journey_execution_metrics) === null || _k === void 0 ? void 0 : _k.total) !== null && _l !== void 0 ? _l : 1)) *
            100).toFixed(2));
        codeReport.data.push({
            title: 'Tests passing percent',
            type: 'PERCENTAGE',
            value: percentPassing,
        });
    }
    if (executionResult.executions) {
        const minStartTimes = [];
        executionResult.executions.forEach((execution) => {
            if (execution.start_time) {
                minStartTimes.push(execution.start_time);
            }
        });
        const maxStartTimes = [];
        executionResult.executions.forEach((execution) => {
            if (execution.stop_time) {
                maxStartTimes.push(execution.stop_time);
            }
        });
        if (maxStartTimes && minStartTimes) {
            const duration = Math.max(...maxStartTimes) - Math.min(...minStartTimes);
            codeReport.data.push({
                title: 'Total duration',
                type: 'DURATION',
                value: duration,
            });
        }
    }
    return codeReport;
}
exports.generateCodeReportForCommit = generateCodeReportForCommit;
function generateCodeAnnotationsForReport(executionResult) {
    const codeAnnotations = [];
    if (executionResult.executions) {
        executionResult.executions.forEach((execution) => {
            if (execution.journey_executions) {
                execution.journey_executions.forEach((testExecution) => {
                    const codeAnnotation = {
                        external_id: `${testExecution.journey_execution_id}-ca`,
                        annotation_type: CodeAnnotation_1.CodeInsightsAnnotationType.BUG,
                        summary: generateAnnotationSummary(testExecution, execution.journeys),
                        result: testExecution.success
                            ? CodeReport_1.CodeInsightsResult.PASSED
                            : CodeReport_1.CodeInsightsResult.FAILED,
                        details: generateAnnotationDetails(testExecution),
                        link: testExecution.app_href,
                        created_on: moment(testExecution.stop_time).toISOString(),
                    };
                    codeAnnotations.push(codeAnnotation);
                });
            }
        });
    }
    return codeAnnotations;
}
exports.generateCodeAnnotationsForReport = generateCodeAnnotationsForReport;
function generateAnnotationDetails(testExecution) {
    var _a;
    if (testExecution.success) {
        return `Test was successful - Browser: "${testExecution.browser_type}"`;
    }
    return `Failure Error: "${(_a = testExecution.failure_summary) === null || _a === void 0 ? void 0 : _a.error}" - Browser: "${testExecution.browser_type}"`;
}
function generateAnnotationSummary(testExecution, journeySummaries) {
    let testForAnnotation;
    if (journeySummaries) {
        testForAnnotation = journeySummaries.find((test) => test.id === testExecution.journey_id);
    }
    if (testForAnnotation) {
        return `${testForAnnotation.name}`;
    }
    return `"${testExecution.journey_id}" test finished with status ${testExecution.status}`;
}
async function putCodeReportAndAnnotations(executionResult, executionEventId, outputLink, workspace, repoSlug, node, isCustomBitBucketPipe, noProxy) {
    const codeReport = generateCodeReportForCommit(executionEventId, outputLink, executionResult);
    const bitBucketApiClient = getBitBucketApiClient(isCustomBitBucketPipe, noProxy);
    const codeReportResponse = await bitBucketApiClient.putCodeReport(codeReport, workspace, repoSlug, node);
    const codeAnnotations = generateCodeAnnotationsForReport(executionResult);
    const requests = codeAnnotations.map((annotation) => bitBucketApiClient.putCodeAnnotation(annotation, workspace, repoSlug, node, codeReportResponse.external_id));
    const results = await Promise.allSettled(requests);
    (0, logUtils_1.logPromiseSettledRejections)(results);
    if (results.some(pureUtil_1.isRejectedPromise)) {
        throw new Error('Error writing Code Annotations to Bitbucket');
    }
    return codeReportResponse;
}
exports.putCodeReportAndAnnotations = putCodeReportAndAnnotations;
async function maybeOutputToBitbucket(executionResult, deploymentId, outputLink) {
    var _a, _b, _c, _d;
    const repoSlug = (_a = process.env.BITBUCKET_REPO_SLUG) !== null && _a !== void 0 ? _a : '';
    const workspace = (_b = process.env.BITBUCKET_REPO_OWNER) !== null && _b !== void 0 ? _b : '';
    const node = (_c = process.env.BITBUCKET_COMMIT) !== null && _c !== void 0 ? _c : '';
    const isCustomBitBucketPipe = process.env.IS_CUSTOM_BITBUCKET_PIPE === 'true';
    const noProxy = process.env.CODE_INSIGHTS_PROXY_OFF === 'true';
    if (repoSlug &&
        workspace &&
        node &&
        ((_d = executionResult === null || executionResult === void 0 ? void 0 : executionResult.executions) === null || _d === void 0 ? void 0 : _d.length) &&
        executionResult.executions.length > 0) {
        const codeReport = await putCodeReportAndAnnotations(executionResult, deploymentId, outputLink, workspace, repoSlug, node, isCustomBitBucketPipe, noProxy);
        loggingProvider_1.logger.info(chalk.cyan(`Bitbucket Code Insights Report generated ${codeReport.uuid}`));
    }
    return;
}
exports.maybeOutputToBitbucket = maybeOutputToBitbucket;
function getBitBucketApiClient(isCustomPipe, noProxy) {
    if (noProxy) {
        const username = process.env[bitbucketUserKey];
        const token = process.env[bitbucketAppToken];
        if (!username || !token) {
            throw new Error(`Auth config not supplied for Bitbucket output. Please define ${bitbucketUserKey} and ${bitbucketAppToken} environment variables`);
        }
        return new bitBucketApiClient_1.BitBucketApiClient(username, token, isCustomPipe, noProxy);
    }
    if (isCustomPipe) {
        return new bitBucketApiClient_1.BitBucketApiClient('', '', isCustomPipe, noProxy);
    }
    return new bitBucketApiClient_1.BitBucketApiClient('', '', isCustomPipe, noProxy);
}
