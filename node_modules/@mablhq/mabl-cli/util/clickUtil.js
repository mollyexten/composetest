"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clickOnElement = exports.CLICK_TYPE_TO_HUMAN_TEXT = exports.ClickType = void 0;
const messaging_1 = require("../core/messaging/messaging");
const ExecutorUtils_1 = require("../execution/actions/ExecutorUtils");
const loggingProvider_1 = require("../providers/logging/loggingProvider");
const actionabilityUtil_1 = require("./actionabilityUtil");
const logUtils_1 = require("./logUtils");
var ClickType;
(function (ClickType) {
    ClickType["DoubleClick"] = "double_click";
    ClickType["LeftClick"] = "click";
    ClickType["RightClick"] = "right_click";
})(ClickType || (exports.ClickType = ClickType = {}));
const CLICK_TYPE_TO_JS_FIRER = {
    [ClickType.DoubleClick]: (element) => globalThis.popupDismissal.fireDoubleClickEvent(element),
    [ClickType.LeftClick]: (element) => globalThis.popupDismissal.fireClickEvent(element),
    [ClickType.RightClick]: (element) => globalThis.popupDismissal.fireRightClickEvent(element),
};
exports.CLICK_TYPE_TO_HUMAN_TEXT = {
    [ClickType.DoubleClick]: 'double click',
    [ClickType.LeftClick]: 'click',
    [ClickType.RightClick]: 'right click',
};
async function clickOnElement(elementHandle, executionContext, clickType = ClickType.LeftClick) {
    const trialClickOptions = {
        button: clickType === ClickType.RightClick ? 'right' : 'left',
        trial: true,
        minimizeScrollIntoView: executionContext.browserConfig.minimizeScrollIntoView,
    };
    const elementHandleTrialClickAction = clickType === ClickType.DoubleClick
        ? () => elementHandle.doubleClick(trialClickOptions)
        : () => elementHandle.click(trialClickOptions);
    const noOverlappingElement = await (0, actionabilityUtil_1.checkPopupDismissalOnAction)(elementHandle, elementHandleTrialClickAction, executionContext);
    const elementBoundingBox = await elementHandle.boundingBox();
    const elementHasSurfaceArea = elementBoundingBox
        ? elementBoundingBox.height > 0 && elementBoundingBox.width > 0
        : false;
    if (!noOverlappingElement || !elementHasSurfaceArea) {
        const isAttached = await elementHandle.evaluate((el) => el.isConnected);
        if (!isAttached) {
            throw new Error(ExecutorUtils_1.ELEMENT_NOT_ATTACHED_ERROR);
        }
        const jsClickReasons = [
            !noOverlappingElement && "there is a popup we couldn't dismiss",
            !elementHasSurfaceArea && 'the element is not visible',
        ]
            .filter((reason) => reason !== false)
            .join(' and ');
        (0, logUtils_1.logWebUIAndCliOutput)(`Attempting ${exports.CLICK_TYPE_TO_HUMAN_TEXT[clickType]} with javascript because ${jsClickReasons}`, loggingProvider_1.LogLevel.Warn, executionContext, {
            executionPhase: messaging_1.ExecutionPhase.DURING_ACTION,
        });
        if (noOverlappingElement) {
            await (0, actionabilityUtil_1.maybeAddPopupLogic)(elementHandle);
        }
        const jsClickEventFirer = CLICK_TYPE_TO_JS_FIRER[clickType];
        return elementHandle.evaluate(jsClickEventFirer);
    }
    const finalClickOptions = {
        button: clickType === ClickType.RightClick ? 'right' : 'left',
        timeout: 0,
        minimizeScrollIntoView: executionContext.browserConfig.minimizeScrollIntoView,
    };
    return clickType === ClickType.DoubleClick
        ? elementHandle.doubleClick(finalClickOptions)
        : elementHandle.click(finalClickOptions);
}
exports.clickOnElement = clickOnElement;
