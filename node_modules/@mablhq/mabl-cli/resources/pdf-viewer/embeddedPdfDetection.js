mablEmbeddedPdfDetector = () => {
  const MABL_PDF_DETECTOR_ANIMATION_NAME =
    '__mabl-trainer-object-embed-detector';
  const MABL_PDF_DETECTOR_STYLE_ID = '__mabl-pdf-detector';
  const PDFEventType = 'animationstart';
  const MABL_PROCESSED_PDF_ATTRIBUTE = '__mabl-processed-pdf';
  const MABL_EMBEDDED_PDF_DETECTED_FLAG = 'mabl-detected-embedded-pdf';
  // must match the types defined in pageMessaging.ts
  const MESSAGE_TYPE_EMBEDDED_PDF_DETECTED = 'EMBEDDED_PDF_DETECTED';
  const MESSAGE_TYPE_EMBEDDED_PDF_MARKED = 'EMBEDDED_PDF_MARKED';

  if (
    document.doctype &&
    document.doctype.name &&
    document.doctype.name.indexOf('html') !== -1
  ) {
    window.addEventListener(PDFEventType, handle, true);

    // Don't wait for animation to load existing embedded elements
    Array.from(document.querySelectorAll('object, embed')).forEach(
      (element) => {
        handle({
          target: element,
          animationName: MABL_PDF_DETECTOR_ANIMATION_NAME,
        });
      },
    );

    if (!document.getElementById(MABL_PDF_DETECTOR_STYLE_ID)) {
      const pdfDetectorStyleElem = document.createElement.call(
        document,
        'style',
      );
      pdfDetectorStyleElem.innerHTML = `
    @keyframes ${MABL_PDF_DETECTOR_ANIMATION_NAME} { from {} }
    object, embed {
      animation-delay: 0s !important;
      animation-name: ${MABL_PDF_DETECTOR_ANIMATION_NAME} !important;
      animation-play-state: running !important;
    }`;
      pdfDetectorStyleElem.id = MABL_PDF_DETECTOR_STYLE_ID;
      if (document.head) {
        // the default PDF page in Chrome doesn't have a head, and the browser doesn't insert one
        document.head.appendChild(pdfDetectorStyleElem);
      } else if (document.body) {
        document.body.appendChild(pdfDetectorStyleElem);
      }
    }
  }

  /**
   * Returns the URL string of the element which should in some way be embedding a PDF.
   * @param {HTMLElement} originalPdfElement The element embedding the PDF, should have embed tag, object tag,
   * @returns {(string|undefined)} The URL which should host the PDF, or undefined if none was found
   */
  function getPdfUrlFromElement(originalPdfElement) {
    return (
      originalPdfElement.src ||
      originalPdfElement.data || // embed has @src, object has @data
      undefined
    );
  }

  /**
   * Checks that the URL embedding the PDF leads to a valid location and/or
   * has a valid protocol
   * @param {HTMLElement} element The element on the page whose URL to check
   * @returns {boolean} Whether or not the element is valid
   */
  function checkUrlProtocol(element) {
    if (element.src === 'about:blank') {
      // this is likely the chrome viewer for a POST
      // don't do anything, we might get a manual update later
      // if the trainer finds a PDF
      return false;
    }
    // Validate that the URL is an allowed protocol to prevent XSS, see IST-561
    const pdfUrlString = getPdfUrlFromElement(element);
    try {
      const pdfUrl = new URL(pdfUrlString);
      // data: is allowed to support embedding the PDF inline using a data URI scheme
      const allowedProtocols = ['http:', 'https:', 'data:'];
      if (!allowedProtocols.includes(pdfUrl?.protocol)) {
        console.warn(
          `PDF Handler ignoring element with URL ${pdfUrlString} because protocol ${pdfUrl?.protocol} does not match one of the allowed protocols ${allowedProtocols}`,
        );
        return false;
      } else if (
        pdfUrl?.protocol === 'data:' &&
        !/^data:application\/pdf[,;]/.test(pdfUrl?.href ?? '') // starts with data:application/pdf and either , or ; separator
      ) {
        console.warn(
          `PDF Handler ignoring element with URL ${pdfUrlString} because it does not use application/pdf MIME type`,
        );
        return false;
      }
    } catch (e) {
      console.warn(
        `PDF Handler ignoring element with URL ${pdfUrlString}; error ${e} was thrown while converting to URL`,
      );
      return false;
    }
    return true;
  }

  async function handle(event) {
    const element = event.target;
    if (
      checkAnimationEvent(event) &&
      checkElement(element) &&
      checkMimeType(element) &&
      !isMablMarked(element) &&
      checkUrlProtocol(element)
    ) {
      const baseUri = document.baseURI;
      const pdfElement = element;
      const pdfUrl = pdfElement.src || pdfElement.data;
      const pdfFileName = mablGetPdfFilenameFromUrl(pdfUrl);

      const embeddedPdfMablId = createEmbeddedPdfMablId(pdfFileName);
      // Mark the embedded PDF element so that we can find it to replace it later
      pdfElement.setAttribute(
        MABL_EMBEDDED_PDF_DETECTED_FLAG,
        embeddedPdfMablId,
      );

      // Signal embedded PDF detection and pending download
      // Wait for PDF event be acknowledged by PageFrameContextTracker before continuing
      await window.dispatchMablEvent({
        type: MESSAGE_TYPE_EMBEDDED_PDF_DETECTED,
        baseUri,
        pdfUrl,
        pdfFileName,
      });

      mablDownloadEmbeddedPdf(pdfFileName, pdfUrl);

      // Trigger replacement of the embedded PDF with an interactable version served by PDF server
      window.dispatchMablEvent({
        type: MESSAGE_TYPE_EMBEDDED_PDF_MARKED,
        baseUri,
        embeddedPdfMablId,
        pdfFileName,
      });
    }
  }

  function checkAnimationEvent(event) {
    return event.animationName === MABL_PDF_DETECTOR_ANIMATION_NAME;
  }

  function checkElement(element) {
    return element.tagName === 'EMBED' || element.tagName === 'OBJECT';
  }

  function checkMimeType(element) {
    const mimeType = element.type;
    const path = getPdfUrlFromElement(element);
    const isAPdf =
      (mimeType && mimeType.toLowerCase() === 'application/pdf') || // mime type is PDF
      (!mimeType && path && /\.pdf($|[?#])/i.test(path)) || // or if we don't have a mime type test the path up to query or hash
      !!element[MABL_PROCESSED_PDF_ATTRIBUTE]; // it's an element we've already identified
    return isAPdf;
  }

  function isMablMarked(element) {
    const attrValue = element.getAttribute(MABL_EMBEDDED_PDF_DETECTED_FLAG);
    if (attrValue === null || attrValue === undefined) {
      return false;
    }
    return true;
  }
};

const CHECK_INTERVAL_IN_MILLIS = 300;
const CHECK_TIMEOUT_IN_MILLIS = 5000;
let checkTimer;
const checkStartTime = Date.now();
const MABL_DEFAULT_PDF_NAME = 'mablPdf';

function mablPdfIdSanitize(originalId) {
  return originalId && originalId.replace(/[^a-zA-Z0-9.-]/g, '_');
}

function createEmbeddedPdfMablId(pdfFileName) {
  return '__mabl_pdf_viewer_' + mablPdfIdSanitize(pdfFileName);
}

function documentHasDocType() {
  return document.doctype && document.doctype.name;
}

function runEmbeddedPdfDetector() {
  if (documentHasDocType()) {
    mablEmbeddedPdfDetector();
    checkTimer && clearInterval(checkTimer);
  } else if (Date.now() - checkStartTime > CHECK_TIMEOUT_IN_MILLIS) {
    checkTimer && clearInterval(checkTimer);
  }
}

function mablGetPdfFilenameFromUrl(pdfUrl) {
  const parsedUrl = new URL(pdfUrl);
  const pdfFileName =
    parsedUrl.pathname.split('/').slice(-1)[0] ?? MABL_DEFAULT_PDF_NAME;
  return pdfUrl.startsWith('blob:') ? 'blob_pdf' : pdfFileName;
}

function mablDownloadEmbeddedPdf(fileName, pdfUrl) {
  const aTag = document.createElement('a');
  aTag.style.display = 'none';
  document.body.appendChild(aTag);
  aTag.href = pdfUrl;
  aTag.setAttribute('download', fileName);
  aTag.click();
  document.body.removeChild(aTag);
}

if (!documentHasDocType()) {
  // If this is executed too quickly, the DOCTYPE has not been loaded yet
  // so wait a bit before checking again.
  checkTimer = setInterval(runEmbeddedPdfDetector, CHECK_INTERVAL_IN_MILLIS);
} else {
  mablEmbeddedPdfDetector();
}
