"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDeploymentEventWebappUrl = exports.printDeploymentEventResultOutput = void 0;
const env_1 = require("../../../env/env");
const mablApiClientFactory_1 = require("../../../api/mablApiClientFactory");
const mablApi_1 = require("../../../mablApi");
const util_1 = require("../../commandUtil/util");
const branches_1 = require("../../commandUtil/branches");
const awaitDeploymentCompletion_1 = require("./awaitDeploymentCompletion");
const scmContextProvider_1 = require("../../../providers/scmContextProvider");
const scmContextProviderV2_1 = require("../../../providers/scmContextProviderV2");
const cliConfigProvider_1 = require("../../../providers/cliConfigProvider");
const configKeys_1 = require("../../config/config_cmds/configKeys");
const codeInsights_1 = require("../../commandUtil/codeInsights");
const constants_1 = require("../../constants");
const describe_1 = require("../../commandUtil/describe");
const loggingProvider_1 = require("../../../providers/logging/loggingProvider");
const chalk = require('chalk');
const CommandArgAwaitCompletion = 'await-completion';
const CommandArgRebaselineImages = 'rebaseline-images';
const CommandArgRepositoryUrl = 'repository-url';
const CommandArgSetStaticBaseline = 'set-static-baseline';
const CommandArgSnapshotBranch = 'snapshot-from';
exports.command = 'create';
exports.describe = 'Trigger a deployment event via the mabl API';
exports.builder = (yargs) => {
    yargs
        .option(constants_1.CommandArgApplicationId, {
        alias: constants_1.CommandArgAliases.ApplicationId,
        describe: 'Application to run the mabl tests for. If provided, mabl will only trigger plans that contain this application',
        nargs: 1,
        type: 'string',
    })
        .option(constants_1.CommandArgEnvironmentId, {
        alias: constants_1.CommandArgAliases.EnvironmentId,
        describe: 'Environment to run the mabl tests for. If provided, mabl will only trigger plans that contain this environment',
        nargs: 1,
        type: 'string',
    })
        .option(constants_1.CommandArgOverrideEnvironmentId, {
        describe: 'Override environment to run the tests against. Not used to select plans to run. Requires `--application-id`.',
        nargs: 1,
        type: 'string',
    })
        .option(CommandArgAwaitCompletion, {
        describe: 'Block until mabl tests complete.',
        type: 'boolean',
        default: false,
    })
        .option(constants_1.CommandArgFastFailure, {
        describe: `If using \'--${CommandArgAwaitCompletion}\', exit on first failed test`,
        type: 'boolean',
        default: false,
    })
        .implies(constants_1.CommandArgFastFailure, CommandArgAwaitCompletion)
        .option(constants_1.CommandArgSilent, {
        describe: "Don't output runtime status",
        type: 'boolean',
        default: false,
    })
        .option(constants_1.CommandArgOutput, {
        alias: constants_1.CommandArgAliases.OutputType,
        describe: 'Specify final result output format. Implies: --silent',
        choices: constants_1.DefaultOutputFormatChoices,
    })
        .option(constants_1.CommandArgWorkspaceId, {
        alias: constants_1.CommandArgAliases.WorkspaceId,
        describe: 'Workspace containing target environment and/or application',
        nargs: 1,
        type: 'string',
    })
        .option(constants_1.CommandArgBrowsers, {
        alias: constants_1.CommandArgAliases.Browsers,
        describe: 'Space delimited browsers to test against (e.g. "chrome firefox")',
        type: 'array',
        default: [],
        choices: constants_1.BrowserTypeSelections,
    })
        .option(constants_1.CommandArgLabelsInclude, {
        alias: 'l',
        describe: 'Space delimited plan labels. Run plans that match any label.',
        type: 'array',
        default: [],
    })
        .option(constants_1.CommandArgHttpHeaders, {
        describe: 'Space delimited HTTP headers added to browser requests (e.g. "x-header:foo")',
        type: 'array',
        default: [],
    })
        .option(constants_1.CommandArgUrl, {
        alias: constants_1.CommandArgAliases.Url,
        describe: 'URL to use for deployment',
        type: 'string',
    })
        .option(constants_1.CommandArgUrlApp, {
        describe: 'Application/web URL to use for deployment',
        nargs: 1,
        type: 'string',
    })
        .option(constants_1.CommandArgUrlApi, {
        describe: 'API URL to to use for deployment',
        nargs: 1,
        type: 'string',
    })
        .option(constants_1.CommandArgAndroidMobileAppFileId, {
        describe: 'Android mobile app file to use for deployment',
        nargs: 1,
        type: 'string',
    })
        .option(constants_1.CommandArgiOSdMobileAppFileId, {
        describe: 'iOS mobile app file to use for deployment',
        nargs: 1,
        type: 'string',
    })
        .option(constants_1.CommandArgApiKey, {
        alias: constants_1.CommandArgAliases.ApiKey,
        describe: 'API key (found in the mabl web app)',
        nargs: 1,
        type: 'string',
    })
        .option(CommandArgRebaselineImages, {
        alias: 'rbi',
        describe: 'Rebaseline visual change models',
        type: 'boolean',
        default: false,
    })
        .option(CommandArgSetStaticBaseline, {
        alias: 'ssbi',
        describe: 'Set run as fixed baseline for visual change models',
        type: 'boolean',
        default: false,
    })
        .option(constants_1.CommandArgRevision, {
        alias: constants_1.CommandArgAliases.Revision,
        describe: 'Code revision hash (application under test)',
        nargs: 1,
        type: 'string',
    })
        .option(CommandArgRepositoryUrl, {
        describe: 'Code repository URL (e.g. git@github.com:foo/bar.git)',
        nargs: 1,
        type: 'string',
    })
        .option(constants_1.CommandArgMablBranch, {
        describe: 'mabl branch to run tests against',
        nargs: 1,
        type: 'string',
    })
        .option(constants_1.CommandArgMablAutoBranch, {
        describe: 'Create a mabl branch when a mabl-branch target is specified that does not exist',
        type: 'boolean',
        default: false,
    })
        .option(CommandArgSnapshotBranch, {
        describe: 'Snapshot the current state of the tests from a mabl branch onto the environment. Use "master" for the mainline branch.  Requires setting environment-id.',
        nargs: 1,
        type: 'string',
    })
        .option('target-runtime-version', {
        hidden: true,
        nargs: 1,
        type: 'string',
    })
        .option('runner-type', {
        hidden: true,
        nargs: 1,
        type: 'string',
        choices: [
            mablApi_1.PlanOverrideOptions.NodejsRuntimeVariantEnum.Playwright,
            mablApi_1.PlanOverrideOptions.NodejsRuntimeVariantEnum.Puppeteer,
        ],
    })
        .implies(constants_1.CommandArgMablAutoBranch, constants_1.CommandArgMablBranch)
        .implies(CommandArgSnapshotBranch, constants_1.CommandArgEnvironmentId)
        .implies(constants_1.CommandArgOverrideEnvironmentId, constants_1.CommandArgApplicationId)
        .check((argv) => {
        if (!(argv[constants_1.CommandArgApplicationId] || argv[constants_1.CommandArgEnvironmentId])) {
            throw new Error(`At least one of ${constants_1.CommandArgApplicationId} or ${constants_1.CommandArgEnvironmentId} required`);
        }
        const branchName = argv[constants_1.CommandArgMablBranch];
        if (branchName !== undefined && !(0, branches_1.isValidMablBranchName)(branchName)) {
            throw new Error(`[${branchName}] is not a valid mabl branch name. Please specify a valid name`);
        }
        const snapshotFromBranch = argv[CommandArgSnapshotBranch];
        if (snapshotFromBranch !== undefined &&
            !(0, branches_1.isValidMablBranchName)(snapshotFromBranch)) {
            throw new Error(`[${snapshotFromBranch}] is not a valid mabl branch name to snapshot from. Please specify a valid name`);
        }
        (0, util_1.validateArrayInputs)(argv[constants_1.CommandArgBrowsers], 'browser names must be SPACE delimited, e.g. "--browsers=chrome firefox"');
        (0, util_1.validateArrayInputs)(argv[constants_1.CommandArgLabelsInclude], 'label names must be SPACE delimited, e.g. "--labels=foo bar"');
        (0, util_1.validateArrayInputs)(argv[constants_1.CommandArgHttpHeaders], 'HTTP headers must be SPACE delimited, e.g. "--http-headers="foo:bar" "baz:qux"');
        const httpHeaders = argv[constants_1.CommandArgHttpHeaders];
        argv[constants_1.CommandArgHttpHeaders] = (0, util_1.validateValuePairInputs)('HTTP header', httpHeaders);
        const repositoryUrl = argv['repository-url'];
        if (repositoryUrl !== undefined && repositoryUrl.trim() === '') {
            throw new Error(`repository-url cannot be set to empty value`);
        }
        return true;
    });
};
exports.handler = (0, util_1.failWrapper)(createDeployment);
async function createDeployment(parsed) {
    var _a, _b, _c;
    const apiClient = await mablApiClientFactory_1.MablApiClientFactory.createApiClientFromOptionalApiKey(parsed['api-key']);
    if (parsed.output) {
        parsed.silent = true;
    }
    if (!parsed.silent) {
        loggingProvider_1.logger.info('Creating Deployment...');
    }
    const applicationId = parsed['application-id'];
    const environmentId = parsed['environment-id'];
    const workspaceId = await (0, util_1.getWorkspaceIdFromAppOrEnv)(apiClient, applicationId, environmentId);
    const environmentOverride = parsed[constants_1.CommandArgOverrideEnvironmentId];
    let deploymentIds;
    if (environmentOverride) {
        deploymentIds = (_a = (await apiClient.queryDeploymentEntities(workspaceId, environmentOverride, applicationId)).deployments) === null || _a === void 0 ? void 0 : _a.map((deployment) => deployment.id);
        if (!deploymentIds || deploymentIds.length === 0) {
            loggingProvider_1.logger.error(chalk.red.bold(`Application ${applicationId} is not defined in override environment ${environmentOverride}`));
            process.exit(1);
        }
    }
    const androidMobileAppFileId = parsed[constants_1.CommandArgAndroidMobileAppFileId];
    if (!!androidMobileAppFileId) {
        await apiClient.getMobileAppFile(androidMobileAppFileId);
    }
    const iOSMobileAppFileId = parsed[constants_1.CommandArgiOSdMobileAppFileId];
    if (!!iOSMobileAppFileId) {
        await apiClient.getMobileAppFile(iOSMobileAppFileId);
    }
    const mablBranch = parsed['mabl-branch'];
    await (0, branches_1.checkBranchNameAndAutoBranchMaybe)(workspaceId, apiClient, mablBranch, parsed['auto-branch']);
    const snapshotFromBranch = parsed['snapshot-from'];
    const httpHeaders = parsed['http-headers'];
    const scmMetadata = await attemptSourceControlMetadataCollection(parsed);
    const deploymentEvent = await apiClient.postDeploymentEvent({
        browserTypes: parsed.browsers,
        labels: parsed.labels,
        rebaselineImages: parsed['rebaseline-images'],
        setStaticBaseline: parsed['set-static-baseline'],
        applicationId,
        httpHeaders,
        environmentId,
        uri: parsed.url,
        apiUrl: parsed.apiUrl,
        appUrl: parsed.appUrl,
        androidMobileAppFileId,
        iOSMobileAppFileId,
        mablBranch,
        snapshotFromBranch,
        sourceControlMetadata: scmMetadata,
        deploymentIds,
        targetRuntimeVersion: parsed['target-runtime-version'],
    });
    const outputWebappLink = getDeploymentEventWebappUrl(deploymentEvent);
    if (!parsed.output) {
        loggingProvider_1.logger.info(chalk.magenta.bold(`Deployment triggered. View output at: ${outputWebappLink}`));
    }
    if (!parsed['await-completion']) {
        return printDeploymentEventResultOutput(deploymentEvent.id, outputWebappLink, parsed.output);
    }
    const waiter = new awaitDeploymentCompletion_1.AwaitDeploymentCompletion(apiClient, parsed['fast-failure'], parsed.silent);
    const pollingResult = await waiter.awaitCompletion(deploymentEvent.id);
    const isSuccess = ((_c = (_b = pollingResult === null || pollingResult === void 0 ? void 0 : pollingResult.newEntity) === null || _b === void 0 ? void 0 : _b.event_status) === null || _c === void 0 ? void 0 : _c.succeeded) || false;
    try {
        await (0, codeInsights_1.maybeOutputToBitbucket)(pollingResult.newEntity, deploymentEvent.id, outputWebappLink);
    }
    catch (error) {
        loggingProvider_1.logger.info(chalk.yellow.bold('Unable to generate code insights due to BitBucket integration API error'));
        loggingProvider_1.logger.info(`details: ${error}`);
    }
    const textOutput = printDeploymentEventResultOutput(deploymentEvent.id, outputWebappLink, parsed.output, pollingResult === null || pollingResult === void 0 ? void 0 : pollingResult.newEntity);
    if (!isSuccess) {
        process.exit(1);
    }
    return textOutput;
}
function printDeploymentEventResultOutput(deploymentEventId, outputWebappLink, outputMode, executionResult) {
    switch (outputMode) {
        case constants_1.OutputFormats.Json:
        case constants_1.OutputFormats.Yaml:
            const resultPayload = {
                id: deploymentEventId,
                href: outputWebappLink,
                execution_results: executionResult,
            };
            return (0, describe_1.outputEntity)(resultPayload, outputMode);
        default:
            return outputWebappLink;
    }
}
exports.printDeploymentEventResultOutput = printDeploymentEventResultOutput;
async function attemptSourceControlMetadataCollection(parsed) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    const userSuppliedRepositoryUrl = parsed['repository-url'];
    if (await cliConfigProvider_1.CliConfigProvider.getConfigProperty(configKeys_1.configKeys.enableSourceControlMetadataCollection)) {
        const buildInfo = await new scmContextProvider_1.ScmContextProvider(process.env).extractScmAndBuildInfo();
        const sourceControlBranch = ((_a = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.scmInfo) === null || _a === void 0 ? void 0 : _a.branchName) || ((_b = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _b === void 0 ? void 0 : _b.branchName);
        const sourceControlTag = ((_c = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.scmInfo) === null || _c === void 0 ? void 0 : _c.tagName) || ((_d = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _d === void 0 ? void 0 : _d.tagName);
        const sourceControlRepoUrl = userSuppliedRepositoryUrl ||
            ((_e = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.scmInfo) === null || _e === void 0 ? void 0 : _e.repoUrl) ||
            ((_f = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _f === void 0 ? void 0 : _f.repoUrl);
        const sourceControlRepoName = ((_g = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.scmInfo) === null || _g === void 0 ? void 0 : _g.repoName) || ((_h = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _h === void 0 ? void 0 : _h.repoName);
        const revision = parsed.revision ||
            ((_j = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.scmInfo) === null || _j === void 0 ? void 0 : _j.commitSha) ||
            ((_k = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _k === void 0 ? void 0 : _k.commitSha) ||
            ((_l = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _l === void 0 ? void 0 : _l.revision);
        return {
            branchName: sourceControlBranch,
            tag: sourceControlTag,
            revision,
            repoUrl: sourceControlRepoUrl,
            repoName: sourceControlRepoName,
        };
    }
    const buildInfo = new scmContextProviderV2_1.ScmContextProviderV2(process.env).extractScmAndBuildInfo();
    if (buildInfo) {
        const sourceControlBranch = (_m = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _m === void 0 ? void 0 : _m.branchName;
        const sourceControlTag = (_o = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _o === void 0 ? void 0 : _o.tagName;
        const sourceControlRepoUrl = userSuppliedRepositoryUrl !== null && userSuppliedRepositoryUrl !== void 0 ? userSuppliedRepositoryUrl : (_p = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _p === void 0 ? void 0 : _p.repoUrl;
        const sourceControlRepoName = (_q = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _q === void 0 ? void 0 : _q.repoName;
        const revision = (_v = (_t = (_r = parsed.revision) !== null && _r !== void 0 ? _r : (_s = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _s === void 0 ? void 0 : _s.commitSha) !== null && _t !== void 0 ? _t : (_u = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _u === void 0 ? void 0 : _u.revision) !== null && _v !== void 0 ? _v : (_w = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _w === void 0 ? void 0 : _w.revisionId;
        return {
            branchName: sourceControlBranch,
            tag: sourceControlTag,
            revision,
            repoUrl: sourceControlRepoUrl,
            repoName: sourceControlRepoName,
            integrationType: (_x = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _x === void 0 ? void 0 : _x.buildType,
            buildInfoUrl: (_y = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _y === void 0 ? void 0 : _y.buildInfoUrl,
            buildId: (_z = buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildInfo) === null || _z === void 0 ? void 0 : _z.buildId,
        };
    }
    return {
        revision: parsed.revision,
        repoUrl: userSuppliedRepositoryUrl,
    };
}
function getDeploymentEventWebappUrl(deploymentEvent) {
    return `${env_1.BASE_APP_URL}/workspaces/${deploymentEvent.workspace_id}/events/${deploymentEvent.id}`;
}
exports.getDeploymentEventWebappUrl = getDeploymentEventWebappUrl;
